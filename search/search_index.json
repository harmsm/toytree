{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to toytree","text":"<p>Welcome to toytree, a Python library for tree visualization, manipulation, and numerical and evolutionary analyses. If you are new to toytree, head to  the User Guide to see examples and learn about its features.</p>"},{"location":"#history","title":"History","text":"<p><code>toytree</code> is an object-oriented library built to meet the desire for a framework that combines a Python-based tree object (similar to ete3) with a more modern and minimalist graphical design framework (e.g., like toyplot). <code>toytree</code> has since expanded far beyond this simple goal, and now also provides a suite of subpackages for additional features such as tree manipulation, enumeration, comparison, and evolutionary analyses. In this respect, <code>toytree</code> aims to fill a similar role for Python as the packages 'ape' and 'phytools' do in the R language. </p>"},{"location":"#usage","title":"Usage","text":"<p><code>toytree</code> is purposefully designed to promote interactive use within jupyter notebooks where users can make use of modern Python and web development features such as tab-completion and interactive plotting that make it easy to learn and use. <code>toytree</code> can also serve as a powerful but lightweight addition to other Python projects to provide efficient tree-based and phylogenetic algorithms.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>style: beautiful \"out-of-the-box\u201d tree drawings that require minimal styling.</li> <li>customization: drawings are highly customizable and export to PDF, SVG, or HTML.</li> <li>extendable: tree drawings are easily combined with scatterplots, barplots, etc.</li> <li>io: easily and flexibly parse tree data from newick, nexus, or extended NHX formats.</li> <li>mod: manipulate tree topology, rooting, and data using efficient algorithms.</li> <li>distance: calculate distances between trees (e.g., RF) or nodes on trees (e.g., paths).</li> <li>enum: enumerate tree partitions (e.g., quartets, bipartitions) or tree space.</li> <li>multitree: visualize or analyze sets of trees (e.g., cloud_trees, consensus).</li> <li>rtree: efficiently generate random trees for testing, demonstration, or research.</li> <li>network: parse and plot phylogenetic networks.</li> <li>reproducibility: simple and readable code.</li> <li>minimalism: few dependencies, easy installation, organized modular code base.</li> <li>and more: Have a feature request? Raise a ticket on GitHub.</li> </ul>"},{"location":"FAQs/","title":"Frequently Asked Questions","text":""},{"location":"FAQs/#how-do-i-get-help","title":"How do I get help?","text":"<p>The first place to look for help or answers is in here in the documentation. You can use the search bar in the navigation to search for terms or function names. The next place is in the source documentation strings. Some of the  source code is available here in the docs, but the rest can be accessed in an interactive environment (e.g., jupyter) by executing a function name followed by one or two question marks. The docstrings often contain detailed descriptions of parameters and example usage. Finally, you can seek further help or advice by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"help wanted\" or \"question\" as the category for your issue.</p>"},{"location":"FAQs/#how-do-i-report-bug","title":"How do I report bug?","text":"<p>If you believe you have encountered a bug in toytree please let us know by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"bug\".</p>"},{"location":"FAQs/#how-can-i-request-a-new-feature","title":"How can I request a new feature","text":"<p>We are happy to implement new useful methods in toytree that will help to  grow its userbase. To request the implementation of a new method please do so by raising an Issue on GitHub. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"enhancement\". </p>"},{"location":"FAQs/#how-can-i-contribute-to-toytree","title":"How can I contribute to toytree","text":"<p>We welcome contributors! If you are interested in contributing to toytree please first read our contributor's guide. This describes a shared framework and style to ensure a cohesive coding style throughout the source code. Then, you can raise an Issue on GitHub to indicate the project you are working on. This way, you can find if others are already working on the method, or find additional contributors for help. To do this, navigate to  https://github.com/eaton-lab/toytree/issues and click the green New Issue  button in the upper right. Then click on Labels on the right to select  \"enhancement\", and under Assignees, assign your self.</p>"},{"location":"change_log/","title":"Change log","text":"<p>The changelog will be updated on each packaged release beginning with  <code>toytree</code> v.3.0. Please see the GitHub repo for more detailed commit  messages and the history prior to v.3.0.</p>"},{"location":"change_log/#202365-v300","title":"2023/6/5 (v.3.0.0)","text":"<ul> <li>new unittest framework for testing methods on GitHub CI.</li> <li>new subpackage structure to organize growing code base.</li> <li>new functools wrap to keep API and module-level methods synced.</li> <li><code>cli</code> New CLI for fast tree drawings in browser <code>toytree --ts p --width X --height Y</code></li> <li><code>color</code> New ToyColor module for easier color type validation and conversion.</li> <li><code>io</code> Improved inference of internal label type in <code>toytree.tree</code></li> <li><code>io</code> Support defaults to np.nan if not present in parsed tree.</li> <li><code>io</code> Completely new newick parser function. More flexible parsing.</li> <li><code>io</code> Nexus parser can handle more types of nexus formatting.</li> <li><code>io</code> Show informative message on NHX parsing errors/formatting. </li> <li><code>io</code> Write Node and Edge features separately to NHX format.</li> <li><code>distance</code> separated tree and node distance methods in submodules.</li> <li><code>distance</code> new faster node distance functions for path, up or down.</li> <li><code>distance</code> much faster algorithm for computing node distances.</li> <li><code>distance</code> bipartition based tree distance functions developed and tested.</li> <li><code>distance</code> quartet based tree distance functions developed and tested.</li> <li><code>mod</code> new rooting functions including minimal ancestor deviation (MAD).</li> <li><code>mod</code> added unittests for root and mod methods across wide variety of cases.</li> <li><code>core</code> set default Node.dist to 0, including for root on random trees.</li> <li><code>core</code> implemented new generic Node query method. Replace regex arg w/ \"~name\".</li> <li><code>core</code> simplified Node object, exposed iter functions, made edit funcs private.</li> <li><code>core</code> ToyTree now has <code>.edge_features</code> set to store default and additional features that should be treated as edge data. Edge data in NHX is stored as such.</li> <li><code>enum</code> created enum subpackage to group partition iterators and counters.</li> <li><code>data</code> replaced <code>get_node_values</code> with <code>get_node_data</code>.</li> <li><code>data</code> missing values in Node data default to np.nan on <code>get_node_data()</code></li> <li><code>data</code> new expand_node_mapping for faster expansion of Node queries w/ regex.</li> <li><code>drawing</code> renamed ToytreeMark to ToyTreeMark</li> <li><code>drawing</code> Use text extents when auto-building canvas size.</li> <li><code>drawing</code> Store tip coords in layout/ToyTreeMark for extents, tip angles, etc.</li> <li><code>drawing</code> used aspect='fit-range' on circular layouts.</li> <li><code>drawing</code> bugfix for circular trees 'p' edge type SVG paths.</li> <li><code>drawing</code> bugfix to allow ts='p' with new validators when no Ne feature.</li> <li><code>drawing</code> unrooted layout EA or ED algorithms with improved tip angles.</li> <li><code>style</code> New TreeStyle serialization and validation is faster and easier to debug.</li> <li><code>style</code> general color_mapping approach developed as (feature, ...).</li> <li><code>style</code> general value_mapping approach developed as (feature, ...). Replace <code>normalize_values</code>.</li> <li><code>style</code> create a 'b' builtin style for showing support values easily.</li> <li><code>style</code> use same validation method for tip and node data w/ <code>size</code> arg.</li> <li><code>annotate</code> New annotation subpackage created for extensible add-on plots.</li> <li><code>annotate</code> Basic Node/Edge annotation drawing methods developed.</li> <li><code>annotate</code> Pie charts and general rectangle/bar methods developed.</li> <li><code>annotate</code> Custom Marks to allow for shift in px units, not just data units.</li> <li><code>annotate</code> moved <code>add_scale_bar</code> and <code>axes_styling</code> methods to annotate.</li> <li><code>pcm</code> continuous and discrete brownian sim funcs w/ similar syntax.</li> <li><code>network</code> network parsing module.</li> </ul>"},{"location":"citation/","title":"Citation","text":""},{"location":"citation/#how-to-cite","title":"How to cite","text":"<p>Eaton, DAR. Toytree: A minimalist tree visualization and manipulation library for Python. Methods Ecol Evol. 2020; 11: 187\u2013 191.  https://doi.org/10.1111/2041-210X.13313</p>"},{"location":"citation/#bibtex","title":"Bibtex","text":"<pre><code>@article{eaton_toytree_2020,\n    title = {Toytree: {A} minimalist tree visualization and manipulation library for {Python}},\n    volume = {11},\n    copyright = {\u00a9 2019 The Author. Methods in Ecology and Evolution \u00a9 2019 British Ecological Society},\n    issn = {2041-210X},\n    shorttitle = {Toytree},\n    url = {https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.13313},\n    doi = {10.1111/2041-210X.13313},\n    abstract = {Toytree is a lightweight Python library for programmatically visualizing and manipulating tree-based data structures. It implements a minimalist design aesthetic and modern plotting architecture suited for interactive coding in IPython/Jupyter. Tree drawings are generated in HTML using the toyplot library backend, and display natively in Jupyter notebooks with interactivity features. Tree drawings can be combined with other plotting functions from the toyplot library (e.g. scatterplots, histograms) to create composite figures on a shared coordinate grid, and can be exported to additional formats including PNG, PDF and SVG. To parse and store tree data, toytree uses a modified fork of the ete3 TreeNode object, which includes functions for manipulating, annotating and comparing trees. Toytree integrates these functions with a plotting layout to allow node values to be extracted from trees in the correct order to style nodes for plotting. In addition, toytree provides functions for parsing additional tree formats, generating random trees, inferring consensus trees and drawing grids or clouds from multiple trees to visualize discordance. The goal of toytree is to provide a simple Python equivalent to commonly used tree manipulation and plotting libraries in R, and in doing so, to promote further development of phylogenetic and other tree-based methods in Python. Toytree is released under the GPLv3 license. Source code is available on GitHub and documentation is available at https://toytree.readthedocs.io.},\n    language = {en},\n    number = {1},\n    urldate = {2020-01-15},\n    journal = {Methods in Ecology and Evolution},\n    author = {Eaton, Deren A. R.},\n    year = {2020},\n    keywords = {phylogeny, genetics, evolution, IPython, coalescent, jupyter, notebooks, toyplot},\n    pages = {187--191},\n    file = {Full Text PDF:/home/deren/Zotero/storage/G7UTE4AR/Eaton - 2020 - Toytree A minimalist tree visualization and manip.pdf:application/pdf;Snapshot:/home/deren/Zotero/storage/SPBG3TPH/2041-210X.html:text/html},\n}\n</code></pre>"},{"location":"color-mapping/","title":"feature color-mapping","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n</pre> import toytree import toyplot import numpy as np In\u00a0[2]: Copied! <pre># example tree\ntree = toytree.rtree.bdtree(10, seed=123)\n</pre> # example tree tree = toytree.rtree.bdtree(10, seed=123) In\u00a0[3]: Copied! <pre># example: project a data feature to an array of colors \ntoytree.style.get_color_mapped_feature(tree, \"height\", \"Spectral\")\n</pre> # example: project a data feature to an array of colors  toytree.style.get_color_mapped_feature(tree, \"height\", \"Spectral\") Out[3]: In\u00a0[4]: Copied! <pre># example: map node height to colors using '(feature, cmap)' syntax\ntree.draw(\n    node_sizes=10, \n    node_mask=False, \n    node_colors=(\"height\", \"Spectral\"),\n);\n</pre> # example: map node height to colors using '(feature, cmap)' syntax tree.draw(     node_sizes=10,      node_mask=False,      node_colors=(\"height\", \"Spectral\"), ); r0r1r2r3r4r5r6r7r8r9 In\u00a0[5]: Copied! <pre># assign data to an example tree\ntree = toytree.rtree.bdtree(10, seed=123)\nrng = np.random.default_rng(seed=123)\ntree.set_node_data(\"W\", rng.random(tree.nnodes), inplace=True);\ntree.set_node_data(\"X\", np.linspace(0, 100, tree.nnodes), inplace=True);\ntree.set_node_data(\"Y\", rng.choice([\"A\", \"B\", \"C\"], tree.nnodes), inplace=True);\ntree.set_node_data(\"Z\", {i: i.X for i in tree[::2]}, inplace=True);\n</pre> # assign data to an example tree tree = toytree.rtree.bdtree(10, seed=123) rng = np.random.default_rng(seed=123) tree.set_node_data(\"W\", rng.random(tree.nnodes), inplace=True); tree.set_node_data(\"X\", np.linspace(0, 100, tree.nnodes), inplace=True); tree.set_node_data(\"Y\", rng.choice([\"A\", \"B\", \"C\"], tree.nnodes), inplace=True); tree.set_node_data(\"Z\", {i: i.X for i in tree[::2]}, inplace=True); In\u00a0[6]: Copied! <pre># show data in a table\ntree.get_node_data([\"W\", \"X\", \"Y\", \"Z\"])\n</pre> # show data in a table tree.get_node_data([\"W\", \"X\", \"Y\", \"Z\"]) Out[6]: W X Y Z 0 0.682352 0.000000 A 0.000000 1 0.053821 5.555556 B NaN 2 0.220360 11.111111 C 11.111111 3 0.184372 16.666667 A NaN 4 0.175906 22.222222 A 22.222222 5 0.812095 27.777778 A NaN 6 0.923345 33.333333 A 33.333333 7 0.276574 38.888889 B NaN 8 0.819755 44.444444 A 44.444444 9 0.889893 50.000000 B NaN 10 0.512970 55.555556 B 55.555556 11 0.244965 61.111111 A NaN 12 0.824242 66.666667 B 66.666667 13 0.213763 72.222222 A NaN 14 0.741467 77.777778 A 77.777778 15 0.629940 83.333333 B NaN 16 0.927407 88.888889 A 88.888889 17 0.231908 94.444444 C NaN 18 0.799125 100.000000 A 100.000000 In\u00a0[7]: Copied! <pre># define colors by name, rgb, or rgba\ncolor1 = \"teal\"\ncolor2 = (0.1, 0.5, 0.5)\ncolor3 = (0.1, 0.5, 0.5, 0.3)\n</pre> # define colors by name, rgb, or rgba color1 = \"teal\" color2 = (0.1, 0.5, 0.5) color3 = (0.1, 0.5, 0.5, 0.3) <p>Here I pass the three objects above to <code>toyplot.color.Palette</code>, which is an object that can parse multiple different types of color inputs and store the results as an array. A palette represents the simplest form of ColorMap, containing a discrete collection of colors. This object has a nice property for displaying a color palette in the notebook, like below.</p> In\u00a0[8]: Copied! <pre># create a Palette object to easily visualize\ncolors = toyplot.color.Palette([color1, color2, color3])\ncolors\n</pre> # create a Palette object to easily visualize colors = toyplot.color.Palette([color1, color2, color3]) colors Out[8]: In\u00a0[9]: Copied! <pre># the dtype of numpy array based colors in toyplot\ncolors[0].dtype\n</pre> # the dtype of numpy array based colors in toyplot colors[0].dtype Out[9]: <pre>dtype([('r', '&lt;f8'), ('g', '&lt;f8'), ('b', '&lt;f8'), ('a', '&lt;f8')])</pre> In\u00a0[10]: Copied! <pre># select a pre-defined discrete color palette\ntoyplot.color.brewer.palette(\"Set2\")\n</pre> # select a pre-defined discrete color palette toyplot.color.brewer.palette(\"Set2\") Out[10]: In\u00a0[11]: Copied! <pre># select a pre-defined diverging color palette\ntoyplot.color.brewer.palette(\"BlueRed\", count=8)\n</pre> # select a pre-defined diverging color palette toyplot.color.brewer.palette(\"BlueRed\", count=8) Out[11]: In\u00a0[12]: Copied! <pre># define a color palette manually\ntoyplot.color.Palette(['darkcyan', 'darkmagenta', 'goldenrod'])\n</pre> # define a color palette manually toyplot.color.Palette(['darkcyan', 'darkmagenta', 'goldenrod']) Out[12]: In\u00a0[13]: Copied! <pre># select a pre-defined diverging or linear colormap\ntoyplot.color.brewer.map(\"Spectral\")\n</pre> # select a pre-defined diverging or linear colormap toyplot.color.brewer.map(\"Spectral\") Out[13]: In\u00a0[14]: Copied! <pre># project data 'X' to colors from a colormap\ntoytree.style.get_color_mapped_feature(tree, feature=\"X\", cmap=\"Spectral\")\n</pre> # project data 'X' to colors from a colormap toytree.style.get_color_mapped_feature(tree, feature=\"X\", cmap=\"Spectral\") Out[14]: In\u00a0[15]: Copied! <pre># project data \"X\" to a named colormap\ntoytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\")\n</pre> # project data \"X\" to a named colormap toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\") Out[15]: In\u00a0[16]: Copied! <pre># project data \"W\" to a named colormap\ntoytree.style.get_color_mapped_feature(tree, \"W\", \"BlueRed\")\n</pre> # project data \"W\" to a named colormap toytree.style.get_color_mapped_feature(tree, \"W\", \"BlueRed\") Out[16]: <p>The domain min or max can be set to limit the range of colors such that multiple values at the upper or lower end of the data map to the same color. For example, here we set the max to 50 even though the max of the data we are mapping (\"X\") is 100. Consequently, the color map range is concentrated between 0-50 and all values above 50 are assigned the max color. If min and max values are not set on a colormap then it will by default use the min and max values of the data being projected. Thus, it is only relevant to set these values if you wish to condense colors at one end or the other.</p> In\u00a0[17]: Copied! <pre># create a ColorMap with a restricted range\ntoytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", domain_min=0, domain_max=50)\n</pre> # create a ColorMap with a restricted range toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", domain_min=0, domain_max=50) Out[17]: <p>The order in which values are mapped to colors in a colomap can be reversed using the <code>reverse</code> argument.</p> In\u00a0[18]: Copied! <pre># create a reversed ColorMap by name\ntoytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", reverse=True)\n</pre> # create a reversed ColorMap by name toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\", reverse=True) Out[18]: <p>The center of the colormap can be skewed towards one end or the other. Here it is set at 25, closer to the min value. This compresses the range of colors to the left of 25, and expands the range to right of 25. This can be useful if the variation among the larger values is of greater interest than among the lower values.</p> In\u00a0[19]: Copied! <pre># create a ColorMap with a skewed center\ncmap = toyplot.color.brewer.map(\"BlueRed\", domain_min=0, domain_max=100, center=25)\ntoytree.style.get_color_mapped_feature(tree, \"X\", cmap)\n</pre> # create a ColorMap with a skewed center cmap = toyplot.color.brewer.map(\"BlueRed\", domain_min=0, domain_max=100, center=25) toytree.style.get_color_mapped_feature(tree, \"X\", cmap) Out[19]: <p>By default colormapping in <code>toytree</code> using <code>get_color_mapped_feature</code> or the tuple syntax will assign \"transparent\" (i.e., <code>rgba(0, 0, 0, 0)</code>) for missing values. You can change this behavior by entering a value to use for missing data instead using the <code>nan_value</code> argument.</p> In\u00a0[20]: Copied! <pre># default behavior sets 'transparent' to missing/NaN values\ntoytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\")\n</pre> # default behavior sets 'transparent' to missing/NaN values toytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\") Out[20]: In\u00a0[21]: Copied! <pre># setting 'nan_value' imputes a data value to be colormapped for missing\ntoytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\", nan_value=0)\n</pre> # setting 'nan_value' imputes a data value to be colormapped for missing toytree.style.get_color_mapped_feature(tree, \"Z\", \"BlueRed\", nan_value=0) Out[21]: In\u00a0[22]: Copied! <pre># map a discrete feature to a list/Palette of color names\ntoytree.style.get_color_mapped_feature(tree, \"Y\", [\"red\", \"blue\", \"green\"])\n</pre> # map a discrete feature to a list/Palette of color names toytree.style.get_color_mapped_feature(tree, \"Y\", [\"red\", \"blue\", \"green\"]) Out[22]: In\u00a0[23]: Copied! <pre># map a discrete feature to a discrete colormap\ntoytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\")\n</pre> # map a discrete feature to a discrete colormap toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\") Out[23]: In\u00a0[24]: Copied! <pre># map a discrete feature to a continuous colormap \ntoytree.style.get_color_mapped_feature(tree, \"Y\", \"BlueRed\")\n</pre> # map a discrete feature to a continuous colormap  toytree.style.get_color_mapped_feature(tree, \"Y\", \"BlueRed\") Out[24]: <p>By creating the ColorMap manually you can set more additional arguments, such as the number of states, which can be used to  discretize colors at a more fine or coarse scale.</p> In\u00a0[25]: Copied! <pre># enter a colormap object\ncmap = toyplot.color.brewer.map(\"BlueRed\", count=8)\ntoytree.style.get_color_mapped_feature(tree, \"Y\", cmap)\n</pre> # enter a colormap object cmap = toyplot.color.brewer.map(\"BlueRed\", count=8) toytree.style.get_color_mapped_feature(tree, \"Y\", cmap) Out[25]: In\u00a0[26]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"BlueRed\") Out[26]: In\u00a0[27]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"Spectral\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"Spectral\") Out[27]: In\u00a0[28]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"Blackbody\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"Blackbody\") Out[28]: In\u00a0[29]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"X\", \"Greys\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"X\", \"Greys\") Out[29]: In\u00a0[30]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set1\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set1\") Out[30]: In\u00a0[31]: Copied! <pre>toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\")\n</pre> toytree.style.get_color_mapped_feature(tree, \"Y\", \"Set2\") Out[31]: In\u00a0[32]: Copied! <pre># project \"W\" values to default 'Spectral' colormap\ntree.draw(node_colors=(\"W\",), node_sizes=10, node_mask=False);\n</pre> # project \"W\" values to default 'Spectral' colormap tree.draw(node_colors=(\"W\",), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[33]: Copied! <pre># project \"Y\" values to discrete colors\ntree.draw(node_colors=(\"Y\", \"BlueRed\"), node_sizes=10, node_mask=False);\n</pre> # project \"Y\" values to discrete colors tree.draw(node_colors=(\"Y\", \"BlueRed\"), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[34]: Copied! <pre># project \"X\" in minmax range 0-50 using the default colormap\ntree.draw(node_colors=(\"X\", None, 0, 50), node_sizes=10, node_mask=False);\n</pre> # project \"X\" in minmax range 0-50 using the default colormap tree.draw(node_colors=(\"X\", None, 0, 50), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[35]: Copied! <pre># project \"Z\" to \"Greys\" colormap with nan_values set to 0 (black)\ntree.draw(node_colors=(\"Z\", \"Greys\", None, None, 0), node_sizes=10, node_mask=False);\n</pre> # project \"Z\" to \"Greys\" colormap with nan_values set to 0 (black) tree.draw(node_colors=(\"Z\", \"Greys\", None, None, 0), node_sizes=10, node_mask=False); r0r1r2r3r4r5r6r7r8r9 <p>Colormapping by the tuple syntax is also supported when using the <code>annotation</code> subpackage to add drawing annotations after initially creating a tree drawing, like in the example below.</p> In\u00a0[36]: Copied! <pre># draw a tree and add node marker annotations w/ colormapped \"X\"\ncanvas, axes, mark  = tree.draw();\ntree.annotate.add_node_markers(axes, color=(\"X\", \"BlueRed\"), mask=False);\n</pre> # draw a tree and add node marker annotations w/ colormapped \"X\" canvas, axes, mark  = tree.draw(); tree.annotate.add_node_markers(axes, color=(\"X\", \"BlueRed\"), mask=False); r0r1r2r3r4r5r6r7r8r9 In\u00a0[37]: Copied! <pre># create a custom Diverging colormap\ncol0 = toyplot.color.css(\"goldenrod\")\ncol1 = toyplot.color.css(\"darkcyan\")\ncustom_map = toyplot.color.DivergingMap(low=col0, high=col1, domain_min=0, domain_max=1)\ncustom_map\n</pre> # create a custom Diverging colormap col0 = toyplot.color.css(\"goldenrod\") col1 = toyplot.color.css(\"darkcyan\") custom_map = toyplot.color.DivergingMap(low=col0, high=col1, domain_min=0, domain_max=1) custom_map Out[37]: In\u00a0[38]: Copied! <pre>tree.draw(node_sizes=10, node_colors=(\"W\", custom_map), node_mask=False);\n</pre> tree.draw(node_sizes=10, node_colors=(\"W\", custom_map), node_mask=False); r0r1r2r3r4r5r6r7r8r9"},{"location":"color-mapping/#color-mapping","title":"Color-mapping\u00b6","text":"<p>Color mapping is a convenient method and syntax that allows for transforming/projecting raw data values into a range of valid color values drawn either from a discrete or continuous colormap. This is especially useful for visualizing a range of data values on the edges or nodes of a tree. (See Range-Mapping for a similar implementation to project continuous data to a new continuous range of values.)</p>"},{"location":"color-mapping/#quick-example","title":"Quick Example\u00b6","text":"<p>In this example we will project Node \"height\" data from a tree into a range of colors. Color mapping can be applied to any continuous or discrete data feature. This is done using the function <code>toytree.style.get_color_mapped_feature</code>, given a feature name and the name of a colormap. Below this function is used to return an array of mapped color values. This array could be passed as a node_color argument to the draw function, or, as demonstrated below, you can use the shortcut syntax by simply entering <code>(feature-name, colormap-name)</code> as a tuple into the specific field.</p>"},{"location":"color-mapping/#example-data","title":"Example Data\u00b6","text":"<p>To demonstrate color-mapping we will use a 10 tip birth-death tree with three data features assigned to Nodes of the tree. The first feature \"W\" contains random float values between 0-1. The second \"X\" contains float values sampled along a continuous range from (0-100). The third feature contains discrete str values randomly sampled from (\"A\", \"B\", \"C\"). And the final feature contains the same data as feature \"X\", but with missing values for alternating Nodes.</p>"},{"location":"color-mapping/#colors","title":"Colors\u00b6","text":"<p><code>toytree</code> relies on <code>toyplot.color</code> for parsing color data and defining color maps. Please see the incredibly good color module documentation of toyplot for more details. Here I provide a simple introduction. You can select colors in three main ways: (1) CSS color name; (2) rgb tuple; or (3) rgba tuple.</p>"},{"location":"color-mapping/#color-array-dtype","title":"Color array dtype\u00b6","text":"<p>Colors in a <code>toyplot.color</code> array are stored in a complex data format that allows for performing mathematical operations on colors, which allows for blending colors from a palette together to create gradients in colormaps. In most cases, this is an advanced feature you do not need to worry about. It is simplest to select colors by name, or by selecting them from a pre-defined palette or colormap, as described in the next section.</p>"},{"location":"color-mapping/#color-palettes","title":"Color Palettes\u00b6","text":"<p>There are a number of pre-defined color palettes that can be selected by name from the <code>toyplot.color</code> subpackage named <code>brewer</code>, which contains the popular \"brewer2\" color sets. The default color palette in <code>toyplot</code> is called Set2, and can be selected like below. A number of \"diverging\" color palettes (see more below) can also be selected and discretized into a palette by using the <code>count</code> argument to maximize divergence among the colors for the number of discrete states in a set of data.</p>"},{"location":"color-mapping/#colormaps","title":"ColorMaps\u00b6","text":"<p>A colormap (<code>toyplot.color.Map</code>) is a more advanced container for describing a distribution of colors. There are two main types of colormaps, discrete and continous. A discrete map contains a small number of colors that are typically grouped together by a shared design palette with the goal of being maximally divergent from each other. By contrast, a continuous colormap represents colors sampled along a continuous range of RGBA values such that a gradient can be easily observed spanning from minimum to maximum values in the map. The default colormaps used by <code>toytree</code> are \"Spectral\" for continous data and \"Set2\" for categorical.</p>"},{"location":"color-mapping/#get_color_mapped_feature","title":"<code>get_color_mapped_feature()</code>\u00b6","text":"<p>Here I will demonstrate color mapping using a function from <code>toytree</code> named <code>get_color_mapped_feature</code>. In practice users can use this function to transform data from a set of values into a distribution of colors in a colormap, however, it is not required, since the simpler \"tuple syntax\" can also be used when entering drawing arguments. Nevertheless, this is the function that is used under the hood to map data to colors, so it helps to understand its options and how it works. This function accepts a number of arguments to specify a tree, a feature to select data from the tree, and a colormap name. It also accepts options that can limit the upper or lower limits of the colormapped distribution, or skew the distribution, and options for dealing with missing data, all of which are demonstrated below.</p>"},{"location":"color-mapping/#continuous-map-examples","title":"Continuous map examples\u00b6","text":"<p>Here the data are extracted from the \"X\" feature on the tree, which contians values equally spaced between 0-100 assigned in order to the 18 Nodes in the tree. Thus, the colors assigned to each Node match the gradient of the colormap. In the next example, the feature \"W\" is mapped to the same colormap, which yields a very different distribution of colors, since Nodes 0-17 contain random values for this feature.</p>"},{"location":"color-mapping/#discrete-map-example","title":"Discrete map example\u00b6","text":"<p>You can similarly map discrete/categorical data to colormaps. For this you can enter either a Categorical or Linear ColorMap, which in the latter case will reduce the linear map into equally spaced discrete colors. Like before you can either enter the name of a colormap, or create a <code>ColorMap</code> object. As an even simpler option, you can simply enter a list of color names that is of the same length as the number of discrete states in the data, as shown below. Here the data are extracted from the \"Y\" feature on the tree which represents random discrete states of \"A\", \"B\" or \"C\".</p>"},{"location":"color-mapping/#best-colormaps","title":"Best ColorMaps\u00b6","text":"<p>These are are a few of my favorites:</p>"},{"location":"color-mapping/#using-color-mapping","title":"Using Color Mapping\u00b6","text":"<p>For convenience you perform colormapping in <code>toytree</code> drawing functions by using the tuple syntax, as a simpler alternative to calling the function <code>get_color_mapped_feature</code>. This simply involves entering the feature name to be colormapped inside of a tuple as <code>(feature-name,)</code>. You can provide additional arguments inside of the tuple, in order, to specify additional arguments available to the <code>get_color_mapped_feature</code> function. For example, to use a specific colormap rather than the default one you can specify the colormap name as well as <code>(feature-name, colormap-name)</code>. You can also add min, max,  and nan_value arguments, as demonstrated below.</p>"},{"location":"color-mapping/#tuple-syntax","title":"Tuple Syntax\u00b6","text":"<p>Several examples of entering colormap arguments using the tuple syntax.</p> <ul> <li>(feature,)</li> <li>(feature, cmap)</li> <li>(feature, cmap, min_value, max_value)</li> <li>(feature, cmap, min_value, max_value, nan_value)</li> <li>(feature, None, None, None, 10)</li> </ul>"},{"location":"color-mapping/#using-toyplotcolormap-objects","title":"Using toyplot.color.Map objects\u00b6","text":"<p>The function <code>get_color_mapped_feature</code> provides a convenient way to map data to colors that would otherwise require additional experience and knowledge about the <code>toyplot.color</code> library. Nevertheless,  advanced users may want to become familiar with the core objects and functions available in this library to expand the options that are available. In addition to selecting a colormap by name when using colormapping in <code>toytree</code> you can alternative pass it a <code>toyplot.color.Map</code> object and it will use this instead. This example demonstrates creating a custom colormap that blends two colors.</p>"},{"location":"command-line/","title":"Command line","text":""},{"location":"command-line/#toytree-cli","title":"<code>toytree</code> cli","text":"<p>Sometimes you might not be in the mood to open a jupyter notebook just to take a quick peek at a tree, in which case, the toytree command line interface (cli) provides a convenient alternative. This tool can be called from a terminal shell to execute one or more simple commands to accomplish tasks such as creating tree drawings, rooting trees, and comparing trees. </p>"},{"location":"command-line/#subcommands","title":"Subcommands","text":"<p>Currently three subcommands are supported in the cli: draw, root, and distance. (Please reach out and let us know if you would like to see additional toytree methods implemented in the cli.) Call the help command (-h) to see the available subcommands.</p> <pre><code>$ toytree -h\n</code></pre> <p>This will bring up a help statement like below. Each subcommand also has its own help page that describes its usage and options, as demonstrated below.</p> <pre><code>usage: toytree [-h] [-v] {draw,root,distance} ...\n\ntoytree command line tool. Select a subcommand.\n\npositional arguments:\n  {draw,root,distance}  sub-commands\n    draw                create tree drawing\n    root                (re)root tree and return to STDOUT\n    distance            compute distance between trees\n\noptions:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n\nEXAMPLE: $ toytree draw TREE -ts o -d 400 400 -v\n</code></pre>"},{"location":"command-line/#toytree-draw","title":"toytree draw","text":"<pre><code>$ toytree draw -h\n</code></pre> <pre><code>usage: toytree draw [-h] [-ts treestyle] [-d dim dim] [-o basename] [-v [app]]\n                    [-f {html,svg,pdf}]\n                    TREE\n\npositional arguments:\n  TREE               tree newick file or string\n\noptions:\n  -h, --help         show this help message and exit\n  -ts treestyle      tree style (default: n)\n  -d dim dim         width height (px) (default: (None, None))\n  -o basename        output basename[.format suffix] (default: /tmp/test)\n  -v [app]           open file with default browser or app. (default: None)\n  -f {html,svg,pdf}  output file format (default: html)\n</code></pre>"},{"location":"command-line/#toytree-root","title":"toytree root","text":"<pre><code>$ toytree root -h\n</code></pre> <pre><code>usage: toytree root [-h] [-o O [O ...]] [-r] TREE\n\npositional arguments:\n  TREE          tree newick file or string\n\noptions:\n  -h, --help    show this help message and exit\n  -o O [O ...]  outgroup\n  -r            use regex matching on outgroup string.\n</code></pre>"},{"location":"command-line/#toytree-distance","title":"toytree distance","text":"<pre><code>$ toytree distance -h\n</code></pre> <pre><code>usage: toytree distance [-h] [-m {rf,rfi,rfj,qrt}] [-n] TREE1 TREE2\n\npositional arguments:\n  TREE1                tree1 newick file or string\n  TREE2                tree2 newick file or string\n\noptions:\n  -h, --help           show this help message and exit\n  -m {rf,rfi,rfj,qrt}  distance metric method\n  -n, --normalize      normalize value between [0-1]\n</code></pre>"},{"location":"command-line/#chaining","title":"chaining","text":"<p>To indicate to the draw function that the NEWICk input is the STDOUT from the previous command, use the <code>-</code> character like below.</p> <pre><code>toytree root NEWICK | toytree draw - ...\n</code></pre>"},{"location":"consensus-trees/","title":"Consensus trees","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[7]: Copied! <pre># a single starting tree\ntree = toytree.rtree.unittree(6, seed=123)\n</pre> # a single starting tree tree = toytree.rtree.unittree(6, seed=123) In\u00a0[8]: Copied! <pre># create set of trees by randomly modifying root, internal, and tip edges\ntrees = [\n    tree\n    .mod.edges_set_node_heights({i: np.random.uniform(-0.2, 0) for i in range(tree.ntips)})\n    .mod.edges_multiplier(10)\n    .mod.edges_slider(0.1)\n    for i in range(20)\n]\n</pre> # create set of trees by randomly modifying root, internal, and tip edges trees = [     tree     .mod.edges_set_node_heights({i: np.random.uniform(-0.2, 0) for i in range(tree.ntips)})     .mod.edges_multiplier(10)     .mod.edges_slider(0.1)     for i in range(20) ] In\u00a0[4]: Copied! <pre># create a multitree\nmtree = toytree.mtree(trees)\n</pre> # create a multitree mtree = toytree.mtree(trees) In\u00a0[5]: Copied! <pre># draw a few trees to examine variation\nmtree.draw(ts='c', shared_axes=True, scale_bar=True);\n</pre> # draw a few trees to examine variation mtree.draw(ts='c', shared_axes=True, scale_bar=True); r0r1r2r3r4r500.51r0r1r2r3r4r500.51r0r1r2r3r4r500.51r0r1r2r3r4r500.51 In\u00a0[6]: Copied! <pre># get consensus tree\nctree = mtree.get_consensus_tree()\n\n# root the tree\n# ctree = ctree.mod.root_on_midpoint()\nctree = ctree.root(8, root_dist=0.28)\n\n# draw it\nctree.draw('p');\n\n# add node bars to show std of node heights\n# ...\n</pre> # get consensus tree ctree = mtree.get_consensus_tree()  # root the tree # ctree = ctree.mod.root_on_midpoint() ctree = ctree.root(8, root_dist=0.28)  # draw it ctree.draw('p');  # add node bars to show std of node heights # ... <pre>&lt;Node(idx=8)&gt; 0.28418659898121107 0.5737607504385339\n&lt;Node(idx=8)&gt; 0.2583728055227246 0.562271718955612\n&lt;Node(idx=8)&gt; 0.20776634990990392 0.4417576575275013\n&lt;Node(idx=8)&gt; 0.4966666903202328 0.9634437598395291\n&lt;Node(idx=8)&gt; 0.2796030913115508 0.5440066126849977\n&lt;Node(idx=8)&gt; 0.2209731809351428 0.4515257945911898\n&lt;Node(idx=8)&gt; 0.3956792138033278 0.8500737537447055\n&lt;Node(idx=8)&gt; 0.38938404955162453 0.8933688023632044\n&lt;Node(idx=8)&gt; 0.2496431351720949 0.48560838839973897\n&lt;Node(idx=8)&gt; 0.32479826910645115 0.642429483482034\n&lt;Node(idx=8)&gt; 0.515842588816714 1.1002762107273165\n&lt;Node(idx=8)&gt; 0.3205299499335021 0.6543663667441568\n&lt;Node(idx=8)&gt; 0.4478923071928977 0.9368206321841088\n&lt;Node(idx=8)&gt; 0.36392653442839135 0.7001000440964242\n&lt;Node(idx=8)&gt; 0.40437951030086616 0.8180741068442078\n&lt;Node(idx=8)&gt; 0.5482530379692488 1.029027637683661\n&lt;Node(idx=8)&gt; 0.45342139503569173 0.8789492137708874\n&lt;Node(idx=8)&gt; 0.5096151196401049 0.9989612640708907\n&lt;Node(idx=8)&gt; 0.24484891580343765 0.5114797463792604\n&lt;Node(idx=8)&gt; 0.24782437249402905 0.5478674408967885\n</pre> 012345678910r0r1r2r3r4r500.40.81.2 In\u00a0[\u00a0]: Copied! <pre>c = mtree1.get_consensus_tree(ultrametric=0)\nc = c.mod.root_on_midpoint()\nc = c.set_node_data(\"height\", {i: 0 for i in range(c.ntips)})\nc = c.set_node_data(\"height\", {i: c[i].height_mean for i in range(c.ntips, c.nnodes - 2)})\nc = c.set_node_data(\"height\", {c.treenode.idx: c[c.treenode.idx - 1].height_mean})\nc = c.set_node_data(\"height\", {c.treenode.idx - 1: c.treenode.height - c[c.treenode.idx - 2].dist})\n\n# c = c.set_node_data(\"height\", {5: 1.208333, 6: 1.250000, 7: 1.25 + 1.0})  # 0 for i in range(5)})\nc.get_node_data()\n</pre> c = mtree1.get_consensus_tree(ultrametric=0) c = c.mod.root_on_midpoint() c = c.set_node_data(\"height\", {i: 0 for i in range(c.ntips)}) c = c.set_node_data(\"height\", {i: c[i].height_mean for i in range(c.ntips, c.nnodes - 2)}) c = c.set_node_data(\"height\", {c.treenode.idx: c[c.treenode.idx - 1].height_mean}) c = c.set_node_data(\"height\", {c.treenode.idx - 1: c.treenode.height - c[c.treenode.idx - 2].dist})  # c = c.set_node_data(\"height\", {5: 1.208333, 6: 1.250000, 7: 1.25 + 1.0})  # 0 for i in range(5)}) c.get_node_data() In\u00a0[\u00a0]: Copied! <pre>mtree1[0].style.edge_colors = \"red\"\nmtree1[0].style.edge_widths = 10\nmtree1[0].style.edge_style.stroke_opacity = 1.0\nmtree1[1].style.edge_style.stroke = \"blue\"\nmtree1[1].style.edge_style.stroke_opacity = 1.0\n</pre> mtree1[0].style.edge_colors = \"red\" mtree1[0].style.edge_widths = 10 mtree1[0].style.edge_style.stroke_opacity = 1.0 mtree1[1].style.edge_style.stroke = \"blue\" mtree1[1].style.edge_style.stroke_opacity = 1.0 In\u00a0[\u00a0]: Copied! <pre>cons.draw(axes=a, tip_labels=False, edge_colors=\"red\", edge_type='b');\nc\n</pre> cons.draw(axes=a, tip_labels=False, edge_colors=\"red\", edge_type='b'); c In\u00a0[\u00a0]: Copied! <pre>tree = toytree.rtree.unittree(ntips=20)\ntree[0].name = \"A-really-long-string-that-becomes-cutoff-on-pdf-exporting\"\n</pre> tree = toytree.rtree.unittree(ntips=20) tree[0].name = \"A-really-long-string-that-becomes-cutoff-on-pdf-exporting\" In\u00a0[40]: Copied! <pre>c, a, m1 = tree.draw(width=500);\n</pre> c, a, m1 = tree.draw(width=500); A-really-long-string-that-becomes-cutoff-on-pdf-exportingr1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19 In\u00a0[74]: Copied! <pre>c, a, m2 = tree.draw(width=500, shrink=500);\nimport toyplot.pdf\ntoyplot.pdf.render(c, \"/tmp/longname.pdf\")\n</pre> c, a, m2 = tree.draw(width=500, shrink=500); import toyplot.pdf toyplot.pdf.render(c, \"/tmp/longname.pdf\") In\u00a0[32]: Copied! <pre>canvas, axes, mark = tree.draw(width=500, tip_labels=False)\naxes.text(\n    [0] * tree.ntips,\n    range(tree.ntips),\n    tree.get_tip_labels(),\n    annotation=False,\n    style={\"text-anchor\": \"start\", \"fill\": \"black\", \"-toyplot-anchor-shift\": 10},\n)\n</pre> canvas, axes, mark = tree.draw(width=500, tip_labels=False) axes.text(     [0] * tree.ntips,     range(tree.ntips),     tree.get_tip_labels(),     annotation=False,     style={\"text-anchor\": \"start\", \"fill\": \"black\", \"-toyplot-anchor-shift\": 10}, ) Out[32]: <pre>&lt;toyplot.mark.Text at 0x7fcbba798970&gt;</pre> A-really-long-string-that-becomes-cutoff-on-pdf-exportingr1r2r3r4r5r6r7r8r9r10r11r12r13r14r15r16r17r18r19 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"consensus-trees/#consensus-trees","title":"Consensus trees\u00b6","text":""},{"location":"consensus-trees/#same-topology-variable-edge-lengths-non-ultrametric-trees","title":"Same topology, variable edge lengths, non-ultrametric trees\u00b6","text":"<p>This is an example of a set of trees you might get as a result of running phylogenetic inference on a collection of different data sets for the same taxa using a non-clock model. A consensus tree approach provides a simple and fast way to compare trees by finding the most commonly supported clades, and their frequency. It may also be of interest to see the relative branch lengths which are stored in features like <code>dist_mean</code> and <code>dist_std</code> for each node.  With this type of dataset you would most likely want to apply a species tree inference approach, such as ASTRAL, as a model-based approach of examining the agreement among trees.</p>"},{"location":"consensus-trees/#example-xiphophorus-fishes","title":"Example: Xiphophorus fishes\u00b6","text":"<p>Data set for reconstructing a densitree figure from Cui et al. (2013). I\u2019ve taken the nexus file from the paper\u2019s dryad repository and converted it to newick and saved it online so it can be easily downloaded. The file contains 160 trees representing mrbayes consensus trees inferred for different genomic regions.</p>"},{"location":"consensus2/","title":"Consensus2","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[30]: Copied! <pre># a set of simple ultrametric trees\ntrees = ...\n</pre> # a set of simple ultrametric trees trees = ... In\u00a0[24]: Copied! <pre># a set of ultrametric (and presumably) rooted trees\naligned_rooted_trees = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\")\n</pre> # a set of ultrametric (and presumably) rooted trees aligned_rooted_trees = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\") In\u00a0[\u00a0]: Copied! <pre># a set of non-ultrametric unrooted trees\nunaligned_unrooted_trees = toytree...\n</pre> # a set of non-ultrametric unrooted trees unaligned_unrooted_trees = toytree... In\u00a0[25]: Copied! <pre>fish\n</pre> fish Out[25]: <pre>&lt;toytree.MultiTree ntrees=160&gt;</pre> In\u00a0[28]: Copied! <pre># ctree = fish.get_consensus_tree(ultrametric=True)\n</pre> # ctree = fish.get_consensus_tree(ultrametric=True) In\u00a0[29]: Copied! <pre>fish[6].draw();\n</pre> fish[6].draw(); PriapellaPsjonesiiXclemenciae_GXsignumXalvareziXmayaeXmonticolusXhelleriiXandersiXcouchianusXgordoniXmeyeriXvariatusXxiphidiumXevelynaeXmilleriXmaculatus_JpWildXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensis In\u00a0[17]: Copied! <pre>ctree.mod.root_on_minimal_ancestor_deviation(48).draw();\n</pre> ctree.mod.root_on_minimal_ancestor_deviation(48).draw(); Xbirchmanni_GARCXmalinche_CHIC2XcorteziXnezahuacoyotlXmontezumaeXmultilineatusXnigrensisXcontinensXpygmaeusXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXgordoniXmeyeriXcouchianusXvariatusXevelynaeXmilleriXxiphidiumXandersiXmaculatus_JpWildPriapellaPsjonesii In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"consensus2/#consensus-trees","title":"Consensus trees\u00b6","text":"<p>A consensus tree represents an amalgamation of information from multiple trees, usually sharing the same sets of tips. For example, a majority-rule consensus tree represents a tree composed of the most frequently observed clades among a set of trees. Consensus trees often include minimum cut-off values such that nodes are collapsed if a clade is not observed at least some minimum proportion of the time. Consensus trees can also be used to represent more complex results, such as the mean edge length, node height, or trait value observed for each clade in a tree. For exapmle, these values are commonly reported in Bayesian tree inference as the marginal posterior values.</p>"},{"location":"consensus2/#inferring-consensus-trees","title":"Inferring consensus trees\u00b6","text":"<p>Let's start by creating three different sets of trees. The first varies in topology, the second varies only in internal node heights but all trees are ultrametric (e.g., a posterior distribution of trees from mrbayes), and the last varies in all edge lengths such that trees are not ultrametric (e.g., a set of maximum likelihood inferred gene trees).</p>"},{"location":"consensus2/#example-datasets","title":"Example datasets\u00b6","text":""},{"location":"consensus2/#rooting-of-consensus-trees","title":"Rooting of consensus trees\u00b6","text":"<p>A set of input trees may be rooted or unrooted. For example, a set of bootstrap trees from a Maximum Likelihood analysis will typically contain many unrooted trees, whereas a posterior distribution of trees from a Bayesian tree inference analysis will usually contain many rooted trees. The distinction of whether the trees are rooted or not can have implications on the ... By default, <code>toytree</code> will attempt to auto-detect whether the trees are rooted or not, but this behavior can be overridden by using the argument ...</p>"},{"location":"consensus2/#consensus-features","title":"Consensus features\u00b6","text":""},{"location":"consensus2/#dist-values","title":"dist values\u00b6","text":"<p><code>dist</code> values (edge lengths) ...</p>"},{"location":"consensus2/#height-values","title":"height values\u00b6","text":"<p>...</p>"},{"location":"consensus2/#support-values","title":"support values\u00b6","text":"<p>...</p>"},{"location":"consensus2/#other-featuresdata","title":"other features/data\u00b6","text":"<p>...</p>"},{"location":"contribute/","title":"Contributing","text":"<p>Collaborator's are very welcome!</p> <p>If you haven\u2019t already, you\u2019ll want to first get familiar with the <code>toytree</code> repository at http://github.com/eaton-lab/toytree.  There you will find the source code and issue tracker where you can inquire about ongoing development, discuss planned contributions, and volunteer to take on known issues or future planned developments.</p>"},{"location":"contribute/#organization","title":"Organization","text":"<p>As of <code>toytree</code> v.3.0 the code base has been reorganized explicitly to better facilitate collaborative development. This involves the organization of code into a nested hierarchy of subpackages that share common themes. Many of these have a clear template structure which can be easily modified or extended to create new useful methods. For example, a new method could be created for annotating drawings within the <code>annotation</code> subpackage, or a new method for modifying a tree could be created in the <code>mod</code> subpackage. </p>"},{"location":"contribute/#getting-started","title":"Getting started","text":"<p>To contribute as a developer you'll need to install <code>toytree</code> from source on GitHub and install additional dependencies used for testing the code. My workflow for this is to clone the repository (in your case, a fork of the repo) and install in development mode using pip.</p> <pre><code># install dependencies from conda\n$ conda install toytree -c eaton-lab --only-deps\n\n# clone the repo and cd into it\n$ git clone https://github.com/eaton-lab/toytree.git\n$ cd toytree/\n\n# call pip install in 'development mode' (note the '-e .')\n$ pip install -e .\n</code></pre>"},{"location":"contribute/#coding-style","title":"Coding Style","text":"<p>The Toyplot source code follows the PEP-8 Style Guide for Python Code.</p>"},{"location":"core/","title":"Core toytree class objects","text":"<p>...</p>"},{"location":"data/","title":"Data/Features","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport toyplot\nimport numpy as np\n</pre> import toytree import toyplot import numpy as np In\u00a0[2]: Copied! <pre># an example tree\ntree = toytree.rtree.unittree(ntips=5, seed=123)\n</pre> # an example tree tree = toytree.rtree.unittree(ntips=5, seed=123) In\u00a0[3]: Copied! <pre># set the feature \"X\" to a value of 10 on all Nodes in a tree\ntree.set_node_data(feature=\"X\", default=10, inplace=True);\n</pre> # set the feature \"X\" to a value of 10 on all Nodes in a tree tree.set_node_data(feature=\"X\", default=10, inplace=True); In\u00a0[4]: Copied! <pre># get the values of \"X\" for all Nodes in idx traversal order\ntree.get_node_data(\"X\")\n</pre> # get the values of \"X\" for all Nodes in idx traversal order tree.get_node_data(\"X\") Out[4]: <pre>0    10\n1    10\n2    10\n3    10\n4    10\n5    10\n6    10\n7    10\n8    10\ndtype: int64</pre> In\u00a0[5]: Copied! <pre># chain the two functions together to set &amp; get values for a feature\ntree.set_node_data(\"X\", default=10).get_node_data(\"X\")\n</pre> # chain the two functions together to set &amp; get values for a feature tree.set_node_data(\"X\", default=10).get_node_data(\"X\") Out[5]: <pre>0    10\n1    10\n2    10\n3    10\n4    10\n5    10\n6    10\n7    10\n8    10\ndtype: int64</pre> In\u00a0[6]: Copied! <pre># all feature names assigned to at least one Node in this tree\ntree.features\n</pre> # all feature names assigned to at least one Node in this tree tree.features Out[6]: <pre>('idx', 'name', 'height', 'dist', 'support', 'X')</pre> In\u00a0[7]: Copied! <pre># set a value for the attribute (feature) named \"Z\" on two Nodes\ntree[0].Z = \"A\"\ntree[1].Z = \"B\"\n</pre> # set a value for the attribute (feature) named \"Z\" on two Nodes tree[0].Z = \"A\" tree[1].Z = \"B\" <p>When the <code>get_node_data</code> function is called without any features selected it returns a dataframe showing all features on the current tree. Here, this tree includes the five default features in addition to the new feature \"X\" for which we assigned a value of 10 to all Nodes above, and it also includes the attribute \"Z\", which has been assigned to only two Nodes in the tree. For other Nodes that do not contain a \"Z\" feature a default missing value of NaN (numpy.nan) is returned in the dataframe (but note, NaN is not assigned to the \"Z\" attribute of the other Nodes by this function).</p> In\u00a0[8]: Copied! <pre># return a dataframe with all feature data\ntree.get_node_data()\n</pre> # return a dataframe with all feature data tree.get_node_data() Out[8]: idx name height dist support X Z 0 0 r0 0.000000 0.333333 NaN 10 A 1 1 r1 0.000000 0.333333 NaN 10 B 2 2 r2 0.000000 0.666667 NaN 10 NaN 3 3 r3 0.000000 0.666667 NaN 10 NaN 4 4 r4 0.000000 0.666667 NaN 10 NaN 5 5 0.333333 0.333333 NaN 10 NaN 6 6 0.666667 0.333333 NaN 10 NaN 7 7 0.666667 0.333333 NaN 10 NaN 8 8 1.000000 0.000000 NaN 10 NaN In\u00a0[9]: Copied! <pre># set data to feature \"Y\" for two Nodes \ndata = {0: 10, 1: 20, 2: 30}\ntree.set_node_data(\"Y\", data=data).get_node_data(\"Y\")\n</pre> # set data to feature \"Y\" for two Nodes  data = {0: 10, 1: 20, 2: 30} tree.set_node_data(\"Y\", data=data).get_node_data(\"Y\") Out[9]: <pre>0    10.0\n1    20.0\n2    30.0\n3     NaN\n4     NaN\n5     NaN\n6     NaN\n7     NaN\n8     NaN\ndtype: float64</pre> <p>In this example the data dictionary selects nodes using a variety of Node Queries. The first is a regular expression that matches the first four nodes in the tree, the second matches the node named \"r4\", and the last matches the node with int index of 8. Finally, we use the <code>default</code> arg to set a value of 0 to all other Nodes not selected in the data dict. In this way, we easily assigned to all 9 nodes in the tree without having to write a value for each.</p> In\u00a0[10]: Copied! <pre># set data to feature \"Y\" using a dict w/ node queries, and the default arg\ndata = {\"~r[0-3]\": 10, \"r4\": 20, 8: 50}\ntree.set_node_data(feature=\"Y\", data=data, default=0).get_node_data(\"Y\")\n</pre> # set data to feature \"Y\" using a dict w/ node queries, and the default arg data = {\"~r[0-3]\": 10, \"r4\": 20, 8: 50} tree.set_node_data(feature=\"Y\", data=data, default=0).get_node_data(\"Y\") Out[10]: <pre>0    10\n1    10\n2    10\n3    10\n4    20\n5     0\n6     0\n7     0\n8    50\ndtype: int64</pre> <p>The <code>inherit</code> arg provides another convenient way to assign data to Nodes in a tree based on their hierarchical relationships. For example, to assign a trait value that is inherited by all descendants of a particular node in a tree you need only to assign the value to one or more internal nodes while using the <code>inherit=True</code> argument. The inherited values are assigned to nodes in order from root to tips so that you can enter values for nested clades using this argument.</p> In\u00a0[11]: Copied! <pre># set data to feature \"Y\" for a clade using inherit=True\ntree.set_node_data(\"Y\", data={6: True}, inherit=True).get_node_data(\"Y\")\n</pre> # set data to feature \"Y\" for a clade using inherit=True tree.set_node_data(\"Y\", data={6: True}, inherit=True).get_node_data(\"Y\") Out[11]: <pre>0    True\n1    True\n2    True\n3     NaN\n4     NaN\n5    True\n6    True\n7     NaN\n8     NaN\ndtype: object</pre> In\u00a0[12]: Copied! <pre># set data using an array of random int values\ndata = np.random.randint(10, 20, size=tree.nnodes)\ntree.set_node_data(feature=\"Y\", data=data).get_node_data(\"Y\")\n</pre> # set data using an array of random int values data = np.random.randint(10, 20, size=tree.nnodes) tree.set_node_data(feature=\"Y\", data=data).get_node_data(\"Y\") Out[12]: <pre>0    14\n1    11\n2    19\n3    10\n4    16\n5    11\n6    17\n7    14\n8    15\ndtype: int64</pre> In\u00a0[13]: Copied! <pre># return values for feature \"dist\"\ntree.get_node_data(feature=\"dist\")\n</pre> # return values for feature \"dist\" tree.get_node_data(feature=\"dist\") Out[13]: <pre>0    0.333333\n1    0.333333\n2    0.666667\n3    0.666667\n4    0.666667\n5    0.333333\n6    0.333333\n7    0.333333\n8    0.000000\ndtype: float64</pre> In\u00a0[14]: Copied! <pre># return values for feature 'Z' which has data for only 2 Nodes\ntree.get_node_data(\"Z\")\n</pre> # return values for feature 'Z' which has data for only 2 Nodes tree.get_node_data(\"Z\") Out[14]: <pre>0      A\n1      B\n2    NaN\n3    NaN\n4    NaN\n5    NaN\n6    NaN\n7    NaN\n8    NaN\ndtype: object</pre> In\u00a0[15]: Copied! <pre># return values for feature 'Z' with an imputed missing value\ntree.get_node_data(\"Z\", missing=\"C\")\n</pre> # return values for feature 'Z' with an imputed missing value tree.get_node_data(\"Z\", missing=\"C\") Out[15]: <pre>0    A\n1    B\n2    C\n3    C\n4    C\n5    C\n6    C\n7    C\n8    C\ndtype: object</pre> <p>The pandas Series object is convenient to work with since it is accepted by many other <code>toytree</code> functions as input, and can can be easily converted to other object types, as demonstrated below.</p> In\u00a0[16]: Copied! <pre># convert a single trait Series to a dict\ntree.get_node_data(\"Z\", missing=\"C\").to_dict()\n</pre> # convert a single trait Series to a dict tree.get_node_data(\"Z\", missing=\"C\").to_dict() Out[16]: <pre>{0: 'A', 1: 'B', 2: 'C', 3: 'C', 4: 'C', 5: 'C', 6: 'C', 7: 'C', 8: 'C'}</pre> In\u00a0[17]: Copied! <pre># convert a single trait Series to a numpy ndarray\ntree.get_node_data(\"Z\", missing=\"C\").values\n</pre> # convert a single trait Series to a numpy ndarray tree.get_node_data(\"Z\", missing=\"C\").values Out[17]: <pre>array(['A', 'B', 'C', 'C', 'C', 'C', 'C', 'C', 'C'], dtype=object)</pre> In\u00a0[18]: Copied! <pre># return Node values for all features\ntree.get_node_data()\n</pre> # return Node values for all features tree.get_node_data() Out[18]: idx name height dist support X Z 0 0 r0 0.000000 0.333333 NaN 10 A 1 1 r1 0.000000 0.333333 NaN 10 B 2 2 r2 0.000000 0.666667 NaN 10 NaN 3 3 r3 0.000000 0.666667 NaN 10 NaN 4 4 r4 0.000000 0.666667 NaN 10 NaN 5 5 0.333333 0.333333 NaN 10 NaN 6 6 0.666667 0.333333 NaN 10 NaN 7 7 0.666667 0.333333 NaN 10 NaN 8 8 1.000000 0.000000 NaN 10 NaN In\u00a0[19]: Copied! <pre># return values for two features, with different imputed missing values\ntree.get_node_data([\"support\", \"Z\"], missing=[100, \"C\"])\n</pre> # return values for two features, with different imputed missing values tree.get_node_data([\"support\", \"Z\"], missing=[100, \"C\"]) Out[19]: support Z 0 100 A 1 100 B 2 100 C 3 100 C 4 100 C 5 100 C 6 100 C 7 100 C 8 100 C In\u00a0[20]: Copied! <pre># set a color name as 'red' or 'blue' to all nodes for feature \"C\"\ntree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True).get_node_data(\"C\")\n</pre> # set a color name as 'red' or 'blue' to all nodes for feature \"C\" tree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True).get_node_data(\"C\") Out[20]: <pre>0     red\n1     red\n2     red\n3    blue\n4    blue\n5     red\n6     red\n7    blue\n8    blue\ndtype: object</pre> In\u00a0[21]: Copied! <pre># set random float values in (0-1) to all nodes for feature \"D\"\ntree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True).get_node_data(\"D\")\n</pre> # set random float values in (0-1) to all nodes for feature \"D\" tree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True).get_node_data(\"D\") Out[21]: <pre>0    0.773484\n1    0.840667\n2    0.503796\n3    0.736419\n4    0.374351\n5    0.737745\n6    0.537203\n7    0.387983\n8    0.136558\ndtype: float64</pre> <p>(1) The first method for extracting data from a tree to use for plotting makes use of the <code>get_node_data</code> function call. Here we call the function from the same tree object that is being plotted, and select the feature \"C\" of discrete data values. This returns a Series object with the values in the correct order (idxorder) for plotting on the nodes, which are then parsed as a <code>node_colors</code> argument.</p> In\u00a0[22]: Copied! <pre># draw with node colors entered from the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\"));\n</pre> # draw with node colors entered from the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\")); r0r1r2r3r4 <p>(2) The second method for extracting data from a tree uses a simpler syntax, entering only the feature name as a string to the <code>node_colors</code> argument. Here, the <code>draw</code> function will identify that \"C\" is a valid feature of this tree object, and it will extract the \"C\" feature data from the tree. Compared to the syntax above, this looks cleaner, but has the downside that you cannot enter additional options to fill a value for missing data.</p> In\u00a0[23]: Copied! <pre># draw with node colors automatically extracted from the \"C\" feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=\"C\");\n</pre> # draw with node colors automatically extracted from the \"C\" feature tree.draw(node_sizes=15, node_mask=False, node_colors=\"C\"); r0r1r2r3r4 <p>(3) The third method uses toytree's \"tuple syntax\" that is used for range and color mapping (See range-mapping and color-mapping). For colors, you can enter (feature name, colormap, min-value, max-value, nan-value), to map any feature to any range of colors in a colormap. Only the first argument is required, with additional args providing style options, as shown below.</p> In\u00a0[24]: Copied! <pre># draw with node colors extracted and colormapped from the \"C\" feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\",));\n</pre> # draw with node colors extracted and colormapped from the \"C\" feature tree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\",)); r0r1r2r3r4 In\u00a0[25]: Copied! <pre># draw with node colors extracted and colormapped to BlueRed from \"C\"\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\", \"BlueRed\"));\n</pre> # draw with node colors extracted and colormapped to BlueRed from \"C\" tree.draw(node_sizes=15, node_mask=False, node_colors=(\"C\", \"BlueRed\")); r0r1r2r3r4 In\u00a0[26]: Copied! <pre># draw with node colors extracted and colormapped to BlueRed from \"D\"\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"BlueRed\"));\n</pre> # draw with node colors extracted and colormapped to BlueRed from \"D\" tree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"BlueRed\")); r0r1r2r3r4 In\u00a0[27]: Copied! <pre># draw a feature as EDGE data \ntree.draw(\n    node_mask=False, \n    node_labels=\"idx\", \n    node_labels_style={'font-size': 18},\n    node_as_edge_data=True,\n);\n</pre> # draw a feature as EDGE data  tree.draw(     node_mask=False,      node_labels=\"idx\",      node_labels_style={'font-size': 18},     node_as_edge_data=True, ); 0123456r0r1r2r3r4 In\u00a0[28]: Copied! <pre># draw a feature as EDGE data for the same tree, unrooted.\ntree.unroot().draw(\n    node_mask=False, \n    node_labels=\"idx\", \n    node_labels_style={'font-size': 18},\n    node_as_edge_data=True,\n);\n</pre> # draw a feature as EDGE data for the same tree, unrooted. tree.unroot().draw(     node_mask=False,      node_labels=\"idx\",      node_labels_style={'font-size': 18},     node_as_edge_data=True, ); 0123456r0r1r2r3r4 <p>Annotation methods can also be used to plot edge data. See the annotation docs.</p> In\u00a0[29]: Copied! <pre># annotate a tree with EDGE data\ncanvas, axes, mark = tree.draw();\ntree.annotate.add_edge_labels(axes=axes, labels=\"idx\", font_size=18, mask=False);\n</pre> # annotate a tree with EDGE data canvas, axes, mark = tree.draw(); tree.annotate.add_edge_labels(axes=axes, labels=\"idx\", font_size=18, mask=False); r0r1r2r3r40123456"},{"location":"data/#datafeatures","title":"Data/Features\u00b6","text":"<p>A common mistake that users make when working with tree data arises from incorrectly assigning trait values to nodes of the tree. This is most prevalent when trait data are stored in a matrix or dataframe separate from the tree object itself, and operations such as re-rooting or ladderizing are applied to the tree. It is important that trees and trait data are kept in sync. To avoid this problem, we recommend using <code>ToyTree</code> objects themselves as the primary data storage object in your analyses. It is very simple to assign data to nodes of a tree, and to fetch data back from a tree as a dataframe, or in various alternative formats. A recommended workflow for working with data on trees is demonstrated in this section.</p>"},{"location":"data/#simple-example","title":"Simple Example\u00b6","text":"<p>The functions <code>set_node_data</code> and <code>get_node_data</code> provide a broad suite of functionality for setting data to one or more nodes on a tree and subsequently fetching the data back in a variety of formats, and in the correct order for plotting. By default the data setting function returns a modified copy of the tree with new data assigned, however, you can optionally use the argument <code>inplace=True</code> to set data on the tree object inplace. In either case, a tree is returned by the function, which allows for optionally chaining it with the data getter function to subsequently return the data for one or more node features.</p>"},{"location":"data/#features","title":"Features\u00b6","text":"<p>In <code>toytree</code> terminology a \"feature\" refers the name of trait for which data is stored to nodes in a tree. For example, each <code>ToyTree</code> has several data features by default, such as <code>name</code>, <code>dist</code>, and <code>support</code>. You can create and store data under any arbitrary feature name (except for a few disallowed names and characters), and, in fact when you load a tree from a newick, NHX, or NEXUS formatted data file created by a phylogenetic tree inference program, it will often contain additional metadata that will be loaded as features. Several examples of this are shown in tree parsing documentation. A <code>ToyTree</code> contains a dynamic propery <code>.features</code> containing all feature names currently assigned to that tree. (This includes any feature that is assigned to at least one Node in the tree, but it does not need to be assigned to every Node in the tree.)</p>"},{"location":"data/#data-as-node-attributes","title":"Data as Node attributes\u00b6","text":"<p>When storing data to a <code>ToyTree</code> it is actually stored to individual <code>Node</code> objects as Node attributes. This is demonstrated below where data is assigned to a feature named \"Z\" for two Nodes in the tree. Setting and retrieving data directly from Nodes as attributes like this is the fastest way to set/get data, and is thus especially useful for developers. However, for general <code>toytree</code> usage, we recommend using the helper functions <code>set_node_data</code> and <code>get_node_data</code> to set and retrieve data as they provide a number of benefits, especially in terms of dealing with missing values, checking data types, and ordering data values.</p>"},{"location":"data/#set-node-data","title":"Set Node data\u00b6","text":"<p>The <code>set_node_data</code> function is the general recommended way to assign data to nodes on a tree. Data can be entered using either a dictionary or sequence of values, and a number of options are available to make it easier to assign values to many nodes without having to type each out individually. A related function is also available, <code>set_node_data_from_dataframe</code>, which allows setting multiple features at the same time from tabular data loaded as a pandas DataFrame. Here, however, we will focus on adding single features at a time.</p>"},{"location":"data/#setting-data-by-dict","title":"Setting data by dict\u00b6","text":"<p>The simplest way to enter specific data values is by using a dictionary. The keys of the dictionary can correspond to any valid Node Query to select one or more Nodes, and the corresponding value will be assigned to these Nodes. Notably, you can enter a dict selecting only a few Nodes and a feature will be assigned to those Nodes, and not to any of the other Nodes not entered in the dict. If you want to assign a default value to all other nodes you can do so using  <code>default</code> argument. Finally, the argument <code>inherit</code> can be used to also assign a value to all descendants of a selected Node. Examples of each of these is shown below.</p>"},{"location":"data/#setting-data-by-array","title":"Setting data by array\u00b6","text":"<p>You can alternatively set data to all Nodes in a tree by entering the values as a sequence (e.g., list, ndarray, Series) in Node idx order. Note that this requires you to have already properly ordered your input data and to be aware of the Node idx order of your current tree. Thus, this method is more error prone than assigning data by dictionary. Nevertheless, the option is available. Here we use it to assign random integer values to all Nodes by using the <code>numpy.random</code> library to generate an array of random ints.</p>"},{"location":"data/#get-node-data","title":"Get Node data\u00b6","text":"<p>The <code>get_node_data</code> function is used to retrieve feature data that has been assigned to Nodes in a tree, and to return them in the correct idx order for plotting. Data can be returned for a single feature as a pandas Series, or for multiple features as a pandas DataFrame. When a feature has not been assigned to all Nodes in a tree a default value of <code>np.nan</code> will be returned for missing values, but this can be changed to any arbitrary alternative value by entering an argument for the option <code>missing</code>.</p>"},{"location":"data/#get-a-single-feature","title":"Get a single feature\u00b6","text":"<p>By entering the name of a feature in the tree a pandas Series will be returned with all of the Node values for that feature. Here the Series index contains Node idx labels representing the Nodes in an idxorder traversal of the tree.</p>"},{"location":"data/#get-multiple-features","title":"Get multiple features\u00b6","text":"<p>By default the <code>get_node_data</code> function returns a DataFrame with data for all features in a tree. In addition to the option to subselect a single feature from the tree, as shown above, you can also select a subset of features to return a DataFrame containing just those features. Finally, an important feature of this function is its application for dealing with missing data. The <code>missing</code> argument can accept either a single value to assign to all missing values in the DataFrame, or a list of values to apply separately to each column.</p>"},{"location":"data/#using-features","title":"Using features\u00b6","text":"<p>One of the primary uses for assigning data to nodes on a tree is to visualize the data. Many arguments to the tree drawing functions accept values to designate the size, color, width, etc. of nodes or edges. These can be entered in three main ways: (1) by extracting the data as a Series using <code>get_node_data</code>; (2) by entering the feature name directly as an argument; and (3) by using range or color mapping. The latter to cases simply provide a shorthand syntax for plotting a feature which use <code>get_node_data</code> under the hood. Examples are shown below for the two features, \"C\" and \"D\", representing a discrete and continuous data set.</p>"},{"location":"data/#node-vs-edge-features","title":"Node vs Edge features\u00b6","text":"<p>Some data stored to a tree are intended to represent information about the edges (splits) in a tree, rather than information about the nodes. This is important as these types of data must be treated differently when doing things like re-rooting a tree, and in some cases, for visualization. (See the rooting tutorial for an example of how this is automatically handled in <code>toytree</code>.) Any feature can be optionally plotted as a marker and/or label on edges of a tree rather than on nodes. This can be done in a simple way within the <code>.draw</code> function by using the argument <code>node_as_edge_data=True</code>, or, it can be done with many more options by using functions in the <code>toytree.annotate</code> subpackage.</p> <p>Examples of plotted edge features are shown below. These have a few key features in visualization: (1) values are plotted on the midpoint of edges; (2) No value is shown for the root edge, since it does not represent a true split in the tree; and (3) only one of the two edges descended from the root show a value, since these are actually the same edge, but on which the root node has been placed. As an example of this last point, a value such as a support score, or edge length, is a feature of this entire edge. Thus, the value is the same whether the tree is rooted or unrooted, as shown below.</p>"},{"location":"drawing-basics/","title":"draw basics","text":"In\u00a0[27]: Copied! <pre>import toytree\nimport numpy as np\n\n# an example tree\ntree = toytree.rtree.bdtree(ntips=6, seed=123)\n</pre> import toytree import numpy as np  # an example tree tree = toytree.rtree.bdtree(ntips=6, seed=123) In\u00a0[28]: Copied! <pre># returns the three drawing objects\ntree.draw()\n</pre> # returns the three drawing objects tree.draw() Out[28]: <pre>(&lt;toyplot.canvas.Canvas at 0x7f0edbe44be0&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7f0edbf9d660&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7f0edbf6eb90&gt;)</pre> r0r1r2r3r4r5 <p>Throughout this documentation you will see many <code>toytree</code> drawing commands end with a semicolon (;), which is a simple method to hide the returned objects from being displayed in the output cell.</p> In\u00a0[29]: Copied! <pre># semicolon hides the returned objects, but drawing still autorenders\ntree.draw();\n</pre> # semicolon hides the returned objects, but drawing still autorenders tree.draw(); r0r1r2r3r4r5 In\u00a0[30]: Copied! <pre># store the drawing objects as variables\ncanvas, axes, mark = tree.draw()\n</pre> # store the drawing objects as variables canvas, axes, mark = tree.draw() r0r1r2r3r4r5 In\u00a0[85]: Copied! <pre># drawing with pre-built tree_styles\ntree.draw(tree_style='s');  # simple-style\ntree.draw(tree_style='c');  # coalescent-style\ntree.draw(tree_style='r');  # R-style\ntree.draw(tree_style='p');  # population-style\ntree.draw(tree_style='d');  # dark-style\ntree.draw(tree_style='o');  # umlaut-style\n</pre> # drawing with pre-built tree_styles tree.draw(tree_style='s');  # simple-style tree.draw(tree_style='c');  # coalescent-style tree.draw(tree_style='r');  # R-style tree.draw(tree_style='p');  # population-style tree.draw(tree_style='d');  # dark-style tree.draw(tree_style='o');  # umlaut-style 012345678910r0r1r2r3r4r5 r0r1r2r3r4r500.511.5 1-14-23-21-20r0r1r2r3r4r5 012345678910r0r1r2r3r4r500.511.5 r0r1r2r3r4r5 r0r1r2r3r4r5 <p>You can think of setting a <code>tree_style</code> as changing the baseline style on top of which additional drawing arguments can still be added. For example, here we select the \"dark\" tree style, which changes the default edge and tip colors, and on top of this we can still specify a change to the layout, node marker type, node size, and/or other drawing options.</p> In\u00a0[38]: Copied! <pre># tree_style is a baseline on top of which additional styles can be added\ntree.draw(tree_style='d', layout='d', node_markers=\"s\", node_sizes=8, height=250);\n</pre> # tree_style is a baseline on top of which additional styles can be added tree.draw(tree_style='d', layout='d', node_markers=\"s\", node_sizes=8, height=250); r0r1r2r3r4r5 In\u00a0[39]: Copied! <pre>tree.draw(\n    node_sizes=8, node_markers=\"&gt;\", node_mask=False,\n    edge_colors=\"darkmagenta\", edge_style={\"opacity\": 0.3}, edge_type=\"c\", \n    scale_bar=True,\n);\n</pre> tree.draw(     node_sizes=8, node_markers=\"&gt;\", node_mask=False,     edge_colors=\"darkmagenta\", edge_style={\"opacity\": 0.3}, edge_type=\"c\",      scale_bar=True, ); r0r1r2r3r4r51.510.50 In\u00a0[13]: Copied! <pre># define a re-usable style dictionary\nmystyle = {\n    \"layout\": 'd',\n    \"edge_type\": 'p',\n    \"edge_style\": {\n        \"stroke\": \"black\",\n        \"stroke-width\": 2.5,\n    },\n    \"tip_labels_align\": True,\n    \"tip_labels_colors\": \"darkcyan\",\n    \"tip_labels_style\": {\n        \"font-size\": \"15px\"\n    },\n    \"node_labels\": False,\n    \"node_sizes\": 8,\n    \"node_colors\": \"goldenrod\",\n    \"node_mask\": False,\n}\n\n# apply the custom treestyle dict to a drawing\ntree.draw(**mystyle);\n</pre> # define a re-usable style dictionary mystyle = {     \"layout\": 'd',     \"edge_type\": 'p',     \"edge_style\": {         \"stroke\": \"black\",         \"stroke-width\": 2.5,     },     \"tip_labels_align\": True,     \"tip_labels_colors\": \"darkcyan\",     \"tip_labels_style\": {         \"font-size\": \"15px\"     },     \"node_labels\": False,     \"node_sizes\": 8,     \"node_colors\": \"goldenrod\",     \"node_mask\": False, }  # apply the custom treestyle dict to a drawing tree.draw(**mystyle); r0r1r2r3r4r5 In\u00a0[14]: Copied! <pre># set a style that will persist on an individual tree object\nstree = tree.copy()\nstree.style.edge_colors = \"darkcyan\"\nstree.style.edge_widths = 2.5\nstree.style.node_mask = False\nstree.style.node_sizes = 16\nstree.style.node_markers = \"s\"\nstree.style.node_style.fill_opacity = 0.5\nstree.style.node_labels = \"idx\"\nstree.style.tip_labels_style.font_size = 16\nstree.style.tip_labels_style.anchor_shift = 25\nstree.draw();\n</pre> # set a style that will persist on an individual tree object stree = tree.copy() stree.style.edge_colors = \"darkcyan\" stree.style.edge_widths = 2.5 stree.style.node_mask = False stree.style.node_sizes = 16 stree.style.node_markers = \"s\" stree.style.node_style.fill_opacity = 0.5 stree.style.node_labels = \"idx\" stree.style.tip_labels_style.font_size = 16 stree.style.tip_labels_style.anchor_shift = 25 stree.draw(); 012345678910r0r1r2r3r4r5 In\u00a0[16]: Copied! <pre># hover over nodes to see pop-up elements\ntree.draw(\n    node_sizes=18, \n    node_style={\"fill-opacity\": 0.75, \"stroke\": \"white\", \"stroke-width\": 2.5},\n    node_mask=(0, 1, 0),\n    node_labels=\"idx\",\n    node_labels_style={\"font-size\": 14, \"fill\": \"white\"},\n    node_colors=(\"idx\", \"BlueRed\", 6, 9),\n    node_markers=\"s\",\n    node_hover=True, \n);\n</pre> # hover over nodes to see pop-up elements tree.draw(     node_sizes=18,      node_style={\"fill-opacity\": 0.75, \"stroke\": \"white\", \"stroke-width\": 2.5},     node_mask=(0, 1, 0),     node_labels=\"idx\",     node_labels_style={\"font-size\": 14, \"fill\": \"white\"},     node_colors=(\"idx\", \"BlueRed\", 6, 9),     node_markers=\"s\",     node_hover=True,  ); idx: 6 dist: 0.596972495123 support: nan height: 1.12630250437 name: 1-1 tdiv: 0.5969724951236idx: 7 dist: 0.0386582269365 support: nan height: 0.177873309174 name: 4-2 tdiv: 1.545401690327idx: 8 dist: 0.783873618514 support: nan height: 0.216531536111 name: 3-2 tdiv: 1.506743463388idx: 9 dist: 0.722869844869 support: nan height: 1.00040515462 name: 1-2 tdiv: 0.5969724951239r0r1r2r3r4r5 In\u00a0[17]: Copied! <pre># hover over nodes to see pop-up elements\ntree.draw(node_sizes=12);\n</pre> # hover over nodes to see pop-up elements tree.draw(node_sizes=12); r0r1r2r3r4r5 In\u00a0[82]: Copied! <pre>tree.draw(node_sizes=(\"height\", 5, 20));\n</pre> tree.draw(node_sizes=(\"height\", 5, 20)); r0r1r2r3r4r5 In\u00a0[77]: Copied! <pre>tree.draw(node_sizes=(\"height\",));\n</pre> tree.draw(node_sizes=(\"height\",)); r0r1r2r3r4r5 In\u00a0[14]: Copied! <pre># mask=False reveals all nodes\ntree.draw(node_mask=False, node_sizes=12);\n</pre> # mask=False reveals all nodes tree.draw(node_mask=False, node_sizes=12); r0r1r2r3r4r5 In\u00a0[15]: Copied! <pre># mask=True masks all nodes\ntree.draw(node_mask=True, node_sizes=12);\n</pre> # mask=True masks all nodes tree.draw(node_mask=True, node_sizes=12); r0r1r2r3r4r5 In\u00a0[16]: Copied! <pre># mask=[True, False, True, ...] shows Nodes with True\nmask = tree.get_node_mask(show_tips=True, show_root=True, show_internal=False)\nprint(mask)\ntree.draw(node_mask=mask, node_sizes=12);\n</pre> # mask=[True, False, True, ...] shows Nodes with True mask = tree.get_node_mask(show_tips=True, show_root=True, show_internal=False) print(mask) tree.draw(node_mask=mask, node_sizes=12); <pre>[ True  True  True  True  True  True False False False False  True]\n</pre> r0r1r2r3r4r5 In\u00a0[17]: Copied! <pre># mask=[True, False, True, ...] shows Nodes with True\nmask = tree.get_node_mask(\"~r[0-5]\")\nprint(mask)\ntree.draw(node_mask=mask, node_sizes=12);\n</pre> # mask=[True, False, True, ...] shows Nodes with True mask = tree.get_node_mask(\"~r[0-5]\") print(mask) tree.draw(node_mask=mask, node_sizes=12); <pre>[ True  True  True  True  True  True False False False False False]\n</pre> r0r1r2r3r4r5 In\u00a0[279]: Copied! <pre># mask=[True, False, True, ...] shows a subset of Nodes\nmask = tree.get_node_mask(2, 3, 7, 8)\nprint(mask)\ntree.draw(node_mask=mask, node_sizes=15, node_labels=\"idx\");\n</pre> # mask=[True, False, True, ...] shows a subset of Nodes mask = tree.get_node_mask(2, 3, 7, 8) print(mask) tree.draw(node_mask=mask, node_sizes=15, node_labels=\"idx\"); 2378r0r1r2r3r4r5 In\u00a0[24]: Copied! <pre># apply square markers to all nodes\ntree.draw(node_sizes=10, node_markers=\"s\");\n</pre> # apply square markers to all nodes tree.draw(node_sizes=10, node_markers=\"s\"); r0r1r2r3r4r5 In\u00a0[35]: Copied! <pre># apply rectangle markers to each node\ntree.draw(node_sizes=15, node_markers=\"r2x1\");\n</pre> # apply rectangle markers to each node tree.draw(node_sizes=15, node_markers=\"r2x1\"); r0r1r2r3r4r5 In\u00a0[36]: Copied! <pre># apply a rectangle marker with width scaled to n digits in data\nrects = [f\"r{len(str(i))}x1\" for i in tree.get_node_data(\"idx\")]\ntree.draw(node_sizes=15, node_markers=rects, node_labels=\"idx\");\n</pre> # apply a rectangle marker with width scaled to n digits in data rects = [f\"r{len(str(i))}x1\" for i in tree.get_node_data(\"idx\")] tree.draw(node_sizes=15, node_markers=rects, node_labels=\"idx\"); 678910r0r1r2r3r4r5 In\u00a0[58]: Copied! <pre># show \ntree = tree.set_node_data(\"support\", default=100)\ntree[-1].support = np.nan\ntree.draw(node_labels='support', node_sizes=18, node_markers='r2x1');\n</pre> # show  tree = tree.set_node_data(\"support\", default=100) tree[-1].support = np.nan tree.draw(node_labels='support', node_sizes=18, node_markers='r2x1'); 100100100100nanr0r1r2r3r4r5 In\u00a0[224]: Copied! <pre># ...\nmask = tree.get_node_mask(2, 9, 10)\ncanvas, axes, mark = tree.draw();\ntree.annotate.add_node_markers(axes=axes, marker=\"s\", size=10, mask=mask);\n</pre> # ... mask = tree.get_node_mask(2, 9, 10) canvas, axes, mark = tree.draw(); tree.annotate.add_node_markers(axes=axes, marker=\"s\", size=10, mask=mask); r0r1r2r3r4r5 In\u00a0[72]: Copied! <pre># set a single color to all nodes\ntree.draw(node_colors='red', node_sizes=10);\n</pre> # set a single color to all nodes tree.draw(node_colors='red', node_sizes=10); r0r1r2r3r4r5 In\u00a0[73]: Copied! <pre># list of colors of length nnodes\ncolors = ['darkcyan'] * 6 + ['goldenrod'] * 5\ntree.draw(node_colors=colors, node_sizes=10, node_mask=False);\n</pre> # list of colors of length nnodes colors = ['darkcyan'] * 6 + ['goldenrod'] * 5 tree.draw(node_colors=colors, node_sizes=10, node_mask=False); r0r1r2r3r4r5 <p>Automatically color nodes by projecting a data feature that is saved to tree object, such as the node heights, using color-mapping.</p> In\u00a0[76]: Copied! <pre># colormapping the 'height' feature\ntree.draw(node_colors='height', node_sizes=10, node_mask=False);\n</pre> # colormapping the 'height' feature tree.draw(node_colors='height', node_sizes=10, node_mask=False); r0r1r2r3r4r5 In\u00a0[24]: Copied! <pre>import toyplot\n\n# set config options to new settings\ntoyplot.config.autoformat = \"png\"\ntoyplot.config.autorender = False\n</pre> import toyplot  # set config options to new settings toyplot.config.autoformat = \"png\" toyplot.config.autorender = False In\u00a0[25]: Copied! <pre># embed a PNG drawing in the notebook\ncanvas, axes, mark = tree.draw();\n\n# it will only display here b/c we return the Canvas\ncanvas\n</pre> # embed a PNG drawing in the notebook canvas, axes, mark = tree.draw();  # it will only display here b/c we return the Canvas canvas Out[25]: r0r1r2r3r4r5 In\u00a0[26]: Copied! <pre># set config options back to their defaults\ntoyplot.config.autoformat = \"html\"\ntoyplot.config.autorender = True\n</pre> # set config options back to their defaults toyplot.config.autoformat = \"html\" toyplot.config.autorender = True"},{"location":"drawing-basics/#tree-drawing-basics","title":"Tree Drawing basics\u00b6","text":"<p>Tree visualization is a fundamental feature of <code>toytree</code>. Following our minimalist ethos, it is possible to generate a beautiful tree drawing very easily. But in addition, it is also possible to create complex and data rich visualizations using a variety of styling options.</p>"},{"location":"drawing-basics/#drawing-class-objects","title":"Drawing class objects\u00b6","text":"<p>When you call <code>.draw()</code> on a tree it returns three objects, a <code>Canvas</code>, a <code>Cartesian</code> axes, and a <code>Mark</code>. This follows the design principle of the <code>toyplot</code> plotting library on which toytree is based. The <code>Canvas</code> describes the plot space, and the <code>Cartesian</code> coordinates define how to project <code>Marks</code> onto that space. <code>Marks</code> are used to represent data using SVG markers and shapes. One canvas can have multiple cartesian coordinates, and each cartesian axes can contain multiple marks.</p> <p>It is often useful to capture these drawing objects as variables so that they can be reused to further edit or annotate drawings, and to save them. However, if you are working in a jupyter notebook and only intend the drawings to be embedded in the output cells, then you do not need to save the plots externally. Canvas objects automatically render in output cells when they are created (this option can be toggled in Global config.)</p>"},{"location":"drawing-basics/#builtin-tree-styles","title":"Builtin Tree Styles\u00b6","text":"<p>There are innumerous ways to style ToyTree drawings by combining different arguments to the <code>.draw</code> function. As a convenience, we also provide a number of pre-built tree styles that represent collections of style arguments that can be set using a single command.</p>"},{"location":"drawing-basics/#creating-tree-styles","title":"Creating Tree Styles\u00b6","text":"<p>There are a number of ways to apply individual styles to tree drawings. Which method you use may depend on whether you intend to reuse a particular tree style many times, or just once. The most common method is described below as the \"one-time\" setting, in which you enter style arguments to the <code>.draw()</code> function. You will see this used most common throughout this tutorial. However, it is also possible for users to create reusable styles similar to the builtin tree style types shown above. A final option is to modify style settings saved to the tree objects themselves. Each is demonstrated below.</p>"},{"location":"drawing-basics/#one-time-style-setting","title":"One-time style setting\u00b6","text":"<p>Use tab-completion or other methods to examine the documentation string of the draw function to see the options available for styling tree drawings.</p>"},{"location":"drawing-basics/#reusable-style-dict","title":"Reusable style dict\u00b6","text":"<p>You can create a custom reusable tree-style as a dictionary of key-value pairs specifying options to the draw function. To apply this to many tree drawings you can simply use variadics to expand the dictionary as a single argument to the draw function, as demonstrated below.</p>"},{"location":"drawing-basics/#persistent-style","title":"Persistent style\u00b6","text":"<p>Finally, you can modify the <code>.style</code> settings of a <code>ToyTree</code> object to modify its saved default drawing options. This can useful if you plan to visualize the same tree many times, or wish to save different trees with different style settings for easier comparison. For example, it can be used within a function to return a tree object that has a style setting saved to it which will highlight a particular feature or clade when visualized. This framework is also useful for learning which tree style options are available, since you can use tab-completion in an interactive environment to explore the different style options available. In this example, I first create a copy of our example tree object and save the new copy as stree. Then, I modify the the style settings of the stree object. Finally, we can simply call <code>.draw()</code> to draw the tree using its saved tree style. (Note that if you enter a new <code>tree_style</code> argument to the draw() function of this tree it will override the settings in the tree's <code>.style</code> settings.)</p>"},{"location":"drawing-basics/#drawing-nodes","title":"Drawing nodes\u00b6","text":"<p>Plotting node values on a tree is a useful way of representing additional information about trees. See the Data/Features section for details on extracting data from tree objects to plot on nodes. Here we will focus on options available for styling nodes. Nodes are often used to show labels, support values, or trait data. They can convey information through variation in their marker shapes (e.g., circles, rectangles, pie-charts), colors, and size. Node markers in <code>toytree</code> are represented by SVG shape objects for which a fill (color), fill-opacity, stroke (outline color), stroke-opacity, and stroke-width can be set.</p> <p>Below is a complex example showing how</p>"},{"location":"drawing-basics/#node_sizes","title":"node_sizes\u00b6","text":"<p>In the default tree style node sizes are set to zero, meaning that they will not be shown. Node sizes are described in pixel units as floats or ints, which scale node marker sizes. A single value can be entered to apply to all nodes, or a sequence of values of length nnodes can be entered to scale nodes to different sizes. In this case, the values should be enetered in node idxorder, which is best done by extracting data from the tree object itself, as described in Data/Features. See also Range-Mapping for examples of scaling node sizes to data features.</p>"},{"location":"drawing-basics/#node_mask","title":"node_mask\u00b6","text":"<p>You will notice that the <code>node_sizes</code> argument shown above only adds node markers to the internal nodes. What if we want to choose which nodes to display markers on? In that case, you will want to use the <code>node_mask</code> argument. This accepts a boolean or array of boolean values to describe which nodes to show versus hide. There is a convenience function of tree objects named <code>get_node_mask</code> that can be used to generate a boolean mask in the correct order to designate a subset of nodes to show. Finally, there is a simplified tuple syntax that can be used to choose to display particular sets of nodes composing only the tips, only the internal nodes, or only the root.</p>"},{"location":"drawing-basics/#node_markers","title":"node_markers\u00b6","text":"<p>Node markers are the shapes of the mark objects plotted on nodes. The default shape is a circle, but a variety of marker shapes are available and can be selected by the shorthand str names used for toyplot markers. For example, 's' for a square, 'o' for a circle, 'r1x5' for a rectangle that is 5 times taller than wide. Each marker shape is still scaled to a particular pixel size using the <code>node_sizes</code> argument, and optionally shown or hidden using <code>node_mask</code>. You can enter a single node marker argument to apply to all nodes uniformly, or a series of node markers of length nnodes to apply different markers shapes to different nodes.</p>"},{"location":"drawing-basics/#node_colors","title":"node_colors\u00b6","text":"<p>The fill color of nodes can be set in a variety of ways. The node_colors option can be used to set a single color to all nodes, or different colors to nodes. The colors can be entered manually, or they can be automatically projected from color map to data values. There is another option for setting a single color to all nodes, using node_style.fill. The node_colors argument overrides node_style.fill.</p>"},{"location":"drawing-basics/#global-config","title":"Global config\u00b6","text":"<p>The default visualization settings in toytree are inherited from toyplot. This includes the default usage of html format for displaying plots in a notebook, and the default behavior of automatically rendering Canvas objects in a notebook cell when they are created. Both of these options can be changed in the <code>config</code> settings of the toyplot library.</p>"},{"location":"drawing-cloud-trees-bkp/","title":"Drawing cloud trees bkp","text":"In\u00a0[\u00a0]: Copied! In\u00a0[3]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[4]: Copied! <pre>fish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\")\nfish\n</pre> fish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\") fish Out[4]: <pre>&lt;toytree.MultiTree ntrees=160&gt;</pre> <p>Styling tip labels in cloud trees -- In cloud tree plots a fixed order of the tips is always enforced, which allows for the discordance among trees to be visualized. Because each tree within the multitree object may have a different ordering of tips, we only print the tip labels once. The order of the tips of the tree can be changed by using the fixed order argument, otherwise a consensus tree is quickly inferred and used for the tip order. To style the tip labels or change them, like below, you can provide a list of new names in the same order as in the first tree in the treelist.</p> In\u00a0[5]: Copied! <pre># draw a cloud tree which enforces a fixed tip order\nfish.draw_cloud_tree(\n    jitter=0.1,\n    edge_style={\n        'stroke': \"red\",\n        'stroke-opacity': 0.05,\n    },\n    #fixed_order=consfish.get_tip_labels(),\n    tip_labels_style={\"font-size\": \"11px\"},\n    tip_labels=[\n        '{}. {}'.format(i[0], i[1:])\n        for i in fish.treelist[0].get_tip_labels()\n    ],\n);\n</pre> # draw a cloud tree which enforces a fixed tip order fish.draw_cloud_tree(     jitter=0.1,     edge_style={         'stroke': \"red\",         'stroke-opacity': 0.05,     },     #fixed_order=consfish.get_tip_labels(),     tip_labels_style={\"font-size\": \"11px\"},     tip_labels=[         '{}. {}'.format(i[0], i[1:])         for i in fish.treelist[0].get_tip_labels()     ], ); P. riapellaP. sjonesiiX. alvareziX. mayaeX. helleriiX. signumX. clemenciae_GX. monticolusX. corteziX. birchmanni_GARCX. malinche_CHIC2X. montezumaeX. nezahuacoyotlX. continensX. pygmaeusX. multilineatusX. nigrensisX. andersiX. couchianusX. gordoniX. meyeriX. variatusX. evelynaeX. milleriX. xiphidiumX. maculatus_JpWild In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"drawing-cloud-trees-bkp/#example-xiphophorus-fishes","title":"Example: Xiphophorus fishes\u00b6","text":"<p>Data set for reconstructing a densitree figure from Cui et al. (2013). I\u2019ve taken the nexus file from the paper\u2019s dryad repository and converted it to newick and saved it online so it can be easily downloaded. The file contains 160 trees representing mrbayes consensus trees inferred for different genomic regions.</p>"},{"location":"drawing-cloud-trees/","title":"multitree cloud trees","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[8]: Copied! <pre># a multi-newick string\nNEWICKS = \"\"\"\\\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n</pre> # a multi-newick string NEWICKS = \"\"\"\\ (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\" In\u00a0[9]: Copied! <pre># create a multitree object\nmtree = toytree.mtree(NEWICKS)\n</pre> # create a multitree object mtree = toytree.mtree(NEWICKS) In\u00a0[24]: Copied! <pre># draw a cloud tree\nmtree.draw_cloud_tree(\n    scale_bar=True,\n    edge_style={\n        \"stroke-opacity\": 0.1,\n        \"stroke-width\": 2.5,\n    },\n);\n</pre> # draw a cloud tree mtree.draw_cloud_tree(     scale_bar=True,     edge_style={         \"stroke-opacity\": 0.1,         \"stroke-width\": 2.5,     }, ); abdec3210 In\u00a0[21]: Copied! <pre># make a copy of the multitree on which we will set styles\nmtree2 = mtree.copy()\n\n# get unique trees\nutrees = mtree2.get_unique_topologies()\n\n# set color to red if most common topology, else green\nfor tree in mtree2:\n    if tree.distance.get_treedist_rf(utrees[0][0]) == 0:\n        tree.style.edge_colors = 'red'\n    else:\n        tree.style.edge_colors = \"green\"\n\n# draw the cloud tree w/o any overriding args to use individual .style dicts\nmtree2.draw_cloud_tree(\n    scale_bar=True,\n    interior_algorithm=0, \n    edge_style={\"stroke-opacity\": 0.25},\n    tip_labels_style={\"font-size\": 15},\n);\n</pre> # make a copy of the multitree on which we will set styles mtree2 = mtree.copy()  # get unique trees utrees = mtree2.get_unique_topologies()  # set color to red if most common topology, else green for tree in mtree2:     if tree.distance.get_treedist_rf(utrees[0][0]) == 0:         tree.style.edge_colors = 'red'     else:         tree.style.edge_colors = \"green\"  # draw the cloud tree w/o any overriding args to use individual .style dicts mtree2.draw_cloud_tree(     scale_bar=True,     interior_algorithm=0,      edge_style={\"stroke-opacity\": 0.25},     tip_labels_style={\"font-size\": 15}, ); abdec3210"},{"location":"drawing-cloud-trees/#drawing-cloud-trees","title":"Drawing Cloud Trees\u00b6","text":"<p>Cloud tree drawings provide a useful way to visualize discordance among sets of trees in a MultiTree object.</p>"},{"location":"drawing-cloud-trees/#example-dataset","title":"Example dataset\u00b6","text":""},{"location":"drawing-cloud-trees/#cloud-tree-drawings","title":"Cloud tree drawings\u00b6","text":"<p>The <code>.draw_cloud_tree</code> function takes similar styling arguments as the <code>ToyTree.draw</code> function but accepts a few additional arguments.</p>"},{"location":"drawing-cloud-trees/#styling-individual-trees","title":"Styling individual trees\u00b6","text":"<p>I find it useful to set different styles on different trees in a set to better examine their differences. In this example I set a different color to the edges depending on whether the tree topology matches the most common topology in the set or not.</p>"},{"location":"drawing-tree-grids/","title":"multitree tree grids","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[15]: Copied! <pre># a MultiTree containing 50 random coalescent trees with 10 tips each\nmtree = toytree.mtree([toytree.rtree.coaltree(10) for i in range(50)])\n</pre> # a MultiTree containing 50 random coalescent trees with 10 tips each mtree = toytree.mtree([toytree.rtree.coaltree(10) for i in range(50)]) In\u00a0[16]: Copied! <pre>mtree.draw();\n</pre> mtree.draw(); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 In\u00a0[4]: Copied! <pre># a multi-newick string\nNEWICKS = \"\"\"\\\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n</pre> # a multi-newick string NEWICKS = \"\"\"\\ (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\" In\u00a0[5]: Copied! <pre># create a multitree object\nmtree = toytree.mtree(NEWICKS)\n</pre> # create a multitree object mtree = toytree.mtree(NEWICKS) In\u00a0[17]: Copied! <pre>mtree.draw();\n</pre> mtree.draw(); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 <p>shape -- The argument <code>shape</code> can be used to layout a grid describing how the trees should be arranged. It takes a tuple of ints as input in the form (rows, columns), similar to describing the shape of a numpy array. In the example below we draw 8 trees in a grid that has two rows and four columns. (See 'margin' below for further styling of spacing).</p> In\u00a0[18]: Copied! <pre>mtree.draw(shape=(2, 2), width=400, height=400);\n</pre> mtree.draw(shape=(2, 2), width=400, height=400); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 <p>shared_axes -- The <code>shared_axes</code> arg accepts a boolean and can be used to set the same shared time scale on the time-associated axis of tree plots (this varies depending on the layout direction). This is useful for comparing the node heights or edge lengths among trees visually. This is demonstrated for five random coalescent trees below which differ in coalescent times.</p> In\u00a0[21]: Copied! <pre>mtree.draw(scale_bar=True, layout='d', shared_axes=True);\n</pre> mtree.draw(scale_bar=True, layout='d', shared_axes=True); r0r1r2r3r4r5r6r7r8r90100200300400r0r1r2r3r4r5r6r7r8r90100200300400r0r1r2r3r4r5r6r7r8r90100200300400r0r1r2r3r4r5r6r7r8r90100200300400 <p>margin -- You can set the margin size in pixel units between the trees in a grid. The default value is automatically adjusted, but usually around 30. Larger values increase the spacing between trees, which can be useful for fitting longer tip names, while smaller values will pack trees closer together. A single value can be entered to apply to margins on all four sides, or a tuple of four values can be entered to modify the (top, right, bottom, left) margins in order.</p> In\u00a0[29]: Copied! <pre>mtree.draw(margin=(10, 30, 10, 30));\n</pre> mtree.draw(margin=(10, 30, 10, 30)); r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9r0r1r2r3r4r5r6r7r8r9 <p>style and label axes -- Just as you can style the axes of a Cartesian object in a tree drawing you can similarly use axes styling to modify the scale, set tick marks, change tick or axes label styles, or add titles to subplots. Here we add a title to each plot.</p> In\u00a0[32]: Copied! <pre># draw a tree grid while using shared_axes=True to share time axis\ncanvas, axes, marks = mtree.draw(\n    layout='d', edge_type='c', node_sizes=5, node_mask=False,\n    shape=(1, 4), width=650, height=250, scale_bar=True,\n    shared_axes=True, \n);\n\n# add a label to each subplot\nfor adx, ax in enumerate(axes):\n    ax.label.text = f\"tree {adx}\"\n\n# add a y-axis label to only the first subplot\naxes[0].y.label.text = \"        time (generations)\"\naxes[0].y.label.offset = 25\n</pre> # draw a tree grid while using shared_axes=True to share time axis canvas, axes, marks = mtree.draw(     layout='d', edge_type='c', node_sizes=5, node_mask=False,     shape=(1, 4), width=650, height=250, scale_bar=True,     shared_axes=True,  );  # add a label to each subplot for adx, ax in enumerate(axes):     ax.label.text = f\"tree {adx}\"  # add a y-axis label to only the first subplot axes[0].y.label.text = \"        time (generations)\" axes[0].y.label.offset = 25 r0r1r2r3r4r5r6r7r8r90100200300400        time (generations)tree 0r0r1r2r3r4r5r6r7r8r90100200300400tree 1r0r1r2r3r4r5r6r7r8r90100200300400tree 2r0r1r2r3r4r5r6r7r8r90100200300400tree 3 In\u00a0[43]: Copied! <pre># load nexus trees data from ...\nfish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\")\n</pre> # load nexus trees data from ... fish = toytree.mtree(\"https://eaton-lab.org/data/densitree.nex\") In\u00a0[44]: Copied! <pre># draw with default styling\nfish.draw(shape=(1, 4), height=350);\n</pre> # draw with default styling fish.draw(shape=(1, 4), height=350); PriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXcorteziXbirchmanni_GARCXmalinche_CHIC2XmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXvariatusXevelynaeXmilleriXxiphidiumXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXmilleriXevelynaeXmaculatus_JpWildXmalinche_CHIC2Xbirchmanni_GARCXcorteziXnezahuacoyotlXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXclemenciae_GXmonticolusPriapellaPsjonesiiXalvareziXmayaeXsignumXhelleriiXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GXbirchmanni_GARCXmalinche_CHIC2XcorteziXmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXmonticolusXclemenciae_GXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWild <p>For example, here we set a different color to the tip labels style attribute for each tree in the MultiTree object.</p> In\u00a0[47]: Copied! <pre># set different 'tip_labels_colors' for each tree\ncolors = toytree.color.color_cycler()\nfor tree in fish.treelist[:4]:\n    tree.style.tip_labels_colors = next(colors)\n\n# draw several trees\nfish.draw(shape=(1, 4), height=350);\n</pre> # set different 'tip_labels_colors' for each tree colors = toytree.color.color_cycler() for tree in fish.treelist[:4]:     tree.style.tip_labels_colors = next(colors)  # draw several trees fish.draw(shape=(1, 4), height=350); PriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXcorteziXbirchmanni_GARCXmalinche_CHIC2XmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXvariatusXevelynaeXmilleriXxiphidiumXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXmilleriXevelynaeXmaculatus_JpWildXmalinche_CHIC2Xbirchmanni_GARCXcorteziXnezahuacoyotlXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXclemenciae_GXmonticolusPriapellaPsjonesiiXalvareziXmayaeXsignumXhelleriiXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GXbirchmanni_GARCXmalinche_CHIC2XcorteziXmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXmonticolusXclemenciae_GXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWild <p>The argument <code>fixed_order</code> is especially useful for multitree drawings for easily comparing trees visually. This fixes the order in which tips in the tree will be ordered, which makes differences between trees visible as conflicts. Here we infer a consensus tree from the full set of trees and use its tip order as the fixed order on which to plot all other trees.</p> In\u00a0[48]: Copied! <pre># get majority-rule consensus tree\nconsfish = fish.get_consensus_tree()\n\n# draw tree grid and use consensus tree order as a fixed_order of tips\nfish.draw(\n    shape=(2, 3),\n    height=600,\n    width=600,\n    fixed_order=True,\n    edge_type='c',\n    shared_axes=True,\n);\n</pre> # get majority-rule consensus tree consfish = fish.get_consensus_tree()  # draw tree grid and use consensus tree order as a fixed_order of tips fish.draw(     shape=(2, 3),     height=600,     width=600,     fixed_order=True,     edge_type='c',     shared_axes=True, ); PriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXcorteziXbirchmanni_GARCXmalinche_CHIC2XmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXvariatusXevelynaeXmilleriXxiphidiumXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXmilleriXevelynaeXmaculatus_JpWildXmalinche_CHIC2Xbirchmanni_GARCXcorteziXnezahuacoyotlXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXclemenciae_GXmonticolusPriapellaPsjonesiiXalvareziXmayaeXsignumXhelleriiXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GXbirchmanni_GARCXmalinche_CHIC2XcorteziXmontezumaeXnezahuacoyotlXcontinensXpygmaeusXmultilineatusXnigrensisPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXmonticolusXclemenciae_GXcorteziXnezahuacoyotlXmalinche_CHIC2Xbirchmanni_GARCXmontezumaeXcontinensXpygmaeusXmultilineatusXnigrensisXandersiXcouchianusXgordoniXmeyeriXxiphidiumXevelynaeXvariatusXmilleriXmaculatus_JpWildPriapellaPsjonesiiXalvareziXhelleriiXmayaeXsignumXandersiXbirchmanni_GARCXmalinche_CHIC2XcontinensXpygmaeusXmultilineatusXnigrensisXcorteziXmontezumaeXnezahuacoyotlXxiphidiumXvariatusXevelynaeXcouchianusXgordoniXmeyeriXmilleriXmaculatus_JpWildXmonticolusXclemenciae_GPriapellaPsjonesiiXalvareziXmayaeXhelleriiXsignumXclemenciae_GXmonticolusXandersiXcouchianusXgordoniXmeyeriXxiphidiumXvariatusXevelynaeXmilleriXbirchmanni_GARCXmalinche_CHIC2XcontinensXpygmaeusXmultilineatusXnigrensisXmontezumaeXcorteziXnezahuacoyotlXmaculatus_JpWild"},{"location":"drawing-tree-grids/#drawing-tree-grids","title":"Drawing Tree Grids\u00b6","text":"<p>When using <code>toytree.MultiTree</code> objects you can easily draw multiple trees displayed as a grid on a canvas by using the <code>.draw</code> function. Here a number of useful examples are demonstrated.</p>"},{"location":"drawing-tree-grids/#example-dataset","title":"Example dataset\u00b6","text":""},{"location":"drawing-tree-grids/#grid-tree-drawings","title":"Grid tree drawings\u00b6","text":"<p>The <code>.draw</code> function takes similar styling arguments as the <code>ToyTree.draw</code> function but accepts a few additional arguments to also describe how to plot and organize multiple trees on a shared Canvas. This includes <code>shape</code>, <code>separate_axes</code>, and <code>idxs</code>, described below. The <code>MultiTree.draw()</code> function returns three objects, similar to <code>ToyTree.draw()</code>, but instead of returning <code>(Canvas, Cartesian, Mark)</code> it returns <code>(Canvas, List[Cartesian], List[Mark])</code>, with the List elements composing the length of the number of trees drawn.</p> <p>As you can see, the drawing below appears as a grid of multiple trees spaced on a canvas. A similar plot an be made by using <code>toyplot</code> Canvas and Cartesian arguments directly to create a layout, and then adding tree drawings to each Cartesian axes, as explained in the [Advanced Drawing] section. The draw function here simply provides a convenient shortcut. Similar to normal tree drawings, many styling arguments are available. It is possible to apply style arguments to each tree individually, or to apply one style to all, as will be demonstrated below.</p>"},{"location":"drawing-tree-grids/#tree-grid-styling","title":"Tree grid styling\u00b6","text":"<p>Trees in MultiTree grid drawing can be styled individually by setting the style dictionary attribute of each ToyTree in the treelist. Additionally, most styles can be applied as arguments to the draw_tree_grid() function to apply styles to all trees at once.</p>"},{"location":"gallery/","title":"Coming soon...","text":""},{"location":"gentime-figure-1/","title":"Gentime figure 1","text":"In\u00a0[\u00a0]: Copied! <pre>##\n</pre> ## In\u00a0[135]: Copied! <pre>import toyplot\nimport toytree\nimport numpy as np\nimport pandas as pd\n</pre> import toyplot import toytree import numpy as np import pandas as pd In\u00a0[147]: Copied! <pre>balfixNvarG = pd.read_csv(\"./results/bal-fixN-varG-concat.csv\", index_col=0)\nbalvarNfixG = pd.read_csv(\"./results/bal-varN-fixG-concat.csv\", index_col=0)\n</pre> balfixNvarG = pd.read_csv(\"./results/bal-fixN-varG-concat.csv\", index_col=0) balvarNfixG = pd.read_csv(\"./results/bal-varN-fixG-concat.csv\", index_col=0) In\u00a0[148]: Copied! <pre>dists = [\n    balfixNvarG.dist_qrt.mean(),\n    ...,\n]\n</pre> dists = [     balfixNvarG.dist_qrt.mean(),     ..., ] In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[149]: Copied! <pre>data = np.random.uniform(0.25, 0.9, 8)\ndata[0] = dists[0]\n</pre> data = np.random.uniform(0.25, 0.9, 8) data[0] = dists[0] In\u00a0[150]: Copied! <pre>canvas = toyplot.Canvas(width=450, height=250)\naxes = canvas.cartesian()\naxes.x.ticks.locator = toyplot.locator.Explicit(np.arange(data.size) + 0.5, )\naxes.x.label.text = \"Phylogenetic dataset (locus length)\"\naxes.x.spine.style[\"stroke-width\"] = 2.5\naxes.x.ticks.style[\"stroke-width\"] = 2.5\naxes.x.ticks.labels.style[\"font-size\"] = 15\naxes.x.label.style[\"font-size\"] = 16\naxes.x.domain.min = 0\n\naxes.y.label.text = \"Tree distance (error)\"\naxes.y.spine.style[\"stroke-width\"] = 2.5\naxes.y.ticks.style[\"stroke-width\"] = 2.5\naxes.y.ticks.labels.style[\"font-size\"] = 15\naxes.y.ticks.labels.style[\"font-size\"] = 15\naxes.y.label.style[\"font-size\"] = 16\naxes.y.domain.max = 1.0\n\nstarts = np.arange(data.size) + 1/6\nmark = axes.bars(\n    starts, \n    starts + 4/6,\n    data,\n    style={\"stroke\": \"#262626\", \"stroke-width\": 1.5, \"fill\": \"lightgrey\"},\n)\n\ntoytree.utils.set_axes_ticks_external(axes);\n# toytree.utils.set_axes_box_outline(axes);\n</pre> canvas = toyplot.Canvas(width=450, height=250) axes = canvas.cartesian() axes.x.ticks.locator = toyplot.locator.Explicit(np.arange(data.size) + 0.5, ) axes.x.label.text = \"Phylogenetic dataset (locus length)\" axes.x.spine.style[\"stroke-width\"] = 2.5 axes.x.ticks.style[\"stroke-width\"] = 2.5 axes.x.ticks.labels.style[\"font-size\"] = 15 axes.x.label.style[\"font-size\"] = 16 axes.x.domain.min = 0  axes.y.label.text = \"Tree distance (error)\" axes.y.spine.style[\"stroke-width\"] = 2.5 axes.y.ticks.style[\"stroke-width\"] = 2.5 axes.y.ticks.labels.style[\"font-size\"] = 15 axes.y.ticks.labels.style[\"font-size\"] = 15 axes.y.label.style[\"font-size\"] = 16 axes.y.domain.max = 1.0  starts = np.arange(data.size) + 1/6 mark = axes.bars(     starts,      starts + 4/6,     data,     style={\"stroke\": \"#262626\", \"stroke-width\": 1.5, \"fill\": \"lightgrey\"}, )  toytree.utils.set_axes_ticks_external(axes); # toytree.utils.set_axes_box_outline(axes); 0.51.52.53.54.55.56.57.5Phylogenetic dataset (locus length)0.00.51.0Tree distance (error) In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"gentime-figure-1/#load-data","title":"LOAD DATA\u00b6","text":""},{"location":"gentime-ne/","title":"Gentime ne","text":"In\u00a0[3]: Copied! <pre>import toytree\nimport toyplot\nimport ipcoal\nimport numpy as np\nimport pandas as pd\n</pre> import toytree import toyplot import ipcoal import numpy as np import pandas as pd In\u00a0[32]: Copied! <pre># get an ultrametric imbalanced tree\nTREE = toytree.rtree.baltree(8, treeheight=1.5e5)\nEDGES = [0, 1, 8, 10, 6, 7, 12, 13, 14]\nNE_DEFAULT = 1e5\nGT_DEFAULT = 1\nRNG = np.random.default_rng(123)\nNLOCI = 1000\nNREPS = 100\nLOCUS_LENS = [1e6, 1e5, 1e4, 1e3]\n</pre> # get an ultrametric imbalanced tree TREE = toytree.rtree.baltree(8, treeheight=1.5e5) EDGES = [0, 1, 8, 10, 6, 7, 12, 13, 14] NE_DEFAULT = 1e5 GT_DEFAULT = 1 RNG = np.random.default_rng(123) NLOCI = 1000 NREPS = 100 LOCUS_LENS = [1e6, 1e5, 1e4, 1e3] In\u00a0[52]: Copied! <pre># set parameters on the species tree\ntree_ne = TREE.copy()\ntree_ne = tree_ne.set_node_data(\"Ne\", {i: NE_DEFAULT * 10 for i in EDGES}, default=NE_DEFAULT)\ntree_ne = tree_ne.set_node_data(\"gt\", default=GT_DEFAULT)\ntree_ne = tree_ne.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_ne})\ntree_ne = tree_ne.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_ne})\n\n# convert edge lens to units of generations.\ntree_ne = tree_ne.set_node_data(\"dist\", {i: i.tg for i in tree_ne})\n\n# show data\ntree_ne.get_node_data()\n</pre> # set parameters on the species tree tree_ne = TREE.copy() tree_ne = tree_ne.set_node_data(\"Ne\", {i: NE_DEFAULT * 10 for i in EDGES}, default=NE_DEFAULT) tree_ne = tree_ne.set_node_data(\"gt\", default=GT_DEFAULT) tree_ne = tree_ne.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_ne}) tree_ne = tree_ne.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_ne})  # convert edge lens to units of generations. tree_ne = tree_ne.set_node_data(\"dist\", {i: i.tg for i in tree_ne})  # show data tree_ne.get_node_data() Out[52]: idx name height dist support Ne gt rho tc tg theta 0 0 r0 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 1 1 r1 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 2 2 r2 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 3 3 r3 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 4 4 r4 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 5 5 r5 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 6 6 r6 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 7 7 r7 0.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 8 8 50000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 9 9 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 10 10 100000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 11 11 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 12 12 50000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 13 13 100000.0 50000.0 NaN 1000000.0 1 0.0040 0.025 50000.0 0.040 14 14 150000.0 0.0 NaN 1000000.0 1 0.0040 0.000 0.0 0.040 In\u00a0[53]: Copied! <pre>c, a, m = tree_ne.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 6), edge_colors=\"gt\");\na.x.label.text = \"Time (generations)\"\n\n# draw tree w/ edge lengths in coal units\nc, a, m = tree_ne.set_node_data(\"dist\", {i: i.tc for i in tree_ne}).draw(scale_bar=True);\na.x.label.text = \"Time (coal units)\"\n</pre> c, a, m = tree_ne.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 6), edge_colors=\"gt\"); a.x.label.text = \"Time (generations)\"  # draw tree w/ edge lengths in coal units c, a, m = tree_ne.set_node_data(\"dist\", {i: i.tc for i in tree_ne}).draw(scale_bar=True); a.x.label.text = \"Time (coal units)\" r0r1r2r3r4r5r6r7150000100000500000Time (generations) r0r1r2r3r4r5r6r70.40.20Time (coal units) In\u00a0[54]: Copied! <pre>tree_gt = TREE.copy()\ntree_gt = tree_gt.set_node_data(\"Ne\", default=NE_DEFAULT)\ntree_gt = tree_gt.set_node_data(\"gt\", {i: GT_DEFAULT * 10 for i in EDGES}, default=GT_DEFAULT)\ntree_gt = tree_gt.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_gt})\ntree_gt = tree_gt.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_gt})\n\n# convert dist to units of generations. Draw and show data\ntree_gt = tree_gt.set_node_data(\"dist\", {i: i.tg for i in tree_gt})\ntree_gt.get_node_data()\n</pre> tree_gt = TREE.copy() tree_gt = tree_gt.set_node_data(\"Ne\", default=NE_DEFAULT) tree_gt = tree_gt.set_node_data(\"gt\", {i: GT_DEFAULT * 10 for i in EDGES}, default=GT_DEFAULT) tree_gt = tree_gt.set_node_data(\"tg\", {i: i.dist / i.gt for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"tc\", {i: i.tg / (2 * i.Ne) for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"theta\", {i: 4 * i.Ne * 1e-8 for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"rho\", {i: 4 * i.Ne * 1e-9 for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"tg_rho\", {i: i.tg * i.rho for i in tree_gt}) tree_gt = tree_gt.set_node_data(\"tg_theta\", {i: i.tg * i.theta * 1e-9 for i in tree_gt})  # convert dist to units of generations. Draw and show data tree_gt = tree_gt.set_node_data(\"dist\", {i: i.tg for i in tree_gt}) tree_gt.get_node_data() Out[54]: idx name height dist support Ne gt rho tc tg theta 0 0 r0 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 1 1 r1 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 2 2 r2 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 3 3 r3 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 4 4 r4 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 5 5 r5 0.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 6 6 r6 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 7 7 r7 90000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 8 8 95000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 9 9 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 10 10 100000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 11 11 50000.0 50000.0 NaN 100000.0 1 0.0004 0.250 50000.0 0.004 12 12 95000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 13 13 100000.0 5000.0 NaN 100000.0 10 0.0004 0.025 5000.0 0.004 14 14 105000.0 0.0 NaN 100000.0 10 0.0004 0.000 0.0 0.004 In\u00a0[55]: Copied! <pre>c, a, m = tree_gt.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 4), edge_colors=\"gt\");\na.x.label.text = \"Time (generations)\"\n\n# draw tree w/ edge lengths in coal units\nc, a, m = tree_gt.set_node_data(\"dist\", {i: i.tc for i in tree_gt}).draw(scale_bar=True);\na.x.label.text = \"Time (coal units)\"\n</pre> c, a, m = tree_gt.draw(scale_bar=True, edge_widths=(\"Ne\", 2, 4), edge_colors=\"gt\"); a.x.label.text = \"Time (generations)\"  # draw tree w/ edge lengths in coal units c, a, m = tree_gt.set_node_data(\"dist\", {i: i.tc for i in tree_gt}).draw(scale_bar=True); a.x.label.text = \"Time (coal units)\" r0r1r2r3r4r5r6r7100000500000Time (generations) r0r1r2r3r4r5r6r70.40.20Time (coal units) In\u00a0[93]: Copied! <pre>def get_n_topos(model):\n    ntopos = []\n    for _, locus in model.df.groupby(\"locus\"):\n        mtree = toytree.mtree(locus.genealogy)\n        ntopos.append(len(mtree.get_unique_topologies()))\n    return np.mean(ntopos)\n</pre> def get_n_topos(model):     ntopos = []     for _, locus in model.df.groupby(\"locus\"):         mtree = toytree.mtree(locus.genealogy)         ntopos.append(len(mtree.get_unique_topologies()))     return np.mean(ntopos) In\u00a0[94]: Copied! <pre>def iter_first_genealogies(model):\n    for _, df in model.df.groupby(\"locus\"):\n        yield toytree.tree(df.iloc[0, 6])\n</pre> def iter_first_genealogies(model):     for _, df in model.df.groupby(\"locus\"):         yield toytree.tree(df.iloc[0, 6]) In\u00a0[77]: Copied! <pre>COLUMNS = [\n    \"concat_tree\", \n    \"nloci\", \"locus_length\", \n    \"nsnps\", \"n_topologies\",\n    \"dist_rf\", \"dist_qrt\",\n]\n\n# setup data\ndata = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float)\n</pre> COLUMNS = [     \"concat_tree\",      \"nloci\", \"locus_length\",      \"nsnps\", \"n_topologies\",     \"dist_rf\", \"dist_qrt\", ]  # setup data data = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float) In\u00a0[78]: Copied! <pre>for rep in range(NREPS):\n    \n    # set up model and simulate loci\n    model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    \n    # get inferred concat tree\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    \n    # get distances from true species tree\n    concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    \n    # get mean topologies per locus in true genealogies\n    ntopos_true = get_n_topos(model)\n    \n    # store data\n    data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]\n    \n# write\ndata.to_csv(\"./results/bal-fixN-varG-concat.csv\")\n</pre> for rep in range(NREPS):          # set up model and simulate loci     model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)          # get inferred concat tree     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)          # get distances from true species tree     concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference          # get mean topologies per locus in true genealogies     ntopos_true = get_n_topos(model)          # store data     data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]      # write data.to_csv(\"./results/bal-fixN-varG-concat.csv\") In\u00a0[89]: Copied! <pre>for rep in range(NREPS):\n    \n    # set up model and simulate loci\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    \n    # get inferred concat tree\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    \n    # get distances from true species tree\n    concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    \n    # get mean topologies per locus in true genealogies\n    ntopos_true = get_n_topos(model)\n    \n    # store data\n    data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]\n    \n# write\ndata.to_csv(\"./results/bal-varN-fixG-concat.csv\")\n</pre> for rep in range(NREPS):          # set up model and simulate loci     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)          # get inferred concat tree     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)          # get distances from true species tree     concat_dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     concat_dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference          # get mean topologies per locus in true genealogies     ntopos_true = get_n_topos(model)          # store data     data.iloc[rep] = [raxtree.write(), 1, 1e6, model.df.nsnps.sum(), ntopos_true, concat_dist_mci, concat_dist_qrt]      # write data.to_csv(\"./results/bal-varN-fixG-concat.csv\") In\u00a0[90]: Copied! <pre>COLUMNS = [\n    \"sptree\",\n    \"nloci\", \"locus_length\", \n    \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"n_inferred_topologies\",\n    \"astral_true\", \"astral_true_dist_qrt\", \"astral_true_dist_rf\",\n    \"astral_inferred\", \"astral_inferred_dist_qrt\", \"astral_inferred_dist_rf\",\n]\n</pre> COLUMNS = [     \"sptree\",     \"nloci\", \"locus_length\",      \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"n_inferred_topologies\",     \"astral_true\", \"astral_true_dist_qrt\", \"astral_true_dist_rf\",     \"astral_inferred\", \"astral_inferred_dist_qrt\", \"astral_inferred_dist_rf\", ] In\u00a0[92]: Copied! <pre>get_n_topos(model)\n</pre> get_n_topos(model) Out[92]: <pre>3.811</pre> In\u00a0[91]: Copied! <pre># setup data\ndata = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float)\n\n# iterate over nreps\nfor i in range(NREPS):\n    \n    # set up model and simulate loci\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1000, nsites=1e3)\n    \n    # get distribution of true genealogies\n    gtrees = list(iter_first_genealogies(model))\n    \n    # get distribution of inferred gene trees\n    raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=2, nworkers=4)\n\n    # get astral tree inferred from genealogies\n    atree_true = ipcoal.phylo.infer_astral_tree(gtrees)\n    \n    # get astral tree inferred from gene trees\n    atree_empirical = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)\n    \n    # get distances from true species tree\n    true_dist_mci = TREE.distance.get_treedist_rfg_mci(atree_true, normalize=True)\n    true_dist_qrt = TREE.distance.get_treedist_quartets(atree_true).similarity_to_reference\n    \n    # get distances from true species tree\n    emp_dist_rf = TREE.distance.get_treedist_rfg_mci(atree_empirical, normalize=True)\n    emp_dist_qrt = TREE.distance.get_treedist_quartets(atree_empirical).similarity_to_reference\n    \n    # get mean topologies per locus in true genealogies\n    ntopos_true = get_n_topos(model)\n    \n    # get number of topologies in empirical gene trees \n    ntopos_inferred = len(toytree.mtree(raxtrees.gene_tree).get_unique_topologies())\n    \n    # store data\n    data.iloc[i] = (\n        \"Ne\",\n        1000, 1e3,\n        model.df.groupby(\"locus\").nsnps.mean(), ntopos_true, ntopos_inferred,\n        atree_true.write(), true_dist_rf, true_dist_qrt,\n        atree_empirical.write(), emp_dist_rf, emp_dist_qrt,\n    )\n    print(\".\", end=\"\")\n\n# write\ndata.to_csv(\"./results/bal-varN-fixG-astral.csv\")\n</pre> # setup data data = pd.DataFrame(index=range(NREPS), columns=COLUMNS, dtype=float)  # iterate over nreps for i in range(NREPS):          # set up model and simulate loci     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1000, nsites=1e3)          # get distribution of true genealogies     gtrees = list(iter_first_genealogies(model))          # get distribution of inferred gene trees     raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=2, nworkers=4)      # get astral tree inferred from genealogies     atree_true = ipcoal.phylo.infer_astral_tree(gtrees)          # get astral tree inferred from gene trees     atree_empirical = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)          # get distances from true species tree     true_dist_mci = TREE.distance.get_treedist_rfg_mci(atree_true, normalize=True)     true_dist_qrt = TREE.distance.get_treedist_quartets(atree_true).similarity_to_reference          # get distances from true species tree     emp_dist_rf = TREE.distance.get_treedist_rfg_mci(atree_empirical, normalize=True)     emp_dist_qrt = TREE.distance.get_treedist_quartets(atree_empirical).similarity_to_reference          # get mean topologies per locus in true genealogies     ntopos_true = get_n_topos(model)          # get number of topologies in empirical gene trees      ntopos_inferred = len(toytree.mtree(raxtrees.gene_tree).get_unique_topologies())          # store data     data.iloc[i] = (         \"Ne\",         1000, 1e3,         model.df.groupby(\"locus\").nsnps.mean(), ntopos_true, ntopos_inferred,         atree_true.write(), true_dist_rf, true_dist_qrt,         atree_empirical.write(), emp_dist_rf, emp_dist_qrt,     )     print(\".\", end=\"\")  # write data.to_csv(\"./results/bal-varN-fixG-astral.csv\") <pre>\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/core/indexes/base.py:3652, in Index.get_loc(self, key)\n   3651 try:\n-&gt; 3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/_libs/index.pyx:147, in pandas._libs.index.IndexEngine.get_loc()\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/_libs/index.pyx:176, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7080, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[91], line 35\n     32 ntopos_true = get_n_topos(model)\n     34 # get number of topologies in empirical gene trees \n---&gt; 35 ntopos_inferred = len(toytree.mtree(raxtrees).get_unique_topologies())\n     37 # store data\n     38 data.iloc[i] = (\n     39     \"Ne\",\n     40     1000, 1e3, \n   (...)\n     43     atree_empirical.write(), emp_dist_rf, emp_dist_qrt,\n     44 )\n\nFile ~/Documents/toytree/toytree/io/src/mtreeio.py:49, in mtree(data, **kwargs)\n     46     data = data.to_list()\n     48 # collection of ToyTrees\n---&gt; 49 if isinstance(data[0], ToyTree):\n     50     data = [i.copy() for i in data]\n     51     treelist = data\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/core/frame.py:3761, in DataFrame.__getitem__(self, key)\n   3759 if self.columns.nlevels &gt; 1:\n   3760     return self._getitem_multilevel(key)\n-&gt; 3761 indexer = self.columns.get_loc(key)\n   3762 if is_integer(indexer):\n   3763     indexer = [indexer]\n\nFile ~/mambaforge-pypy3/envs/radcamp-ipa/lib/python3.10/site-packages/pandas/core/indexes/base.py:3654, in Index.get_loc(self, key)\n   3652     return self._engine.get_loc(casted_key)\n   3653 except KeyError as err:\n-&gt; 3654     raise KeyError(key) from err\n   3655 except TypeError:\n   3656     # If we have a listlike key, _check_indexing_error will raise\n   3657     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3658     #  the TypeError.\n   3659     self._check_indexing_error(key)\n\nKeyError: 0</pre> In\u00a0[62]: Copied! <pre>model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\nmodel.sim_loci(nloci=100, nsites=1e4)\nmodel.df.groupby(\"locus\").nsnps.mean()\n</pre> model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG) model.sim_loci(nloci=100, nsites=1e4) model.df.groupby(\"locus\").nsnps.mean() Out[62]: <pre>locus\n0     11.835616\n1     13.235955\n2     13.386364\n3     10.049383\n4     11.224719\n        ...    \n95    11.845238\n96    12.787500\n97    13.144330\n98    10.987805\n99    10.900000\nName: nsnps, Length: 100, dtype: float64</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[133]: Copied! <pre>for i in range(3):\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    print(i, dist_mci, dist_qrt, model.df.nsnps.sum())\n</pre> for i in range(3):     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     print(i, dist_mci, dist_qrt, model.df.nsnps.sum()) <pre>0 0.6044988508385621 0.6285714285714286 616328\n1 0.6044988508385621 0.6285714285714286 609840\n2 0.484844581260579 0.4714285714285714 607740\n</pre> In\u00a0[27]: Copied! <pre>model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\nmodel.sim_loci(nloci=1, nsites=1e6)\n</pre> model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG) model.sim_loci(nloci=1, nsites=1e6) In\u00a0[28]: Copied! <pre>raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n</pre> raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4) In\u00a0[23]: Copied! <pre>raxtree.draw(ts='s',  edge_type='c', );\n</pre> raxtree.draw(ts='s',  edge_type='c', ); 012345678910111213r7r0r6r5r4r2r3r1 In\u00a0[10]: Copied! <pre>model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\nmodel.sim_loci(nloci=500, nsites=int(1e6 / 500))\ngtrees = list(iter_first_genealogies(model))\natree = ipcoal.phylo.infer_astral_tree(gtrees)\n</pre> model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG) model.sim_loci(nloci=500, nsites=int(1e6 / 500)) gtrees = list(iter_first_genealogies(model)) atree = ipcoal.phylo.infer_astral_tree(gtrees) In\u00a0[14]: Copied! <pre>atree.root(\"~r[0-3]\").draw();\n</pre> atree.root(\"~r[0-3]\").draw(); r4r5r7r6r2r3r1r0 In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[133]: Copied! <pre>for i in range(3):\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    print(i, dist_mci, dist_qrt, model.df.nsnps.sum())\n</pre> for i in range(3):     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     print(i, dist_mci, dist_qrt, model.df.nsnps.sum()) <pre>0 0.6044988508385621 0.6285714285714286 616328\n1 0.6044988508385621 0.6285714285714286 609840\n2 0.484844581260579 0.4714285714285714 607740\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\nfor i in range(100):\n    model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    ntopos = get_n_topos(model)\n    data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci\ndata.to_csv(\"./bal-varN-fixG-1\")\n</pre> data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float) for i in range(100):     model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     ntopos = get_n_topos(model)     data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci data.to_csv(\"./bal-varN-fixG-1\")  In\u00a0[78]: Copied! <pre>data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\nfor i in range(100):\n    model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\n    model.sim_loci(nloci=1, nsites=1e6)\n    raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)\n    dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)\n    dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference\n    ntopos = get_n_topos(model)\n    data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci\n\ndata.to_csv(\"./bal-fixN-varG-1\")\n</pre> data = pd.DataFrame(index=range(100), columns=[\"method\", \"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float) for i in range(100):     model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)     model.sim_loci(nloci=1, nsites=1e6)     raxtree = ipcoal.phylo.infer_raxml_ng_tree(model, nthreads=4)     dist_mci = TREE.distance.get_treedist_rfg_mci(raxtree, normalize=True)     dist_qrt = TREE.distance.get_treedist_quartets(raxtree).similarity_to_reference     ntopos = get_n_topos(model)     data.loc[i] = \"raxml\", 1, 1e6, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci  data.to_csv(\"./bal-fixN-varG-1\") Out[78]: nloci mean_snps_per_loc mean_topologies_per_loc tree distance_qrt distance_mci 0 1.0 102808.0 2312.0 ((r7:0.027027,r5:0.02607... 0.428571 0.586306 1 1.0 102403.0 2225.0 (r0:0.023672,r2:0.026822... 0.785714 0.840064 2 1.0 98636.0 1979.0 (((r0:0.024178,r4:0.0246... 0.657143 0.664200 3 1.0 101283.0 2154.0 (((r6:0.022732,r0:0.0263... 0.471429 0.527081 4 1.0 100409.0 2112.0 ((r7:0.02501,r2:0.027519... 0.857143 0.884520 ... ... ... ... ... ... ... 95 1.0 100314.0 2215.0 ((r5:0.025548,r4:0.02442... 0.600000 0.615993 96 1.0 101480.0 2208.0 ((r3:0.028213,((r5:0.026... 0.600000 0.750320 97 1.0 100135.0 2379.0 (r5:0.026733,((r2:0.0258... 0.757143 0.775203 98 1.0 102699.0 2248.0 ((r2:0.025885,r0:0.02612... 0.742857 0.823748 99 1.0 103375.0 2279.0 (r1:0.025407,(((r3:0.025... 0.600000 0.615993 <p>100 rows \u00d7 6 columns</p> In\u00a0[80]: Copied! <pre>\n</pre> In\u00a0[87]: Copied! <pre>for nloci in [500]:#[1, 20, 50, 100, 500, 1000]:\n    nsites = int(1e6 / nloci)\n    \n    data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\n\n    for i in range(2):\n        model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)\n        model.sim_loci(nloci=nloci, nsites=nsites)\n        raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)\n        astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)\n        dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)\n        dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference\n        ntopos = get_n_topos(model)\n        data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)\n    data.to_csv(f\"./bal-fixN-varG-{nloci}\")\n    print(f'finished nloci={nloci}')\n</pre> for nloci in [500]:#[1, 20, 50, 100, 500, 1000]:     nsites = int(1e6 / nloci)          data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)      for i in range(2):         model = ipcoal.Model(tree_gt, seed_mutations=RNG, seed_trees=RNG)         model.sim_loci(nloci=nloci, nsites=nsites)         raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)         astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)         dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)         dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference         ntopos = get_n_topos(model)         data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)     data.to_csv(f\"./bal-fixN-varG-{nloci}\")     print(f'finished nloci={nloci}') <pre>finished nloci=500\n</pre> In\u00a0[116]: Copied! <pre>genealogy.draw()\n</pre> genealogy.draw() Out[116]: <pre>(&lt;toyplot.canvas.Canvas at 0x7fd55c7d5c00&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7fd55c861330&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7fd557a5f400&gt;)</pre> r1r2r0r7r3r5r4r6 In\u00a0[113]: Copied! <pre>for _, df in model.df.groupby(\"locus\"):\n    genealogy = toytree.tree(df.iloc[0, 6])\n    dist = TREE.distance.get_treedist_quartets(genealogy).similarity_to_reference\n    print(dist)\n</pre> for _, df in model.df.groupby(\"locus\"):     genealogy = toytree.tree(df.iloc[0, 6])     dist = TREE.distance.get_treedist_quartets(genealogy).similarity_to_reference     print(dist) <pre>0.7857142857142857\n0.5857142857142856\n0.6285714285714286\n0.7857142857142857\n0.7142857142857143\n0.7285714285714286\n0.7428571428571429\n0.8285714285714285\n0.6285714285714286\n0.7428571428571429\n0.6285714285714286\n0.8142857142857143\n0.5714285714285714\n0.6857142857142857\n0.7714285714285715\n0.6\n0.6714285714285715\n0.48571428571428577\n0.7428571428571429\n0.8285714285714285\n0.6428571428571428\n0.6285714285714286\n0.8142857142857143\n0.6714285714285715\n0.8142857142857143\n0.6428571428571428\n0.6714285714285715\n0.6142857142857143\n0.6714285714285715\n0.6\n0.8142857142857143\n0.7714285714285715\n0.6\n0.8\n0.8285714285714285\n0.48571428571428577\n0.8428571428571429\n0.6142857142857143\n0.7285714285714286\n0.7428571428571429\n0.7142857142857143\n0.5428571428571429\n0.5\n0.4285714285714286\n0.5857142857142856\n0.6\n0.6714285714285715\n0.7428571428571429\n0.6285714285714286\n0.8\n0.5428571428571429\n0.7285714285714286\n0.7714285714285715\n0.6428571428571428\n0.5571428571428572\n0.6571428571428571\n0.4285714285714286\n0.6857142857142857\n0.7428571428571429\n0.7714285714285715\n0.8428571428571429\n0.6285714285714286\n0.7428571428571429\n0.7285714285714286\n0.8142857142857143\n0.7571428571428571\n0.5285714285714286\n0.7857142857142857\n0.8428571428571429\n0.6571428571428571\n0.7714285714285715\n0.7857142857142857\n0.8\n0.5\n0.6\n0.7142857142857143\n0.3571428571428571\n0.7428571428571429\n0.6142857142857143\n0.6857142857142857\n0.6\n0.7142857142857143\n0.6714285714285715\n0.6428571428571428\n0.7571428571428571\n0.5142857142857142\n0.7428571428571429\n0.4714285714285714\n0.5571428571428572\n0.37142857142857144\n0.6285714285714286\n0.4714285714285714\n0.7142857142857143\n0.7\n0.7714285714285715\n0.5857142857142856\n0.5714285714285714\n0.4285714285714286\n0.7428571428571429\n0.7285714285714286\n0.6142857142857143\n0.6714285714285715\n0.6714285714285715\n0.8428571428571429\n0.8\n0.7571428571428571\n0.8142857142857143\n0.48571428571428577\n0.7714285714285715\n0.7857142857142857\n0.4714285714285714\n0.6857142857142857\n0.6714285714285715\n0.7857142857142857\n0.7285714285714286\n0.7142857142857143\n0.7857142857142857\n0.5\n0.7428571428571429\n0.24285714285714288\n0.5142857142857142\n0.7714285714285715\n0.7714285714285715\n0.6285714285714286\n0.7285714285714286\n0.6714285714285715\n0.7428571428571429\n0.4285714285714286\n0.7714285714285715\n0.37142857142857144\n0.4571428571428572\n0.6428571428571428\n0.7857142857142857\n0.7857142857142857\n0.7142857142857143\n0.8\n0.6285714285714286\n0.5857142857142856\n0.8285714285714285\n0.6\n0.7428571428571429\n0.6428571428571428\n0.7714285714285715\n0.8285714285714285\n0.8285714285714285\n0.5285714285714286\n0.6428571428571428\n0.7285714285714286\n0.7285714285714286\n0.7142857142857143\n0.6714285714285715\n0.6285714285714286\n0.8142857142857143\n0.5\n0.6714285714285715\n0.30000000000000004\n0.8571428571428572\n0.5285714285714286\n0.6\n0.6428571428571428\n0.6571428571428571\n0.7714285714285715\n0.6857142857142857\n0.41428571428571426\n0.6142857142857143\n0.5857142857142856\n0.7857142857142857\n0.5714285714285714\n0.4714285714285714\n0.6\n0.6285714285714286\n0.5285714285714286\n0.5857142857142856\n0.6285714285714286\n0.6142857142857143\n0.6857142857142857\n0.4285714285714286\n0.8\n0.4285714285714286\n0.8428571428571429\n0.6428571428571428\n0.5142857142857142\n0.7714285714285715\n0.6285714285714286\n0.8\n0.5857142857142856\n0.6285714285714286\n0.8142857142857143\n0.6714285714285715\n0.6857142857142857\n0.7428571428571429\n0.6428571428571428\n0.6857142857142857\n0.5714285714285714\n0.7857142857142857\n0.6285714285714286\n0.7428571428571429\n0.7857142857142857\n0.7142857142857143\n0.5285714285714286\n0.6571428571428571\n0.6714285714285715\n0.8428571428571429\n0.6857142857142857\n0.7428571428571429\n0.6142857142857143\n0.6714285714285715\n0.6857142857142857\n0.7285714285714286\n0.7571428571428571\n0.7428571428571429\n0.3571428571428571\n0.8142857142857143\n0.3571428571428571\n0.7428571428571429\n0.8142857142857143\n0.8142857142857143\n0.8285714285714285\n0.4285714285714286\n0.5571428571428572\n0.5857142857142856\n0.6857142857142857\n0.7428571428571429\n0.5285714285714286\n0.7285714285714286\n0.8142857142857143\n0.6\n0.7142857142857143\n0.5285714285714286\n0.5142857142857142\n0.6\n0.7857142857142857\n0.6428571428571428\n0.5571428571428572\n0.7857142857142857\n0.6428571428571428\n0.8142857142857143\n0.5\n0.6142857142857143\n0.8142857142857143\n0.6285714285714286\n0.6428571428571428\n0.7285714285714286\n0.6571428571428571\n0.7428571428571429\n0.8\n0.6142857142857143\n0.4714285714285714\n0.5\n0.7714285714285715\n0.7857142857142857\n0.6857142857142857\n0.8\n0.7285714285714286\n0.5142857142857142\n0.7142857142857143\n0.4285714285714286\n0.41428571428571426\n0.6285714285714286\n0.6714285714285715\n0.5285714285714286\n0.6\n0.6857142857142857\n0.8142857142857143\n0.6857142857142857\n0.7142857142857143\n0.8\n0.7285714285714286\n0.3571428571428571\n0.7142857142857143\n0.6\n0.7428571428571429\n0.6428571428571428\n0.7857142857142857\n0.6285714285714286\n0.7142857142857143\n0.7714285714285715\n0.5857142857142856\n0.7428571428571429\n0.8\n0.6\n0.7857142857142857\n0.5285714285714286\n0.7857142857142857\n0.6142857142857143\n0.6428571428571428\n0.8285714285714285\n0.48571428571428577\n0.6571428571428571\n0.7\n0.3571428571428571\n0.8428571428571429\n0.5142857142857142\n0.6428571428571428\n0.4714285714285714\n0.6142857142857143\n0.8142857142857143\n0.6142857142857143\n0.4714285714285714\n0.3571428571428571\n0.7857142857142857\n0.7428571428571429\n0.7571428571428571\n0.7142857142857143\n0.7285714285714286\n0.5\n0.7142857142857143\n0.6714285714285715\n0.6857142857142857\n0.4285714285714286\n0.7714285714285715\n0.7428571428571429\n0.5142857142857142\n0.6714285714285715\n0.6857142857142857\n0.4285714285714286\n0.7714285714285715\n0.8285714285714285\n0.4285714285714286\n0.7142857142857143\n0.6857142857142857\n0.6428571428571428\n0.6714285714285715\n0.7571428571428571\n0.7285714285714286\n0.6714285714285715\n0.8571428571428572\n0.5142857142857142\n0.5714285714285714\n0.7\n0.4285714285714286\n0.7285714285714286\n0.4285714285714286\n0.3571428571428571\n0.7285714285714286\n0.5571428571428572\n0.7714285714285715\n0.3571428571428571\n0.7428571428571429\n0.6714285714285715\n0.8142857142857143\n0.7142857142857143\n0.3571428571428571\n0.8142857142857143\n0.7\n0.3571428571428571\n0.7285714285714286\n0.6857142857142857\n0.4285714285714286\n0.7285714285714286\n0.7714285714285715\n0.6285714285714286\n0.7142857142857143\n0.6\n0.5714285714285714\n0.7714285714285715\n0.7571428571428571\n0.5142857142857142\n0.8142857142857143\n0.7285714285714286\n0.7428571428571429\n0.7285714285714286\n0.5714285714285714\n0.8285714285714285\n0.8142857142857143\n0.6\n0.6428571428571428\n0.5857142857142856\n0.8428571428571429\n0.7714285714285715\n0.5\n0.7142857142857143\n0.41428571428571426\n0.8142857142857143\n0.6428571428571428\n0.6\n0.5428571428571429\n0.5142857142857142\n0.5\n0.6\n0.5\n0.3571428571428571\n0.7571428571428571\n0.6714285714285715\n0.6142857142857143\n0.6428571428571428\n0.3571428571428571\n0.4714285714285714\n0.6142857142857143\n0.7285714285714286\n0.6285714285714286\n0.7714285714285715\n0.8142857142857143\n0.7428571428571429\n0.8285714285714285\n0.6428571428571428\n0.7428571428571429\n0.7\n0.6\n0.5142857142857142\n0.7142857142857143\n0.7857142857142857\n0.7571428571428571\n0.6428571428571428\n0.7857142857142857\n0.7714285714285715\n0.5714285714285714\n0.7857142857142857\n0.4571428571428572\n0.8428571428571429\n0.6714285714285715\n0.7285714285714286\n0.3571428571428571\n0.8428571428571429\n0.6428571428571428\n0.7142857142857143\n0.4285714285714286\n0.7285714285714286\n0.5\n0.48571428571428577\n0.6428571428571428\n0.7857142857142857\n0.6285714285714286\n0.6714285714285715\n0.7714285714285715\n0.7142857142857143\n0.7142857142857143\n0.7142857142857143\n0.6\n0.5428571428571429\n0.6142857142857143\n0.3571428571428571\n0.7142857142857143\n0.6\n0.6142857142857143\n0.6428571428571428\n0.7857142857142857\n0.6714285714285715\n0.6\n0.6285714285714286\n0.6285714285714286\n0.6\n0.6714285714285715\n0.5285714285714286\n0.6285714285714286\n0.6428571428571428\n0.7285714285714286\n0.5857142857142856\n0.7714285714285715\n0.7428571428571429\n0.8571428571428572\n0.6\n0.6428571428571428\n0.7714285714285715\n0.7285714285714286\n0.44285714285714284\n0.4571428571428572\n0.8428571428571429\n0.6142857142857143\n0.7428571428571429\n0.8285714285714285\n0.6285714285714286\n0.5428571428571429\n0.7142857142857143\n0.8285714285714285\n0.5571428571428572\n0.6142857142857143\n0.7285714285714286\n0.7571428571428571\n0.7285714285714286\n0.5285714285714286\n0.22857142857142854\n0.5285714285714286\n0.5857142857142856\n0.7\n0.4285714285714286\n0.4571428571428572\n0.6428571428571428\n0.7857142857142857\n0.6714285714285715\n0.7142857142857143\n0.6142857142857143\n0.6428571428571428\n0.7142857142857143\n0.5857142857142856\n0.6142857142857143\n0.7428571428571429\n0.7\n0.6714285714285715\n0.4571428571428572\n0.5142857142857142\n0.7857142857142857\n0.7714285714285715\n0.6428571428571428\n0.6571428571428571\n0.7857142857142857\n0.8142857142857143\n0.4285714285714286\n0.6714285714285715\n0.6714285714285715\n</pre> In\u00a0[\u00a0]: Copied! <pre>for nloci in [1, 20, 50, 100, 500, 1000]:\n    nsites = int(1e6 / nloci)\n    \n    data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)\n\n    for i in range(100):\n        model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)\n        model.sim_loci(nloci=nloci, nsites=nsites)\n        raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)\n        astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)\n        dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)\n        dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference\n        ntopos = get_n_topos(model)\n        data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)\n    data.to_csv(f\"./bal-varN-fixG-{nloci}\")\n    print(f'finished nloci={nloci}')\n</pre> for nloci in [1, 20, 50, 100, 500, 1000]:     nsites = int(1e6 / nloci)          data = pd.DataFrame(index=range(100), columns=[\"nloci\", \"locus_length\", \"mean_snps_per_loc\", \"mean_topologies_per_loc\", \"tree\", \"distance_qrt\", \"distance_mci\"], dtype=float)      for i in range(100):         model = ipcoal.Model(tree_ne, seed_mutations=RNG, seed_trees=RNG)         model.sim_loci(nloci=nloci, nsites=nsites)         raxtrees = ipcoal.phylo.infer_raxml_ng_trees(model, nthreads=4, nworkers=2)         astral_tree = ipcoal.phylo.infer_astral_tree(raxtrees.gene_tree)         dist_mci = TREE.distance.get_treedist_rfg_mci(astral_tree, normalize=True)         dist_qrt = TREE.distance.get_treedist_quartets(astral_tree).similarity_to_reference         ntopos = get_n_topos(model)         data.loc[i] = (nloci, nsites, model.df.nsnps.sum(), ntopos, raxtree.write(), dist_qrt, dist_mci)     data.to_csv(f\"./bal-varN-fixG-{nloci}\")     print(f'finished nloci={nloci}') In\u00a0[85]: Copied! <pre>cat ./bal-fixN-varG-20\n</pre> cat ./bal-fixN-varG-20 <pre>,method,nloci,locus_length,mean_snps_per_loc,mean_topologies_per_loc,tree,distance_qrt,distance_mci\r\n0,astral,20.0,50000.0,100037.0,3.719,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n1,astral,20.0,50000.0,101689.0,3.733,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n2,astral,20.0,50000.0,101243.0,3.799,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n3,astral,20.0,50000.0,101487.0,3.7,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n4,astral,20.0,50000.0,101650.0,3.737,\"(r1:0.025407,(((r3:0.025742,r2:0.025302):0.006943,(r0:0.026001,r5:0.024882):0.005497):0.002393,(r4:0.026065,r7:0.024732):0.006042):0.006311,r6:0.024598);\",0.6,0.6159932318991975\r\n5,,,,,,,,\r\n6,,,,,,,,\r\n7,,,,,,,,\r\n8,,,,,,,,\r\n9,,,,,,,,\r\n10,,,,,,,,\r\n11,,,,,,,,\r\n12,,,,,,,,\r\n13,,,,,,,,\r\n14,,,,,,,,\r\n15,,,,,,,,\r\n16,,,,,,,,\r\n17,,,,,,,,\r\n18,,,,,,,,\r\n19,,,,,,,,\r\n20,,,,,,,,\r\n21,,,,,,,,\r\n22,,,,,,,,\r\n23,,,,,,,,\r\n24,,,,,,,,\r\n25,,,,,,,,\r\n26,,,,,,,,\r\n27,,,,,,,,\r\n28,,,,,,,,\r\n29,,,,,,,,\r\n30,,,,,,,,\r\n31,,,,,,,,\r\n32,,,,,,,,\r\n33,,,,,,,,\r\n34,,,,,,,,\r\n35,,,,,,,,\r\n36,,,,,,,,\r\n37,,,,,,,,\r\n38,,,,,,,,\r\n39,,,,,,,,\r\n40,,,,,,,,\r\n41,,,,,,,,\r\n42,,,,,,,,\r\n43,,,,,,,,\r\n44,,,,,,,,\r\n45,,,,,,,,\r\n46,,,,,,,,\r\n47,,,,,,,,\r\n48,,,,,,,,\r\n49,,,,,,,,\r\n50,,,,,,,,\r\n51,,,,,,,,\r\n52,,,,,,,,\r\n53,,,,,,,,\r\n54,,,,,,,,\r\n55,,,,,,,,\r\n56,,,,,,,,\r\n57,,,,,,,,\r\n58,,,,,,,,\r\n59,,,,,,,,\r\n60,,,,,,,,\r\n61,,,,,,,,\r\n62,,,,,,,,\r\n63,,,,,,,,\r\n64,,,,,,,,\r\n65,,,,,,,,\r\n66,,,,,,,,\r\n67,,,,,,,,\r\n68,,,,,,,,\r\n69,,,,,,,,\r\n70,,,,,,,,\r\n71,,,,,,,,\r\n72,,,,,,,,\r\n73,,,,,,,,\r\n74,,,,,,,,\r\n75,,,,,,,,\r\n76,,,,,,,,\r\n77,,,,,,,,\r\n78,,,,,,,,\r\n79,,,,,,,,\r\n80,,,,,,,,\r\n81,,,,,,,,\r\n82,,,,,,,,\r\n83,,,,,,,,\r\n84,,,,,,,,\r\n85,,,,,,,,\r\n86,,,,,,,,\r\n87,,,,,,,,\r\n88,,,,,,,,\r\n89,,,,,,,,\r\n90,,,,,,,,\r\n91,,,,,,,,\r\n92,,,,,,,,\r\n93,,,,,,,,\r\n94,,,,,,,,\r\n95,,,,,,,,\r\n96,,,,,,,,\r\n97,,,,,,,,\r\n98,,,,,,,,\r\n99,,,,,,,,\r\n</pre> In\u00a0[18]: Copied! <pre>model = ipcoal.Model(tree_gt)\nmodel.sim_loci(nloci=1, nsites=1e6)\n</pre> model = ipcoal.Model(tree_gt) model.sim_loci(nloci=1, nsites=1e6) In\u00a0[19]: Copied! <pre>raxtree = ipcoal.phylo.infer_raxml_ng_tree(model)\n</pre> raxtree = ipcoal.phylo.infer_raxml_ng_tree(model) In\u00a0[22]: Copied! <pre>raxtree.draw(ts='s', edge_type='c',);\n# fixed_order=TREE.get_tip_labels());\n</pre> raxtree.draw(ts='s', edge_type='c',); # fixed_order=TREE.get_tip_labels()); 012345678910111213r7r6r4r1r3r0r5r2 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"gentime-ne/#species-tree-scenario-w-fixed-ne-and-variable-gt","title":"Species tree scenario w/ fixed <code>Ne</code> and variable <code>gt</code>\u00b6","text":"<p>Define two species trees w/ different parameterizations. One has variable effective populations (Ne) and fixed generation times (gt), the other has fixed Ne and variable gt. Both have the same species tree in terms of topology and edge lengths in coalescent units.</p>"},{"location":"gentime-ne/#tree1-variable-ne-fixed-gt","title":"Tree1: Variable <code>Ne</code>, fixed <code>gt</code>\u00b6","text":""},{"location":"gentime-ne/#tree-2-fixed-ne-variable-gt","title":"Tree 2: Fixed <code>Ne</code>, variable <code>gt</code>\u00b6","text":""},{"location":"gentime-ne/#some-useful-functions","title":"Some useful functions\u00b6","text":""},{"location":"gentime-ne/#phylogenetic-inference","title":"Phylogenetic inference\u00b6","text":"<ul> <li>N loci = 1000</li> <li>Locus length = 1e6, 1e5, 1e4, 1e3</li> <li>N replicates = 100</li> </ul>"},{"location":"gentime-ne/#concatenation","title":"Concatenation\u00b6","text":""},{"location":"gentime-ne/#astral","title":"Astral\u00b6","text":""},{"location":"installation/","title":"Installation","text":"<p><code>toytree</code> can be installed using pip or conda (or mamba), any of which will pull in all required dependencies. We also provide instructions below for installing from source (GitHub).</p>"},{"location":"installation/#conda-install-recommended","title":"Conda install (recommended)","text":"<pre><code>$ conda install toytree -c conda-forge\n</code></pre>"},{"location":"installation/#pip-install","title":"Pip install","text":"<pre><code>$ pip install toytree\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>Our goal is to maintain <code>toytree</code> as a minimalist library that does not require substantial dependencies outside of the standard Python scientific stack (i.e., numpy, scipy, and pandas). </p> <pre><code>- python&gt;=3.7\n- numpy\n- scipy\n- pandas\n- loguru\n- requests\n- toyplot\n- ghostscript  # to save PNGs\n</code></pre>"},{"location":"installation/#installing-development-versions","title":"Installing Development Versions","text":"<pre><code>$ git clone https://github.com/eaton-lab/toytree.git\n$ cd toytree\n$ conda install toytree -c conda-forge --only-deps\n$ pip install -e . --no-deps\n</code></pre>"},{"location":"installation/#building-the-documentation","title":"Building the documentation","text":"<pre><code>$ conda install mkdocs-material mkdocstrings-python mkdocs-jupyter -c conda-forge\n</code></pre>"},{"location":"multitree/","title":"MultiTree","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre>multinewick = \"\"\"\\\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n</pre> multinewick = \"\"\"\\ (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\" In\u00a0[3]: Copied! <pre># create an mtree from a string, list of strings, url, or file.\nmtree1 = toytree.mtree(multinewick)\nmtree1\n</pre> # create an mtree from a string, list of strings, url, or file. mtree1 = toytree.mtree(multinewick) mtree1 Out[3]: <pre>&lt;toytree.MultiTree ntrees=8&gt;</pre> In\u00a0[4]: Copied! <pre># generate 50 random coalescent trees each with 6 tips\ncoaltrees = [toytree.rtree.coaltree(k=6) for i in range(50)]\n</pre> # generate 50 random coalescent trees each with 6 tips coaltrees = [toytree.rtree.coaltree(k=6) for i in range(50)] In\u00a0[5]: Copied! <pre># create a MultiTree from a list of ToyTrees\nmtree2 = toytree.mtree(coaltrees)\nmtree2\n</pre> # create a MultiTree from a list of ToyTrees mtree2 = toytree.mtree(coaltrees) mtree2 Out[5]: <pre>&lt;toytree.MultiTree ntrees=50&gt;</pre> In\u00a0[6]: Copied! <pre># get first tree\nmtree1[0]\n</pre> # get first tree mtree1[0] Out[6]: <pre>&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;</pre> In\u00a0[7]: Copied! <pre># get all trees\nmtree1[:]\n</pre> # get all trees mtree1[:] Out[7]: <pre>[&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab9270&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8b20&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8550&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abb7f0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abbbe0&gt;,\n &lt;toytree.ToyTree at 0x7f03c58ec190&gt;]</pre> In\u00a0[8]: Copied! <pre># slice the first three trees\nmtree1[:3]\n</pre> # slice the first three trees mtree1[:3] Out[8]: <pre>[&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab9270&gt;]</pre> In\u00a0[9]: Copied! <pre># iterate over ToyTrees in a MultiTree\nfor tree in mtree1:\n    print(tree)\n</pre> # iterate over ToyTrees in a MultiTree for tree in mtree1:     print(tree) <pre>&lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab9270&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab8b20&gt;\n&lt;toytree.ToyTree at 0x7f03c5ab8550&gt;\n&lt;toytree.ToyTree at 0x7f03c5abb7f0&gt;\n&lt;toytree.ToyTree at 0x7f03c5abbbe0&gt;\n&lt;toytree.ToyTree at 0x7f03c58ec190&gt;\n</pre> In\u00a0[10]: Copied! <pre># re-arrange trees in the treelist to send the first to be last\nmtree1.treelist = mtree1.treelist[1:] + [mtree1.treelist[0]]\nmtree1[:]\n</pre> # re-arrange trees in the treelist to send the first to be last mtree1.treelist = mtree1.treelist[1:] + [mtree1.treelist[0]] mtree1[:] Out[10]: <pre>[&lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab9270&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8b20&gt;,\n &lt;toytree.ToyTree at 0x7f03c5ab8550&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abb7f0&gt;,\n &lt;toytree.ToyTree at 0x7f03c5abbbe0&gt;,\n &lt;toytree.ToyTree at 0x7f03c58ec190&gt;,\n &lt;toytree.ToyTree at 0x7f03c5aba7a0&gt;]</pre> In\u00a0[11]: Copied! <pre>mtree1.ntrees\n</pre> mtree1.ntrees Out[11]: <pre>8</pre> In\u00a0[12]: Copied! <pre>mtree1.all_tree_tip_labels_same()\n</pre> mtree1.all_tree_tip_labels_same() Out[12]: <pre>True</pre> In\u00a0[13]: Copied! <pre>mtree1.all_tree_topologies_same()\n</pre> mtree1.all_tree_topologies_same() Out[13]: <pre>False</pre> In\u00a0[14]: Copied! <pre>mtree1.all_tree_tips_aligned()\n</pre> mtree1.all_tree_tips_aligned() Out[14]: <pre>False</pre> In\u00a0[15]: Copied! <pre># get a consensus tree \nctree = mtree1.get_consensus_tree()\n\n# plot the tree showing 'support' values\nctree.draw(\n    ts='r', layout=\"unrooted\", width=350, height=350,\n    node_labels=\"support\", node_sizes=14, node_as_edge_data=True);\n</pre> # get a consensus tree  ctree = mtree1.get_consensus_tree()  # plot the tree showing 'support' values ctree.draw(     ts='r', layout=\"unrooted\", width=350, height=350,     node_labels=\"support\", node_sizes=14, node_as_edge_data=True); 0.750.75abdec In\u00a0[16]: Copied! <pre># get (tree, count) for each unique topology in the MultiTree\nmtree1.get_unique_topologies()\n</pre> # get (tree, count) for each unique topology in the MultiTree mtree1.get_unique_topologies() Out[16]: <pre>[[&lt;toytree.ToyTree at 0x7f03c5ab9270&gt;, 6],\n [&lt;toytree.ToyTree at 0x7f03c5ab97e0&gt;, 1],\n [&lt;toytree.ToyTree at 0x7f03c58ec190&gt;, 1]]</pre> In\u00a0[19]: Copied! <pre># draw a 2x4 grid of trees with 30px margins between them\nmtree1.draw(ts='o', shape=(2, 4), width=600, height=300, margin=25, fixed_order=['c', 'b', 'e', 'a', 'd']);\n</pre> # draw a 2x4 grid of trees with 30px margins between them mtree1.draw(ts='o', shape=(2, 4), width=600, height=300, margin=25, fixed_order=['c', 'b', 'e', 'a', 'd']); adbecabdecabdecabdecbadecabdecbdaecabdec In\u00a0[27]: Copied! <pre># draw a cloud tree\nmtree1.draw_cloud_tree(\n    scale_bar=True,\n    edge_style={\n        \"stroke-opacity\": 0.1,\n        \"stroke-width\": 3,\n    },\n);\n</pre> # draw a cloud tree mtree1.draw_cloud_tree(     scale_bar=True,     edge_style={         \"stroke-opacity\": 0.1,         \"stroke-width\": 3,     }, ); adbec3210"},{"location":"multitree/#multitree","title":"MultiTree\u00b6","text":"<p>The <code>toytree.MultiTree</code> class object is used to represent a collection of <code>ToyTree</code> objects and includes attributes and methods for describing this set or performing operations on it. Common examples of tree sets include bootstrap replicate samples or posterior distributions of sampled trees; common operations on sets of trees include consensus tree inference, computing discordance or distance statistics, and plotting tree grids or cloud trees.</p>"},{"location":"multitree/#generating-multitrees","title":"Generating MultiTrees\u00b6","text":"<p>MultiTree objects can be generated from a list of Toytrees or newick strings, or by parsing a file, url, or string of text that includes newick trees separated by newlines. The convenience function <code>toytree.mtree()</code> can be used to parse multitree input data similar to how the function <code>toytree.tree</code> is used to parse individual trees, and supports the same file formats.</p>"},{"location":"multitree/#from-tree-data","title":"From tree data\u00b6","text":"<p>Below is an example multi-newick string representing multiple trees as newick strings separated by newlines. You can create a MultiTree from this input data, entered as a string or filepath, by passing it to the <code>toytree.mtree()</code> convenience parsing function. Each tree will be parsed individually and stored as a list of <code>ToyTree</code> objects contained within a returned <code>MultiTree</code> object.</p>"},{"location":"multitree/#from-a-collection-of-trees","title":"From a collection of trees\u00b6","text":"<p>Similarly, you can create a <code>MultiTree</code> by providing a collection of <code>ToyTree</code> objects to the <code>toytree.mtree</code> function. Here we generate a list of 50 random coalescent trees and pass the list as input to create a new <code>MultiTree</code>.</p>"},{"location":"multitree/#indexable-and-iterable","title":"Indexable and Iterable\u00b6","text":"<p>One or more trees can be indexed or sliced from a <code>MultiTree</code>, and sequential trees can be accessed through iteration. The trees themselves are stored in the <code>.treelist</code> attribute of the <code>MultiTree</code> object as a list. This can be modified to remove, add, or reorder the trees. Several example operations are shown below for accessing one or more trees.</p>"},{"location":"multitree/#attributes-and-types-of-tree-sets","title":"Attributes and types of tree sets\u00b6","text":"<p>Most of the time <code>MultiTree</code> objects are used to hold a collection of trees that all share the same tip labels, such as a collection of bootstrap replicates. But, in other cases, a <code>MultiTree</code> could hold a collection of unrelated trees, in which case some of the built-in functions for comparing trees (such as consensus tree inference) will raise an error, but it still provides a useful container for drawing trees. These methods will raise a ToyTreeError when attempted if the tree set is a mixed collection of trees. The  <code>MultiTree</code> class contains several functions to quickly check attributes of the tree set to examine the number of trees, whether they share the same tip names, and whether the trees are rooted or ultrametric.</p>"},{"location":"multitree/#consensus-trees","title":"Consensus trees\u00b6","text":"<p>A majority-rule consensus tree is a tree that represents the most common non-conflicting splits among a set of input trees. In <code>toytree</code> this can be inferred from a <code>MultiTree</code> object using the <code>.get_consensus_tree</code>, which returns a <code>ToyTree</code> with the consensus topology on which several types of statistics have been stored to nodes. This can be useful in several contexts, but one of the simplest is to find the most common order of tip names among a set of trees, so that when you make a <code>MultiTree</code> plot you can order tips in the same way to more easily visualize variation among trees. There are many options and uses for consensus trees, check out the Consensus Trees documentation section for more details.</p> <p>In the example below we get a consensus tree from the <code>mtree1</code> multitree object which contains 8 trees. The support values on this returned tree represent the proportion of trees in the input set that contain each clade in the consensus tree. By default, the returned tree is unrooted, since the input trees may vary in their rooting. Here the trees exhibit variation in the relationships among <code>(a,b,d,e)</code> with <code>(a,b)</code> and <code>(d,e)</code> each occurring in 75% of trees.</p>"},{"location":"multitree/#unique-trees","title":"Unique trees\u00b6","text":"<p>Given a set of trees it is useful to be able to pull out just the unique topologies from the set. The function <code>get_unique_topologies()</code> returns a list of <code>(tree, int)</code> tuples from a <code>MultiTree</code> with each unique topology paired with its number of occurrences in the set. Note, this condenses all trees with the same topology into a single representative, using the first occurrence as the returned tree, thus branch length variation is not retained. See the <code>toytree.distance</code> subpackage for many additional methods for comparing trees and computing differences/distances between them.</p>"},{"location":"multitree/#drawing-with-multitrees","title":"Drawing with MultiTrees\u00b6","text":"<p>There are two main ways to draw groups of trees from <code>MultiTree</code> objects. The first is simply called <code>.draw()</code> and is used to plot multiple trees onto a shared canvas arranged into a grid. These trees can be arranged each on their own axes, or on shared axes to better compare scales. The second method is <code>.draw_cloud_tree</code>, which plots a set of trees over top of one another, usually at low opacity, as a way of examining discordance and variation among a set of trees. These are sometimes called cloud trees, densitrees, or other similar names. A simple example of each is shown below.</p>"},{"location":"multitree/#grid-tree-drawings","title":"Grid tree drawings\u00b6","text":"<p>The <code>.draw()</code> function of a <code>MultiTree</code> returns multiple tree drawings layed out on a grid. The shape of the grid, and which trees from the tree set are drawn, can be set with the <code>shape</code> and <code>idxs</code> arguments. This also accepts all of the standard drawing arguments that can be used when drawing individual trees. See Drawing Tree Grids.</p>"},{"location":"multitree/#cloud-tree-drawings","title":"Cloud tree drawings\u00b6","text":"<p>It is sometimes even more informative to plot a number of trees on top of each other to visualize their discordance. These are sometimes called \u201cdensitree\u201d plots, or here, \u201ccloud tree plots\u201d. See the documentation section on Drawing Cloud Trees for more details and examples.</p>"},{"location":"node/","title":"Node","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># create an example tree\ntree = toytree.rtree.rtree(ntips=8, seed=321)\ntree.draw('c');\n</pre> # create an example tree tree = toytree.rtree.rtree(ntips=8, seed=321) tree.draw('c'); r0r1r2r3r4r5r6r701234 In\u00a0[3]: Copied! <pre># create a new Node\nsingle_node = toytree.Node(name=\"single\")\nsingle_node\n</pre> # create a new Node single_node = toytree.Node(name=\"single\") single_node Out[3]: <pre>&lt;Node(name='single')&gt;</pre> In\u00a0[4]: Copied! <pre># select a Node from a ToyTree\nnode3 = tree[3]\nnode3\n</pre> # select a Node from a ToyTree node3 = tree[3] node3 Out[4]: <pre>&lt;Node(idx=3, name='r3')&gt;</pre> In\u00a0[5]: Copied! <pre># check that an object's type is a Node \nisinstance(node3, toytree.Node)\n</pre> # check that an object's type is a Node  isinstance(node3, toytree.Node) Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre># a name can be accessed from a Node\nsingle_node.name\n</pre> # a name can be accessed from a Node single_node.name Out[6]: <pre>'single'</pre> In\u00a0[7]: Copied! <pre># a name can be accessed from a Node in a ToyTree\ntree[3].name\n</pre> # a name can be accessed from a Node in a ToyTree tree[3].name Out[7]: <pre>'r3'</pre> In\u00a0[8]: Copied! <pre># returns .name from Nodes in the order they will be plotted (idxorder)\ntree.get_tip_labels()\n</pre> # returns .name from Nodes in the order they will be plotted (idxorder) tree.get_tip_labels() Out[8]: <pre>['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7']</pre> In\u00a0[9]: Copied! <pre># a Node that is not part of a ToyTree has idx=-1\nsingle_node.idx\n</pre> # a Node that is not part of a ToyTree has idx=-1 single_node.idx Out[9]: <pre>-1</pre> In\u00a0[10]: Copied! <pre># Nodes in a ToyTree have unique idx values between 0 and nnodes - 1\nnode3.idx\n</pre> # Nodes in a ToyTree have unique idx values between 0 and nnodes - 1 node3.idx Out[10]: <pre>3</pre> In\u00a0[11]: Copied! <pre># default Node dist\nsingle_node.dist\n</pre> # default Node dist single_node.dist Out[11]: <pre>0.0</pre> In\u00a0[12]: Copied! <pre># the dist from node 3 to its parent\nnode3.dist\n</pre> # the dist from node 3 to its parent node3.dist Out[12]: <pre>1.0</pre> In\u00a0[13]: Copied! <pre># the default support value\nsingle_node.support\n</pre> # the default support value single_node.support Out[13]: <pre>nan</pre> In\u00a0[14]: Copied! <pre># the default .up is None (no value is returned here)\nsingle_node.up\n</pre> # the default .up is None (no value is returned here) single_node.up In\u00a0[15]: Copied! <pre># node3's parent is Node 10\nnode3.up\n</pre> # node3's parent is Node 10 node3.up Out[15]: <pre>&lt;Node(idx=10)&gt;</pre> In\u00a0[16]: Copied! <pre># the parent of node3's parent is Node 11\nnode3.up.up\n</pre> # the parent of node3's parent is Node 11 node3.up.up Out[16]: <pre>&lt;Node(idx=13)&gt;</pre> In\u00a0[17]: Copied! <pre># this single Node has no children\nsingle_node.children\n</pre> # this single Node has no children single_node.children Out[17]: <pre>()</pre> In\u00a0[18]: Copied! <pre># internal Node 8 in the tree has two children\ntree[8].children\n</pre> # internal Node 8 in the tree has two children tree[8].children Out[18]: <pre>(&lt;Node(idx=0, name='r0')&gt;, &lt;Node(idx=1, name='r1')&gt;)</pre> In\u00a0[19]: Copied! <pre># single node has not height\nsingle_node.height\n</pre> # single node has not height single_node.height Out[19]: <pre>0.0</pre> In\u00a0[20]: Copied! <pre># leaf node 3 height\nnode3.height\n</pre> # leaf node 3 height node3.height Out[20]: <pre>1.0</pre> In\u00a0[21]: Copied! <pre># internal node 8 height\ntree[8].height\n</pre> # internal node 8 height tree[8].height Out[21]: <pre>2.0</pre> In\u00a0[22]: Copied! <pre>node3.is_leaf()\n</pre> node3.is_leaf() Out[22]: <pre>True</pre> In\u00a0[23]: Copied! <pre>node3.is_root()\n</pre> node3.is_root() Out[23]: <pre>False</pre> In\u00a0[24]: Copied! <pre>node3.get_ancestors()\n</pre> node3.get_ancestors() Out[24]: <pre>(&lt;Node(idx=10)&gt;, &lt;Node(idx=13)&gt;, &lt;Node(idx=14)&gt;)</pre> In\u00a0[25]: Copied! <pre>node3.get_descendants()\n</pre> node3.get_descendants() Out[25]: <pre>(&lt;Node(idx=3, name='r3')&gt;,)</pre> In\u00a0[26]: Copied! <pre>node3.get_leaves()\n</pre> node3.get_leaves() Out[26]: <pre>[&lt;Node(idx=3, name='r3')&gt;]</pre> In\u00a0[27]: Copied! <pre>node3.get_sisters()\n</pre> node3.get_sisters() Out[27]: <pre>(&lt;Node(idx=4, name='r4')&gt;,)</pre> In\u00a0[28]: Copied! <pre>node3.get_leaf_names()\n</pre> node3.get_leaf_names() Out[28]: <pre>['r3']</pre> <p>Each of the <code>get_[x]</code> functions above is also available as a generator function named <code>iter_[x]</code>, which is more efficient for fetching such data over very large trees, or for terminating a traversal over part of the tree once a condition has been met. The <code>traverse()</code> function is also a generator function.</p> In\u00a0[29]: Copied! <pre>node3.iter_ancestors()\n</pre> node3.iter_ancestors() Out[29]: <pre>&lt;generator object Node.iter_ancestors at 0x7f3ba6ca9bd0&gt;</pre> In\u00a0[30]: Copied! <pre>node3.traverse(\"idxorder\")\n</pre> node3.traverse(\"idxorder\") Out[30]: <pre>&lt;generator object Node._traverse_idxorder at 0x7f3ba6ca9d20&gt;</pre> In\u00a0[31]: Copied! <pre># edges are simply pairs of Nodes with a child,parent relationship\ntree.get_edges(feature='idx', df=True)\n</pre> # edges are simply pairs of Nodes with a child,parent relationship tree.get_edges(feature='idx', df=True) Out[31]: child parent 0 0 8 1 1 8 2 2 9 3 3 10 4 4 10 5 5 11 6 6 11 7 7 12 8 8 9 9 9 14 10 10 13 11 11 12 12 12 13 13 13 14 In\u00a0[32]: Copied! <pre># catch 'ToyTreeError' exception raised when trying to modify a Node attribute\ntry:\n    single_node.idx = 10\nexcept toytree.utils.ToytreeError as exc:\n    print(\"ToyTreeError:\", exc)\n</pre> # catch 'ToyTreeError' exception raised when trying to modify a Node attribute try:     single_node.idx = 10 except toytree.utils.ToytreeError as exc:     print(\"ToyTreeError:\", exc) <pre>ToyTreeError: Cannot set .idx attribute of a Node. If you are an advanced user then you can do so by setting ._idx. See the docs section on Modifying Nodes and Tree Topology.\n</pre> In\u00a0[33]: Copied! <pre># an example toytree.mod function that modifies node attributes\nrtree = tree.mod.root(\"r4\")\n\n# the new tree has different idx values b/c the traversal order changed\ntoytree.mtree([tree, rtree]).draw(ts='p');\n</pre> # an example toytree.mod function that modifies node attributes rtree = tree.mod.root(\"r4\")  # the new tree has different idx values b/c the traversal order changed toytree.mtree([tree, rtree]).draw(ts='p'); 01234567891011121314r0r1r2r3r4r5r6r701234567891011121314r4r3r5r6r7r0r1r2 In\u00a0[34]: Copied! <pre># create a new tree copy\nmodtree = tree.copy()\n\n# modify one or more private node attributes\nmodtree[0]._dist += 2\nmodtree[1]._dist += 3\n\n# call update to update idxs, heights, etc.\nmodtree._update()\n\n# show the old and new tree with longer .dists for nodes 0,1 and .heights for all nodes\ntoytree.mtree([tree, modtree]).draw(ts='p', scale_bar=True);\n</pre> # create a new tree copy modtree = tree.copy()  # modify one or more private node attributes modtree[0]._dist += 2 modtree[1]._dist += 3  # call update to update idxs, heights, etc. modtree._update()  # show the old and new tree with longer .dists for nodes 0,1 and .heights for all nodes toytree.mtree([tree, modtree]).draw(ts='p', scale_bar=True); 01234567891011121314r0r1r2r3r4r5r6r70123401234567891011121314r0r1r2r3r4r5r6r70246 <ol> <li>Generate random or fixed trees. See the <code>rtree</code> documentation section for more details. This includes options to generate trees under a variety of algorithms and of different sizes.</li> </ol> In\u00a0[35]: Copied! <pre># generate a 6-tip balanced tree with crown height of 1M units\ntoytree.rtree.baltree(6, treeheight=1e6).draw(scale_bar=True);\n</pre> # generate a 6-tip balanced tree with crown height of 1M units toytree.rtree.baltree(6, treeheight=1e6).draw(scale_bar=True); r0r1r2r3r4r510000005000000 <ol> <li>Parse a Newick string to generate a tree from scratch with desired characteristics.</li> </ol> In\u00a0[36]: Copied! <pre># generate a ToyTree with this specific data\ntoytree.tree(\"(((a:3,b:2):1),(c:3,d:2):5);\").draw(scale_bar=True);\n</pre> # generate a ToyTree with this specific data toytree.tree(\"(((a:3,b:2):1),(c:3,d:2):5);\").draw(scale_bar=True); abcd7.552.50 <ol> <li>Modify a tree using one or more <code>toytree.mod</code> functions:</li> </ol> In\u00a0[37]: Copied! <pre># get a 4-tip balanced tree\ntree4 = toytree.rtree.baltree(4)\n\n# add a new sister (internal and tip node) to tip node 'r1'\nmodtree4 = toytree.mod.add_internal_node_and_child(tree4, 'r1', name=\"child\", parent_name=\"parent\")\n\n# draw to highlight new parent and child nodes\nmodtree4.draw('r', node_mask=modtree4.get_node_mask(5), node_colors=\"lightgrey\");\n</pre> # get a 4-tip balanced tree tree4 = toytree.rtree.baltree(4)  # add a new sister (internal and tip node) to tip node 'r1' modtree4 = toytree.mod.add_internal_node_and_child(tree4, 'r1', name=\"child\", parent_name=\"parent\")  # draw to highlight new parent and child nodes modtree4.draw('r', node_mask=modtree4.get_node_mask(5), node_colors=\"lightgrey\"); parentr0r1childr2r3 <ol> <li>Create connections among <code>Node</code> objects and create a <code>ToyTree</code> from them. You can do this by setting <code>._up</code>, <code>._children</code>, and <code>._dist</code> values on a set of nodes.</li> </ol> In\u00a0[38]: Copied! <pre># create several tips nodes\nnodeA = toytree.Node(\"A\", dist=1)\nnodeB = toytree.Node(\"B\", dist=1)\nnodeC = toytree.Node(\"C\", dist=1)\n\n# create several internal Nodes\nnodeAB = toytree.Node(\"AB\", dist=1)\nnodeABC = toytree.Node(\"ABC\", dist=1)\n\n# connect the nodes\nnodeA._up = nodeAB\nnodeB._up = nodeAB\nnodeC._up = nodeABC\nnodeAB._up = nodeABC\nnodeAB._children = (nodeA, nodeB)\nnodeABC._children = (nodeAB, nodeC)\n\n# draw the tree (the tree traversal data is cached at this step)\ntoytree.tree(nodeABC).draw(ts='r', node_colors=\"lightgrey\");\n</pre> # create several tips nodes nodeA = toytree.Node(\"A\", dist=1) nodeB = toytree.Node(\"B\", dist=1) nodeC = toytree.Node(\"C\", dist=1)  # create several internal Nodes nodeAB = toytree.Node(\"AB\", dist=1) nodeABC = toytree.Node(\"ABC\", dist=1)  # connect the nodes nodeA._up = nodeAB nodeB._up = nodeAB nodeC._up = nodeABC nodeAB._up = nodeABC nodeAB._children = (nodeA, nodeB) nodeABC._children = (nodeAB, nodeC)  # draw the tree (the tree traversal data is cached at this step) toytree.tree(nodeABC).draw(ts='r', node_colors=\"lightgrey\"); ABABCABC <p>Similarly, this process could be applied to an existing tree to add or remove connections by changing the same types of node attributes. The important thing is that the <code>ToyTree._update()</code> function is called at the end to update values across connected nodes. The <code>Node</code> object includes convenience functions <code>_add_child</code> and <code>_remove_child</code> which change the <code>._up</code> and <code>._children</code> attributes together, but setting them manually may be more clear.</p> In\u00a0[39]: Copied! <pre># get a 4-tip balanced tree\ntree4 = toytree.rtree.baltree(4, treeheight=2)\n\n# add a new sister (internal and tip node) to tip node 0\ntree4[0]._add_child(toytree.Node(\"child0\", dist=1))\ntree4[0]._add_child(toytree.Node(\"child1\", dist=1))\n\n# connects node data across three\ntree4._update()\n\n# draw to highlight new nodes. Note former node (idx=0, name='r0') is now node idx=5\ntree4.draw('r', node_mask=tree4.get_node_mask(5), node_colors=\"lightgrey\");\n</pre> # get a 4-tip balanced tree tree4 = toytree.rtree.baltree(4, treeheight=2)  # add a new sister (internal and tip node) to tip node 0 tree4[0]._add_child(toytree.Node(\"child0\", dist=1)) tree4[0]._add_child(toytree.Node(\"child1\", dist=1))  # connects node data across three tree4._update()  # draw to highlight new nodes. Note former node (idx=0, name='r0') is now node idx=5 tree4.draw('r', node_mask=tree4.get_node_mask(5), node_colors=\"lightgrey\"); r0child0child1r1r2r3"},{"location":"node/#toytreenode","title":"toytree.Node\u00b6","text":"<p>The <code>toytree.Node</code> class is primarily used for data storage. Minimally, it contains attributes storing a <code>.name</code>, <code>.dist</code> (edge length), and <code>.support</code> values, as well as attributes <code>.up</code> and <code>.children</code> which point to other <code>Node</code> objects to represent connections between them.</p> <p>A single <code>Node</code> instance is generally of little use, it is only when nodes form connections that they have emergent properties in the form  a network/tree structure. Thus, most methods in the <code>toytree</code> library are associated with <code>ToyTree</code> objects which are a container around a collection of <code>Nodes</code>. However, <code>Node</code> objects themselves are important to understand as the underlying object storing data within trees. This section describes the structure of <code>Node</code> objects and the design behind their intended use.</p>"},{"location":"node/#the-node-class","title":"The Node class\u00b6","text":"<p>The <code>Node</code> class is accessible from <code>toytree.Node</code> and can be used to create new instances or to check or validate the type of a <code>Node</code> instance. Unless you are a developer you are not likely to create new <code>Node</code> objects often, but instead will most often interact them by selecting them from within <code>ToyTrees</code>.</p>"},{"location":"node/#attributes","title":"Attributes\u00b6","text":""},{"location":"node/#name-str","title":"name: str\u00b6","text":"<p>The default <code>name</code> attribute is an empty string. Leaf nodes usually have names associated with them whereas internal nodes usually do not. This will depend on the data that a tree is parsed or constructed from, and whether additional names are added. Some characters are not allowed in node names (<code>[:;(),\\[\\]\\t\\n\\r=]</code>) as they would interfere with Newick string parsing when written to a file. Names can be accessed from a <code>Node</code>'s <code>.name</code> attribute, and can be used to query nodes from a <code>ToyTree</code>.</p>"},{"location":"node/#idx-int","title":"idx: int\u00b6","text":"<p>The default <code>idx</code> attribute is an int value of -1, which means that the node is not part of a <code>ToyTree</code>. If a node is in a <code>ToyTree</code> then it will be assigned a unique idx integer between 0 and nnodes-1. The leaf nodes in a tree have idx values between 0 and ntips - 1, and all internal nodes are labeled by increasing numbers in a post-order left-then-right traversal. This is termed an idxorder traversal. When a tree structure changes (e.g. during re-rooting) the idx values of nodes are updated and can change (see Traversal). A node's idx value can be checked from its <code>.idx</code> attribute, or if it is in a <code>ToyTree</code> then by calling <code>.get_node_data()</code> or plotting the tree to visualize idx values.</p>"},{"location":"node/#dist-float","title":"dist: float\u00b6","text":"<p>The default <code>dist</code> attribute is a float of 0. The value represents the distance from a node to its parent. In other words, it is the length of an edge connecting them. The dist attribute is thus not actually a feature of a node, but of an edge between nodes, but is nevertheless stored to a <code>Node</code> object. We call this an <code>edge_feature</code> of a <code>Node</code>, since it will change if the tree is re-rooted, changing which Node is parent to another. The value of a dist can range from very small to very large values, such as when representing the expected number of substitutions per site on a phylogeny, or divergence times in millions of years.</p>"},{"location":"node/#support-float","title":"support: float\u00b6","text":"<p>The default <code>support</code> value is <code>numpy.nan</code>, which represents the absence of support information. Tip (leaf) nodes are not expected to have support information, since they do not represent a split in a tree. Similarly, the root node support is <code>nan</code> since it does not represent a true split.</p>"},{"location":"node/#up-node","title":"up: Node\u00b6","text":"<p>The <code>.up</code> attribute references a node's parent. The default value is <code>None</code>. This is also the value of the <code>.up</code> attribute of the root <code>Node</code> in a <code>ToyTree</code>, since it has no parent. A <code>Node</code> can only have one parent. If a tree is re-rooted the relationship between nodes can change such that a <code>Node</code> that was previously a child can become a parent, and thus the <code>Node</code> attributes are automatically updated during this process.</p>"},{"location":"node/#children-tuple","title":"children: tuple\u00b6","text":"<p>The <code>.children</code> attribute is a tuple of zero or more <code>Node</code> objects that are descended from a node. The default is an empty tuple. If a tree is re-rooted the relationship between nodes can change such that a <code>Node</code> that was previously a child can become a parent, and thus the <code>Node</code> attributes are automatically updated during this process.</p>"},{"location":"node/#height-float","title":"height: float\u00b6","text":"<p>The default <code>height</code> value is a float of 0. The height of a <code>Node</code> is an emergent property of a tree of connected nodes. It is the height above the node that is the farthest distance from the root. This value is automatically updated for every node in a <code>ToyTree</code> when a tree is modified during the cached traversal.</p>"},{"location":"node/#methods","title":"Methods\u00b6","text":"<p>The <code>Node</code> object provides a number of functions for fetching information about a node's position relative to other connected nodes. Some of this information is also accessible from a <code>ToyTree</code> object, but is sometimes easier to access it from a Node object directly.</p>"},{"location":"node/#nodes-vs-edges","title":"Nodes vs 'Edges'\u00b6","text":"<p>Notably, <code>toytree</code> does not implement a separate \"Edge\" class to represent edges in a tree. Instead, edges are simply represented by the connections between <code>Node</code> objects -- by their <code>.up</code> and <code>.children</code> attributes. (This can be important when storing new data types to a tree; see Edge features). Thus you can think of edges as pairs of nodes. You can fetch the edge information from a <code>ToyTree</code> in a variety of ways. Below we use the function <code>get_edges</code> which has options for returning this information in a number of tabular formats.</p>"},{"location":"node/#mutability-of-nodes","title":"Mutability of Nodes\u00b6","text":"<p>The data assigned to nodes may represent a feature of the node itself, or it may represent a feature of the edge connecting that node to its parent. In the latter case, it is important that the data be treated appropriately if the tree is modified, such as when a node is pruned from the tree, or the tree is re-rooted. In these cases, the edge features, such as the <code>.dist</code>, <code>.support</code>, and the connection information <code>.up</code> and <code>.children</code>, need to be automatically updated. Similarly, emergent properties of nodes in a tree, such as the <code>.height</code> of a node relative to the farthest leaf must be re-computed.</p> <p>The automatic updating of these attributes is done at the level of a <code>ToyTree</code>, not within individual <code>Nodes</code>, and thus we have intentionally designed these elements of <code>Node</code> objects to be immutable (you cannot modify them directly). Thus, users cannot call <code>node.idx = 3</code>  or <code>node.height = 100</code> to set these atrributes to a new value, since these attributes are properties of the node's placement with respect to other nodes in the tree, which need to also be updated. If you try to set one of these values a <code>ToyTreeError</code> exception will be raised like in the example below where we catch the exception and print it. For developers there is a simple workaround for this described further below.</p>"},{"location":"node/#calling-mod-functions","title":"Calling mod functions\u00b6","text":"<p>Instead of modifying a node's attributes directly you should instead call one of the tree modification functions from the <code>toytree.mod</code> subpackage that will ensure that the rest of the tree data is automatically updated along with the modified node data. Examples include the <code>.root</code>, <code>.drop_tips</code>, <code>prune</code>, <code>ladderize</code>, <code>rotate_nodes</code>, <code>edges_set_node_heights</code>, and many others which modify one or more <code>.up</code>, <code>.children</code>, <code>.idx</code>, <code>.dist</code>, or <code>.height</code> attributes of nodes in unison.</p>"},{"location":"node/#developing-mod-functions","title":"Developing mod functions\u00b6","text":"<p>Sometimes, however, you may really want to directly modify one or more core features of a <code>Node</code>, in which case it is possible, we just want to make sure that you are well aware of the necessary considerations to avoid errors in your code. You can examine the source code of the many <code>.mod</code> subpackage functions above for examples. Each of these core attributes is available as a private attribute (e.g., <code>._dist</code>, <code>._idx</code>) which can be modified without raising an exception. The key, however, is that after one or more private node attributes have been modified, the <code>ToyTree</code> traversal caching function named <code>._update()</code> must be called at the end to ensure that all of the linked attributes of nodes are updated.</p>"},{"location":"node/#building-trees-from-nodes","title":"Building trees from Nodes\u00b6","text":"<p>There are several ways of constructing trees in <code>toytree</code> from scratch. This most simple is to use one of the random tree generation functions from the <code>toytree.rtree</code> subpackage. A second method is to write a Newick string and parse it using the <code>toytree.tree</code> function. A third is to build or modify a tree using one or more functions from <code>toytree.mod</code> such as <code>.add_child_node</code>. And finally, the fourth method is to link together <code>Node</code> objects manually. The last is the most low-level method, which requires eventually calling <code>ToyTree._update()</code> to cache the traversal order and store idx values. Each of these is demonstrated below.</p>"},{"location":"parse_trees/","title":"parsing tree data","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># example newick string\nDATA = \"((tip1:2,tip2:2):1,tip3:3);\"\n\n# load/parse into a ToyTree\ntree = toytree.tree(DATA)\ntree\n</pre> # example newick string DATA = \"((tip1:2,tip2:2):1,tip3:3);\"  # load/parse into a ToyTree tree = toytree.tree(DATA) tree Out[2]: <pre>&lt;toytree.ToyTree at 0x7f6e4600b640&gt;</pre> <p>Take Home</p> <p>       You can parse almost any tree data (file, string, nexus, newick, etc) using toytree.tree().   </p> In\u00a0[3]: Copied! <pre># newick: represents a topology using nested parentheses\nNEWICK0 = \"((,),);\"\n</pre> # newick: represents a topology using nested parentheses NEWICK0 = \"((,),);\" In\u00a0[4]: Copied! <pre># newick: name strings are usually present for tips as `(label,)`\nNEWICK1 = \"((tip1,tip2),tip3);\"\n</pre> # newick: name strings are usually present for tips as `(label,)` NEWICK1 = \"((tip1,tip2),tip3);\" In\u00a0[5]: Copied! <pre># newick: names can also be present for internal nodes as `()label`\nNEWICK2 = \"((tip1,tip2)internal1,tip3)internal2;\"\n</pre> # newick: names can also be present for internal nodes as `()label` NEWICK2 = \"((tip1,tip2)internal1,tip3)internal2;\" In\u00a0[6]: Copied! <pre># newick: edge lengths (dists) are usually present as `()label:dist`\nNEWICK3 = \"((tip1:2,tip2:2):1,tip3:3);\"\n</pre> # newick: edge lengths (dists) are usually present as `()label:dist` NEWICK3 = \"((tip1:2,tip2:2):1,tip3:3);\" In\u00a0[7]: Copied! <pre># newick: support values can be stored in place of internal names `()support`\nNEWICK4 = \"((tip1,tip2)100,tip3);\"\n</pre> # newick: support values can be stored in place of internal names `()support` NEWICK4 = \"((tip1,tip2)100,tip3);\" In\u00a0[8]: Copied! <pre># nhx: additional metadata is stored as key=value pairs as `()[meta]`\nNHX1 = \"((tip1[&amp;trait=2],tip2[&amp;trait=4])[&amp;trait=3],tip3[&amp;trait=1])[&amp;trait=5];\"\n</pre> # nhx: additional metadata is stored as key=value pairs as `()[meta]` NHX1 = \"((tip1[&amp;trait=2],tip2[&amp;trait=4])[&amp;trait=3],tip3[&amp;trait=1])[&amp;trait=5];\" In\u00a0[9]: Copied! <pre># nexus: newick/NHX data with other code blocks between (begin... end;)  \nNEXUS1 = \"\"\"\n#NEXUS\nbegin trees;\n    translate\n        1 apple,\n        2 blueberry,\n        3 cantaloupe,\n        4 durian,\n    ;\n    tree tree0 = [&amp;U] ((1,2),(3,4));\nend;\n\"\"\"\n</pre> # nexus: newick/NHX data with other code blocks between (begin... end;)   NEXUS1 = \"\"\" #NEXUS begin trees;     translate         1 apple,         2 blueberry,         3 cantaloupe,         4 durian,     ;     tree tree0 = [&amp;U] ((1,2),(3,4)); end; \"\"\" In\u00a0[10]: Copied! <pre># parse all 7 tree data strings from above into ToyTree objects\ndata = [NEWICK0, NEWICK1, NEWICK2, NEWICK3, NEWICK4, NHX1, NEXUS1]\ntrees = [toytree.tree(i) for i in data]\ntrees\n</pre> # parse all 7 tree data strings from above into ToyTree objects data = [NEWICK0, NEWICK1, NEWICK2, NEWICK3, NEWICK4, NHX1, NEXUS1] trees = [toytree.tree(i) for i in data] trees Out[10]: <pre>[&lt;toytree.ToyTree at 0x7f6e4600be50&gt;,\n &lt;toytree.ToyTree at 0x7f6e46048280&gt;,\n &lt;toytree.ToyTree at 0x7f6e460485e0&gt;,\n &lt;toytree.ToyTree at 0x7f6e46048a90&gt;,\n &lt;toytree.ToyTree at 0x7f6e46048f40&gt;,\n &lt;toytree.ToyTree at 0x7f6e460493f0&gt;,\n &lt;toytree.ToyTree at 0x7f6e46049900&gt;]</pre> In\u00a0[11]: Copied! <pre># print newick with str labels for tips and internal nodes\nprint(f\"Newick = {NEWICK2}\")\n\n# parse the newick string with .tree()\ntree = toytree.tree(NEWICK2)\n\n# show the tree data (labels were assigned to 'name' feature)\ntree.get_node_data()\n</pre> # print newick with str labels for tips and internal nodes print(f\"Newick = {NEWICK2}\")  # parse the newick string with .tree() tree = toytree.tree(NEWICK2)  # show the tree data (labels were assigned to 'name' feature) tree.get_node_data() <pre>Newick = ((tip1,tip2)internal1,tip3)internal2;\n</pre> Out[11]: idx name height dist support 0 0 tip1 0.0 1.0 NaN 1 1 tip2 0.0 1.0 NaN 2 2 tip3 1.0 1.0 NaN 3 3 internal1 1.0 1.0 NaN 4 4 internal2 2.0 0.0 NaN In\u00a0[12]: Copied! <pre># print newick with str labels for tips and int labels for internal nodes\nprint(f\"Newick = {NEWICK4}\")\n\n# parse the newick string with .tree()\ntree = toytree.tree(NEWICK4)\n\n# show the tree data (labels assigned to 'support' for internal Node)\ntree.get_node_data()\n</pre> # print newick with str labels for tips and int labels for internal nodes print(f\"Newick = {NEWICK4}\")  # parse the newick string with .tree() tree = toytree.tree(NEWICK4)  # show the tree data (labels assigned to 'support' for internal Node) tree.get_node_data() <pre>Newick = ((tip1,tip2)100,tip3);\n</pre> Out[12]: idx name height dist support 0 0 tip1 0.0 1.0 NaN 1 1 tip2 0.0 1.0 NaN 2 2 tip3 1.0 1.0 NaN 3 3 1.0 1.0 100.0 4 4 2.0 0.0 NaN In\u00a0[13]: Copied! <pre># parse the newick string with internal str labels and assign\ntre0 = toytree.tree(NEWICK2, internal_labels=\"arbitrary\")\n\n# show the tree data where labels were assigned to \"arbitrary\"\ntre0.get_node_data()\n</pre> # parse the newick string with internal str labels and assign tre0 = toytree.tree(NEWICK2, internal_labels=\"arbitrary\")  # show the tree data where labels were assigned to \"arbitrary\" tre0.get_node_data() Out[13]: idx name height dist support arbitrary 0 0 tip1 0.0 1.0 NaN NaN 1 1 tip2 0.0 1.0 NaN NaN 2 2 tip3 1.0 1.0 NaN NaN 3 3 1.0 1.0 NaN internal1 4 4 2.0 0.0 NaN internal2 In\u00a0[14]: Copied! <pre># only tip Node metadata\nNHX1 = \"((a[&amp;N=1],b[&amp;N=2]),c[&amp;N=3]);\"\n# only internal Node metadata\nNHX2 = \"((a,b)[&amp;N=4],c)[&amp;N=5];\"\n# both tip and internal Node metadata\nNHX3 = \"((a[&amp;N=1],b[&amp;N=2])[&amp;N=4],c[&amp;N=3])[&amp;N=5];\"\n# only edge metadata\nNHX4 = \"((a:1[&amp;E=1],b:1[&amp;E=2]):1[&amp;E=4],c:1[&amp;E=3]);\"\n# both node and edge metadata\nNHX5 = \"((a[&amp;N=1]:1[&amp;E=1],b[&amp;N=2]:1[&amp;E=2])[&amp;N=4]:1[&amp;E=4],c[&amp;N=3]:1[&amp;E=3])[&amp;N=5];\"\n</pre> # only tip Node metadata NHX1 = \"((a[&amp;N=1],b[&amp;N=2]),c[&amp;N=3]);\" # only internal Node metadata NHX2 = \"((a,b)[&amp;N=4],c)[&amp;N=5];\" # both tip and internal Node metadata NHX3 = \"((a[&amp;N=1],b[&amp;N=2])[&amp;N=4],c[&amp;N=3])[&amp;N=5];\" # only edge metadata NHX4 = \"((a:1[&amp;E=1],b:1[&amp;E=2]):1[&amp;E=4],c:1[&amp;E=3]);\" # both node and edge metadata NHX5 = \"((a[&amp;N=1]:1[&amp;E=1],b[&amp;N=2]:1[&amp;E=2])[&amp;N=4]:1[&amp;E=4],c[&amp;N=3]:1[&amp;E=3])[&amp;N=5];\" In\u00a0[15]: Copied! <pre># NHX1 has only tip node data mapped to feature \"N\"\ntoytree.tree(NHX1).get_node_data()\n</pre> # NHX1 has only tip node data mapped to feature \"N\" toytree.tree(NHX1).get_node_data() Out[15]: idx name height dist support N 0 0 a 0.0 1.0 NaN 1.0 1 1 b 0.0 1.0 NaN 2.0 2 2 c 1.0 1.0 NaN 3.0 3 3 1.0 1.0 NaN NaN 4 4 2.0 0.0 NaN NaN In\u00a0[16]: Copied! <pre># NHX5 has all node data mapped to feature \"N\" and edge data to feature \"E\"\ntoytree.tree(NHX5).get_node_data()\n</pre> # NHX5 has all node data mapped to feature \"N\" and edge data to feature \"E\" toytree.tree(NHX5).get_node_data() Out[16]: idx name height dist support E N 0 0 a 0.0 1.0 NaN 1.0 1.0 1 1 b 0.0 1.0 NaN 2.0 2.0 2 2 c 1.0 1.0 NaN 3.0 3.0 3 3 1.0 1.0 NaN 4.0 4.0 4 4 2.0 0.0 NaN NaN 5.0 In\u00a0[17]: Copied! <pre># nexus: Newick/NHX data with other code blocks between (begin... end;)  \nNEXUS_EXAMPLE = \"\"\"\n#NEXUS\nbegin data;\n    ...\nend;\n\nbegin mrbayes;\n    ...\nend;\n\nbegin trees;\n    translate\n        1 apple,\n        2 blueberry,\n        3 cantaloupe,\n        4 durian,\n    ;\n    tree tree0 = [&amp;U] ((1,2),(3,4));\nend;\n\"\"\"\n</pre> # nexus: Newick/NHX data with other code blocks between (begin... end;)   NEXUS_EXAMPLE = \"\"\" #NEXUS begin data;     ... end;  begin mrbayes;     ... end;  begin trees;     translate         1 apple,         2 blueberry,         3 cantaloupe,         4 durian,     ;     tree tree0 = [&amp;U] ((1,2),(3,4)); end; \"\"\" In\u00a0[18]: Copied! <pre># parse NEXUS file and show tree data\ntree = toytree.tree(NEXUS_EXAMPLE)\ntree.get_node_data()\n</pre> # parse NEXUS file and show tree data tree = toytree.tree(NEXUS_EXAMPLE) tree.get_node_data() Out[18]: idx name height dist support 0 0 apple 0.0 1.0 NaN 1 1 blueberry 0.0 1.0 NaN 2 2 cantaloupe 0.0 1.0 NaN 3 3 durian 0.0 1.0 NaN 4 4 1.0 1.0 NaN 5 5 1.0 1.0 NaN 6 6 2.0 0.0 NaN In\u00a0[19]: Copied! <pre># a str with Newick data separated by new lines\nMULTILINE_NEWICK = \"\"\"\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((a:1,d:1):1,(b:1,e:1):1):1,c:3);\n(((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5);\n(((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3);\n(((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3);\n(((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4);\n(((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3);\n(((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3);\n\"\"\"\n\n# parse with .mtree\nmtree = toytree.mtree(MULTILINE_NEWICK)\nmtree\n</pre> # a str with Newick data separated by new lines MULTILINE_NEWICK = \"\"\" (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((a:1,d:1):1,(b:1,e:1):1):1,c:3); (((a:1.5,b:1.5):1,(d:1,e:1):1.5):1,c:3.5); (((a:1.25,b:1.25):0.75,(d:1,e:1):1):1,c:3); (((a:1,b:1):1,(d:1.5,e:1.5):0.5):1,c:3); (((b:1,a:1):1,(d:1.5,e:1.5):0.5):2,c:4); (((a:1.5,b:1.5):0.5,(d:1,e:1):1):1,c:3); (((b:1.5,d:1.5):0.5,(a:1,e:1):1):1,c:3); \"\"\"  # parse with .mtree mtree = toytree.mtree(MULTILINE_NEWICK) mtree Out[19]: <pre>&lt;toytree.MultiTree ntrees=8&gt;</pre> In\u00a0[20]: Copied! <pre># a Nexus str with trees in a trees block\nMULTI_N5XUS = \"\"\"\n#NEXUS\nbegin trees;\n    translate\n        1 a,\n        2 b,\n        3 c,\n        4 d,\n        5 e,\n    ;\n    tree 1 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);\n    tree 2 = [&amp;R] (((1:1,4:1):1,(2:1,5:1):1):1,3:3);\n    tree 3 = [&amp;R] (((1:1.5,2:1.5):1,(4:1,5:1):1.5):1,3:3.5);\n    tree 4 = [&amp;R] (((1:1.25,2:1.25):0.75,(4:1,5:1):1):1,3:3);\n    tree 5 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);\n    tree 6 = [&amp;R] (((2:1,1:1):1,(4:1.5,5:1.5):0.5):2,3:4);\n    tree 7 = [&amp;R] (((1:1.5,2:1.5):0.5,(4:1,5:1):1):1,3:3);\n    tree 8 = [&amp;R] (((2:1.5,4:1.5):0.5,(1:1,5:1):1):1,3:3);\nend;\n\"\"\"\n\n# pars5 with .mtree\nmtree = toytree.mtree(MULTI_N5XUS)\nmtree\n</pre> # a Nexus str with trees in a trees block MULTI_N5XUS = \"\"\" #NEXUS begin trees;     translate         1 a,         2 b,         3 c,         4 d,         5 e,     ;     tree 1 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);     tree 2 = [&amp;R] (((1:1,4:1):1,(2:1,5:1):1):1,3:3);     tree 3 = [&amp;R] (((1:1.5,2:1.5):1,(4:1,5:1):1.5):1,3:3.5);     tree 4 = [&amp;R] (((1:1.25,2:1.25):0.75,(4:1,5:1):1):1,3:3);     tree 5 = [&amp;R] (((1:1,2:1):1,(4:1.5,5:1.5):0.5):1,3:3);     tree 6 = [&amp;R] (((2:1,1:1):1,(4:1.5,5:1.5):0.5):2,3:4);     tree 7 = [&amp;R] (((1:1.5,2:1.5):0.5,(4:1,5:1):1):1,3:3);     tree 8 = [&amp;R] (((2:1.5,4:1.5):0.5,(1:1,5:1):1):1,3:3); end; \"\"\"  # pars5 with .mtree mtree = toytree.mtree(MULTI_N5XUS) mtree Out[20]: <pre>&lt;toytree.MultiTree ntrees=8&gt;</pre> <p>If you call <code>toytree.mtree</code> on a file containing a single tree then it will simply return a <code>MultiTree</code> object containing only a single <code>ToyTree</code> within it. If you call <code>toytree.tree</code> on a file containing multiple trees it will return the first tree in the file as a <code>ToyTree</code>, but will also print a warning to make sure you know that the input contained multiple trees.</p> In\u00a0[21]: Copied! <pre># calling .mtree on a single tree input is OK\ntoytree.mtree(NEWICK1)\n</pre> # calling .mtree on a single tree input is OK toytree.mtree(NEWICK1) Out[21]: <pre>&lt;toytree.MultiTree ntrees=1&gt;</pre> In\u00a0[22]: Copied! <pre># calling .tree on a multiple tree input is also OK, but raises a WARNING\ntoytree.tree(MULTILINE_NEWICK)\n</pre> # calling .tree on a multiple tree input is also OK, but raises a WARNING toytree.tree(MULTILINE_NEWICK) <pre>\u26a0\ufe0f toytree | parse:parse_tree | Data contains (8) trees.\nLoading first using `toytree.tree`. Use `toytree.mtree` to instead load a MultiTree.\n</pre> Out[22]: <pre>&lt;toytree.ToyTree at 0x7f6e4600aec0&gt;</pre> In\u00a0[23]: Copied! <pre>toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\n</pre> toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\") Out[23]: <pre>&lt;toytree.ToyTree at 0x7f6e45e92ad0&gt;</pre>"},{"location":"parse_trees/#tree-parsing-io","title":"Tree Parsing (I/O)\u00b6","text":"<p>Parsing tree data involves loading a tree topology and associated metadata from a serialized text format into a data structure. <code>toytree</code> loads trees from a variety of text formats (Newick, nexus, NHX) stored in a file, URL, or string, and returns a <code>ToyTree</code> class object.</p> <p>This is made incredibly simple in <code>toytree</code> through the general purpose <code>toytree.tree()</code> function. In most cases, you can simply call this method on your data (string, file, or URL), without having to even specify the input data type or format.</p>"},{"location":"parse_trees/#tree-data-formats","title":"Tree data formats\u00b6","text":"<p>Below are examples of the common Newick, NHX, and Nexus tree data formats. Newick is the base format from which the other two formats are extensions. More details on parsing each format is described further below. While a few additional formats (e.g., JSON or XML) are sometimes used to store tree data, these Newick-based formats are most common.</p>"},{"location":"parse_trees/#parsing-toytrees-tldr","title":"Parsing ToyTrees (tldr;)\u00b6","text":"<p>Parsing tree data is made simple in <code>toytree</code> through the general purpose <code>toytree.tree()</code> function. For example, this method can parse all of the above data strings correctly without the need of any additional arguments to specify the data or metadata formats. Moreover, it can can parse these data regardless of whether they are entered as a string, or as a file path, or even a public URL. In this way, <code>toytree.tree()</code> acts as a sort of swiss army knife for tree data parsing.</p>"},{"location":"parse_trees/#newick-format","title":"Newick format\u00b6","text":"<p>A <code>ToyTree</code> can be flexibly loaded from a range of text formats. When parsing Newick data it is important to be aware of its limitations. Specifically, that internal node labels are sometimes used for different purposes, to store either node names, node support values (as int or floats), and sometimes for other forms of metadata. The <code>toytree.tree</code> function will auto-detect whether these labels should be stored as names or supports based on their values being numeric or not, however, you can also override this behavior to assign the values to a feature name of your choice. This is demonstrated below using two examples of Newick strings with different internal node label types (<code>NEWICK2</code> and <code>NEWICK4</code>, from above).</p>"},{"location":"parse_trees/#internal-labels-as-names","title":"Internal labels as names\u00b6","text":"<p>If any internal node labels present are non-numeric then they will be parsed and stored as \"name\" features of Nodes. In the example below the Newick string is parsed into a ToyTree object and its <code>.get_node_data()</code> function is called to show the tree's metadata, showing that labels were assigned to 'name'.</p>"},{"location":"parse_trees/#internal-labels-as-support","title":"Internal labels as support\u00b6","text":"<p>In contrast to the example above, you can see that the internal labels here are numeric and have thus been stored as \"support\" features instead of \"name\", and the internal nodes have names set to the default empty strings. This is the typical format of a Newick string generated by phylogenetic inference software, usually representing some kind of support values. Note that tip nodes/edges do not have support values, nor does the root edge. Support values are actually features of edges, not nodes. This is important for how they are re-oriented when trees are re-rooted (see Edge Features).</p>"},{"location":"parse_trees/#internal-labels-explicit","title":"Internal labels explicit\u00b6","text":"<p>As you've seen the use of internal Newick labels can be inconsistent, which is one of the main reasons that the extended Newick format (NHX) was developed, which will be introduced next. Nevertheless, instead of relying on the <code>toytree.tree</code> function to automatically parse the internal label as a name or support value, you can optionally enter the feature name you want the values assigned to explicitly using the <code>internal_labels</code> arg. For example, you could enter \"name\", or \"support\", in which case it will still be parsed as <code>str</code> or <code>float</code> tyeps, or you can enter any other name to store as a different feature name.</p>"},{"location":"parse_trees/#nhx-format","title":"NHX format\u00b6","text":"<p>The extended New Hampshire format (NHX) has emerged as a more recent and popular format for tree data storage (although unfortunately the precise rules for the format are not consistently followed). In addition to the standard information in Newick data provided by parentheses (topology) and edge lengths, any additional and arbitrary metadata can be stored within square brackets.</p> <p>The <code>toytree.tree()</code> function will automatically detect if square brackets are present in a Newick string and parse the associated metadata. It is important to note that different programs sometimes vary in the way that they store data inside of the square brackets, and so <code>toytree.tree</code> takes a number of additional optional arguments that can be entered to properly parse the NHX metadata. Below are some examples.</p> <p>Finally, NHX format has the advantage over Newick in that it can distinguish between data that is assigned to Nodes versus Edges in a tree. Data on edges, such as support values, are treated differently than data on nodes, such as trait values, when re-rooting trees (See Data/Features for more on this).</p>"},{"location":"parse_trees/#nexus-format","title":"NEXUS format\u00b6","text":"<p>The NEXUS format is popular in the field of phylogenetics because it provides a flexible format for storing a variety of information -- both data and instructions -- that can be used by multiple software tools. A NEXUS file starts with a \"#NEXUS\" header, and then contains one or more blocks delimited by \"begin\" and \"end;\" statements. For example, a \"data\" block would start with \"begin data\" and could contain morphological or molecular data. Another block might include code instructions for the mrbayes software, which takes a NEXUS file as input with instructions for an analysis. This could then write results to a \"trees\" block, which contains one or more Newick or NHX strings. In this way, a NEXUS file can fully describe an analysis from data -&gt; analysis -&gt; trees, as in the example below.</p> <p>For now, as far as <code>toytree</code> is concerned, only the \"trees\" block is of interest, and all other block are ignored. The <code>toytree.tree()</code> function will parse the tree data inside a NEXUS file just as it parses other Newick or NHX strings.</p>"},{"location":"parse_trees/#parsing-multitrees","title":"Parsing MultiTrees\u00b6","text":"<p>Sometimes data from multiple trees are stored together in a single file, such as the results of a bootstrap analysis, or a posterior distribution of trees from a Bayesian phylogenetic inference. <code>toytree</code> can parse and load all trees in a multiple tree input using the <code>toytree.mtree</code> function. This returns a <code>MultiTree</code> object (see MultiTree), which has methods that can apply to sets of trees, and from which individual <code>ToyTrees</code> can be indexed and extracted.</p>"},{"location":"parse_trees/#loading-trees-from-urls","title":"Loading trees from URLs\u00b6","text":"<p>A convenient feature of <code>toytree.tree</code> is the ability to laod tree data from a public URI. If you provide a string as input that begins with \"http\" then the str data of that URI will be checked for valid tree data. If so, it is returned as a tree. You can thus store your trees on any public site, such as a GitHub repo, and easily load it in without having to write out a long file path.</p>"},{"location":"query/","title":"node query/selection","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># load a toytree from a newick string at a URL and root it\ntree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\").root(\"~prz\")\n</pre> # load a toytree from a newick string at a URL and root it tree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\").root(\"~prz\") In\u00a0[3]: Copied! <pre># draw tree showing the idx labels representing the cached idxorder traversal\ntree.draw('s');\n</pre> # draw tree showing the idx labels representing the cached idxorder traversal tree.draw('s'); 012345678910111213141516171819202122232432082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides <p>Nodes can selected from a <code>ToyTree</code> by indexing, slicing by idx label.</p> In\u00a0[4]: Copied! <pre># select a single node by idx\ntree[1]\n</pre> # select a single node by idx tree[1] Out[4]: <pre>&lt;Node(idx=1, name='33588_przewalskii')&gt;</pre> In\u00a0[5]: Copied! <pre># select a slice of nodes by idx\ntree[3:5]\n</pre> # select a slice of nodes by idx tree[3:5] Out[5]: <pre>[&lt;Node(idx=3, name='30556_thamno')&gt;, &lt;Node(idx=4, name='40578_rex')&gt;]</pre> In\u00a0[6]: Copied! <pre># select a list of nodes by idx\ntree[[3, 4, 8, 9]]\n</pre> # select a list of nodes by idx tree[[3, 4, 8, 9]] Out[6]: <pre>[&lt;Node(idx=3, name='30556_thamno')&gt;,\n &lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=8, name='38362_rex')&gt;,\n &lt;Node(idx=9, name='29154_superba')&gt;]</pre> In\u00a0[7]: Copied! <pre># select all tip (leaf) nodes by slicing\ntree[:tree.ntips]\n</pre> # select all tip (leaf) nodes by slicing tree[:tree.ntips] Out[7]: <pre>[&lt;Node(idx=0, name='32082_przewalskii')&gt;,\n &lt;Node(idx=1, name='33588_przewalskii')&gt;,\n &lt;Node(idx=2, name='33413_thamno')&gt;,\n &lt;Node(idx=3, name='30556_thamno')&gt;,\n &lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=5, name='35855_rex')&gt;,\n &lt;Node(idx=6, name='35236_rex')&gt;,\n &lt;Node(idx=7, name='39618_rex')&gt;,\n &lt;Node(idx=8, name='38362_rex')&gt;,\n &lt;Node(idx=9, name='29154_superba')&gt;,\n &lt;Node(idx=10, name='30686_cyathophylla')&gt;,\n &lt;Node(idx=11, name='41954_cyathophylloides')&gt;,\n &lt;Node(idx=12, name='41478_cyathophylloides')&gt;]</pre> In\u00a0[8]: Copied! <pre># select all internal nodes by slicing\ntree[tree.ntips:tree.nnodes]\n</pre> # select all internal nodes by slicing tree[tree.ntips:tree.nnodes] Out[8]: <pre>[&lt;Node(idx=13)&gt;,\n &lt;Node(idx=14)&gt;,\n &lt;Node(idx=15)&gt;,\n &lt;Node(idx=16)&gt;,\n &lt;Node(idx=17)&gt;,\n &lt;Node(idx=18)&gt;,\n &lt;Node(idx=19)&gt;,\n &lt;Node(idx=20)&gt;,\n &lt;Node(idx=21)&gt;,\n &lt;Node(idx=22)&gt;,\n &lt;Node(idx=23)&gt;,\n &lt;Node(idx=24, name='root')&gt;]</pre> In\u00a0[9]: Copied! <pre># select the root node\ntree[-1]\n</pre> # select the root node tree[-1] Out[9]: <pre>&lt;Node(idx=24, name='root')&gt;</pre> In\u00a0[10]: Copied! <pre># select one node by name\ntree.get_nodes(\"40578_rex\")\n</pre> # select one node by name tree.get_nodes(\"40578_rex\") Out[10]: <pre>[&lt;Node(idx=4, name='40578_rex')&gt;]</pre> In\u00a0[11]: Copied! <pre># select multiple nodes by name\ntree.get_nodes(\"40578_rex\", \"38362_rex\")\n</pre> # select multiple nodes by name tree.get_nodes(\"40578_rex\", \"38362_rex\") Out[11]: <pre>[&lt;Node(idx=4, name='40578_rex')&gt;, &lt;Node(idx=8, name='38362_rex')&gt;]</pre> In\u00a0[12]: Copied! <pre># match any node name containing 'prz'\ntree.get_nodes(\"~prz\")\n</pre> # match any node name containing 'prz' tree.get_nodes(\"~prz\") Out[12]: <pre>[&lt;Node(idx=1, name='33588_przewalskii')&gt;,\n &lt;Node(idx=0, name='32082_przewalskii')&gt;]</pre> In\u00a0[13]: Copied! <pre># match any node name containing 855\ntree.get_nodes(\"~855\")\n</pre> # match any node name containing 855 tree.get_nodes(\"~855\") Out[13]: <pre>[&lt;Node(idx=5, name='35855_rex')&gt;]</pre> In\u00a0[14]: Copied! <pre># match any node name starting with a 4\ntree.get_nodes(\"~^4\")\n</pre> # match any node name starting with a 4 tree.get_nodes(\"~^4\") Out[14]: <pre>[&lt;Node(idx=11, name='41954_cyathophylloides')&gt;,\n &lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=12, name='41478_cyathophylloides')&gt;]</pre> In\u00a0[15]: Copied! <pre># match any node name ending with an 'a'\ntree.get_nodes(\"~a$\")\n</pre> # match any node name ending with an 'a' tree.get_nodes(\"~a$\") Out[15]: <pre>[&lt;Node(idx=9, name='29154_superba')&gt;,\n &lt;Node(idx=10, name='30686_cyathophylla')&gt;]</pre> In\u00a0[16]: Copied! <pre># match name containing a 3 followed by 8 or 9 then any chars followed by 'rex'\ntree.get_nodes(\"~3[8,9].+rex\")\n</pre> # match name containing a 3 followed by 8 or 9 then any chars followed by 'rex' tree.get_nodes(\"~3[8,9].+rex\") Out[16]: <pre>[&lt;Node(idx=7, name='39618_rex')&gt;, &lt;Node(idx=8, name='38362_rex')&gt;]</pre> In\u00a0[17]: Copied! <pre># select nodes by int idx labels, or by str names, or multiple by ~regex, or Node\ntree.get_nodes(0, 1, '40578_rex', tree[8])\n</pre> # select nodes by int idx labels, or by str names, or multiple by ~regex, or Node tree.get_nodes(0, 1, '40578_rex', tree[8]) Out[17]: <pre>[&lt;Node(idx=4, name='40578_rex')&gt;,\n &lt;Node(idx=1, name='33588_przewalskii')&gt;,\n &lt;Node(idx=8, name='38362_rex')&gt;,\n &lt;Node(idx=0, name='32082_przewalskii')&gt;]</pre> In\u00a0[18]: Copied! <pre># if you already know its idx (e.g., by tree visualization) you can index it\ntree[17]\n</pre> # if you already know its idx (e.g., by tree visualization) you can index it tree[17] Out[18]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[19]: Copied! <pre># or, you can find the mrca by knowing the tip node idxs\ntree.get_mrca_node(4, 5, 6, 7, 8)\n</pre> # or, you can find the mrca by knowing the tip node idxs tree.get_mrca_node(4, 5, 6, 7, 8) Out[19]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[20]: Copied! <pre># you actually only need to provide the minimal spanning nodes\ntree.get_mrca_node(4, 8)\n</pre> # you actually only need to provide the minimal spanning nodes tree.get_mrca_node(4, 8) Out[20]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[21]: Copied! <pre># safer, however, is to enter node names, since these never change\ntree.get_mrca_node(\"35855_rex\", \"40578_rex\", \"39618_rex\", \"35236_rex\", \"38362_rex\")\n</pre> # safer, however, is to enter node names, since these never change tree.get_mrca_node(\"35855_rex\", \"40578_rex\", \"39618_rex\", \"35236_rex\", \"38362_rex\") Out[21]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[22]: Copied! <pre># again, you only need to enter the minimal required\ntree.get_mrca_node(\"35855_rex\", \"38362_rex\")\n</pre> # again, you only need to enter the minimal required tree.get_mrca_node(\"35855_rex\", \"38362_rex\") Out[22]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[23]: Copied! <pre># simpler, use a regular expression to match all names with 'rex'\ntree.get_mrca_node(\"~rex\")\n</pre> # simpler, use a regular expression to match all names with 'rex' tree.get_mrca_node(\"~rex\") Out[23]: <pre>&lt;Node(idx=17)&gt;</pre> In\u00a0[24]: Copied! <pre>%%timeit\n# time to select a tip node by its idx (superfast)\ntree[7]\n</pre> %%timeit # time to select a tip node by its idx (superfast) tree[7] <pre>152 ns \u00b1 1.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n</pre> In\u00a0[25]: Copied! <pre>%%timeit\n# time to select a tip node by its name\ntree.get_nodes(\"39618_rex\")\n</pre> %%timeit # time to select a tip node by its name tree.get_nodes(\"39618_rex\") <pre>10.8 \u00b5s \u00b1 36.6 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</pre> In\u00a0[26]: Copied! <pre>%%timeit\n# time to select an internal node (17) by its known index\ntree[17]\n</pre> %%timeit # time to select an internal node (17) by its known index tree[17] <pre>156 ns \u00b1 0.887 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n</pre> In\u00a0[27]: Copied! <pre>%%timeit\n# time to find mrca (17) by mrca of idx labels\ntree.get_mrca_node(4, 8)\n</pre> %%timeit # time to find mrca (17) by mrca of idx labels tree.get_mrca_node(4, 8) <pre>27.6 \u00b5s \u00b1 338 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[28]: Copied! <pre>%%timeit\n# time to find mrca (17) by mrca of name labels\ntree.get_mrca_node(\"~rex\")\n</pre> %%timeit # time to find mrca (17) by mrca of name labels tree.get_mrca_node(\"~rex\") <pre>63.4 \u00b5s \u00b1 267 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[29]: Copied! <pre>tree.mod.root(\"~prz\").draw();\n</pre> tree.mod.root(\"~prz\").draw(); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[30]: Copied! <pre># drop all 'rex' samples\ntree.mod.drop_tips(\"~rex*\").draw();\n</pre> # drop all 'rex' samples tree.mod.drop_tips(\"~rex*\").draw(); 32082_przewalskii33588_przewalskii33413_thamno30556_thamno29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[31]: Copied! <pre># keep only the subtree connecting 'rex' samples\ntree.mod.prune(\"~rex*\").draw();\n</pre> # keep only the subtree connecting 'rex' samples tree.mod.prune(\"~rex*\").draw(); 40578_rex35855_rex35236_rex39618_rex38362_rex"},{"location":"query/#node-queryselection","title":"Node query/selection\u00b6","text":"<p>Many methods in <code>toytree</code> require selecting one or more nodes from a tree to operate on. This can often be challenging since most nodes in a tree usually do not have unique names assigned to them, and selecting nodes by a numeric indexing method can be error-prone if the indices change. We have tried to design the node query and selection methods in <code>toytree</code> to be maximally flexible to allow for ease-of-use when selecting nodes while also trying to prevent users from making simple and common mistakes.</p>"},{"location":"query/#select-nodes-by-index-idx","title":"Select Nodes by index (idx)\u00b6","text":"<p>The simplest and fastest approach to get <code>Node</code> objects from a ToyTree is to select them by their <code>idx</code> label. In fact, the storage of Nodes in a cached traversal order for fast recall is one of the main advantages of the ToyTree class. The tip nodes are intuitively labeled from left to right (or bottom to top, depending on the tree orientation) as idx labels from 0 to ntips - 1, and the root node is at idx label nnodes - 1.</p>"},{"location":"query/#select-nodes-by-name","title":"Select Nodes by name\u00b6","text":"<p>To select nodes by name you can use the <code>get_nodes</code> function. This is most useful for selecting tip nodes, since these are often the only nodes that have unique names, whereas internal nodes usually have empty name attributes. Internal nodes can be queried by using their idx labels, or, as demonstrated below, they can be selected based on tip names by using the function <code>get_mrca_node</code>.</p>"},{"location":"query/#using-regular-expressions","title":"Using regular expressions ~\u00b6","text":"<p>Regular expressions are a sequence of characters that match a pattern, and are often used in search algorithms. In <code>toytree</code> there are many functions which optionally accept regular expressions as an input to allow for easily selecting multiple nodes. This can be used because the operation is intended to operate on each of these nodes individually (e.g., <code>toytree.mod.drop_tips</code>) or because the operation will find the most recent common ancestor of the input nodes and operate on that edge or subtree (e.g., <code>toytree.mod.root</code>, or <code>toytree.mod.extract_subtree</code>; see below).</p> <p>All of these functions that accept name strings as input use the <code>get_nodes</code> function under the hood to find the matched nodes, and so our demonstrations below will use this function. In addition to accepting one or more individual name strings this function can also accept regular expressions as input.</p> <p>To indicate that an entry should be treated as a regular expression use the <code>~</code> prefix. It will then use the Python standard library regular expression function <code>re.search()</code> to find any nodes that match this query.</p>"},{"location":"query/#node-queries","title":"Node queries\u00b6","text":"<p>We define a query as a flexible type of input used to match one or more nodes. For functions which accept a query as input, an <code>int</code> will be treated as a Node idx label, whereas a <code>str</code> will be treated as a Node <code>name</code>, and a <code>str</code> starting with a <code>~</code> will be treated as a regular expression. These functions can also accept a <code>Node</code> object as an input. You can even mix these arguments to select multiple nodes.</p>"},{"location":"query/#get_nodes","title":"<code>get_nodes()</code>\u00b6","text":"<p>The function <code>get_nodes</code> is used widely both by users as well as internally by other functions. It takes <code>*query</code> as input meaning that it accepts any number of queries as input.</p>"},{"location":"query/#get_mrca_node","title":"<code>get_mrca_node()</code>\u00b6","text":"<p>Many tree operations require selecting an internal node to operate on. For example, rooting a tree on a clade. This is easiest done by selecting two tip nodes by name for which the internal node target is the most recent common ancestor (mrca), and providing these as entries to the <code>get_mrca_node</code> function. This function accepts query arguments the same way as <code>get_nodes</code>, accepting int, str, or <code>~</code>regex entries.</p> <p>Consider the example below where wish to find the internal node that is the mrca of the five tip nodes in the example tree forming the \"rex\" clade. We can select this node in several ways:</p>"},{"location":"query/#efficiencyspeed","title":"Efficiency/speed\u00b6","text":"<p>Because matching nodes by name requires traversing over all nodes in the tree to find matches it is much slower than selecting nodes by indexing with idx labels. All of the methods are still pretty fast, the time difference only matters when writing very time-intensive code. This is demonstrated simply below.</p>"},{"location":"query/#best-practices","title":"Best practices\u00b6","text":"<p>There are many situations in which you know the tree structure will not change, and thus indexing by node idx is faster and much preferred to slower name selection. Especially when you are selecting the tip or root nodes, which have obvious numeric labels. However, in other cases it is preferable to use names when selecting nodes, such as when adding traits or labels to internal nodes for tree drawings, since it makes your code more readable and explicit.</p>"},{"location":"query/#node-queries-are-everywhere","title":"Node Queries are everywhere\u00b6","text":"<p>You will find that many functions in <code>toytree</code> accept query type inputs that are used to match nodes following the node query methods described above. These are especially common in the <code>toytree.mod</code> subpackage.</p>"},{"location":"quick_guide/","title":"Quick Guide","text":"In\u00a0[1]: Copied! <pre>import toytree\ntoytree.__version__\n</pre> import toytree toytree.__version__ Out[1]: <pre>'3.0.dev9'</pre> In\u00a0[2]: Copied! <pre># load a toytree from a newick string at a URL\nutree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\n\n# re-root on internal edge selected using a regex string\nrtree = utree.root(\"~prz\")\n\n# draw the rooted tree\nrtree.draw(node_hover=True, node_sizes=8, tip_labels_align=True);\n</pre> # load a toytree from a newick string at a URL utree = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")  # re-root on internal edge selected using a regex string rtree = utree.root(\"~prz\")  # draw the rooted tree rtree.draw(node_hover=True, node_sizes=8, tip_labels_align=True); idx: 13 dist: 0.0179371130487 support: 100 height: 0.0152107514239 name: idx: 14 dist: 0.00222999650239 support: 100 height: 0.00577636172318 name: idx: 15 dist: 0.00617527349892 support: 100 height: 0.00109218434613 name: idx: 16 dist: 0.000738900380519 support: 96 height: 0.00726745784506 name: idx: 17 dist: 0.000783365499905 support: 99 height: 0.00800635822557 name: idx: 18 dist: 0.00103379657491 support: 100 height: 0.00878972372548 name: idx: 19 dist: 0.00538723112355 support: 100 height: 0.00982352030039 name: idx: 20 dist: 0.00237994755604 support: 100 height: 0.00985454237589 name: idx: 21 dist: 0.00941020878048 support: 100 height: 0.00282428115145 name: idx: 22 dist: 0.00297626149201 support: 100 height: 0.0122344899319 name: idx: 23 dist: 0.0179371130487 support: 100 height: 0.0152107514239 name: idx: 24 dist: 0 support: nan height: 0.0331478644727 name: root32082_przewalskii33588_przewalskii33413_thamno30556_thamno40578_rex35855_rex35236_rex39618_rex38362_rex29154_superba30686_cyathophylla41954_cyathophylloides41478_cyathophylloides In\u00a0[3]: Copied! <pre># newick str with edge-lengths &amp; support values\nnewick = \"((a:1,b:1)90:3,(c:3,(d:1,e:1)100:2)100:1);\"\n\n# load as ToyTree\ntree = toytree.tree(newick)\n\n# show tree data parsed from Newick str\ntree.get_node_data()\n</pre> # newick str with edge-lengths &amp; support values newick = \"((a:1,b:1)90:3,(c:3,(d:1,e:1)100:2)100:1);\"  # load as ToyTree tree = toytree.tree(newick)  # show tree data parsed from Newick str tree.get_node_data() Out[3]: idx name height dist support 0 0 a 0.0 1.0 NaN 1 1 b 0.0 1.0 NaN 2 2 c 0.0 3.0 NaN 3 3 d 0.0 1.0 NaN 4 4 e 0.0 1.0 NaN 5 5 1.0 3.0 90.0 6 6 1.0 2.0 100.0 7 7 3.0 1.0 100.0 8 8 4.0 0.0 NaN <p>The data that make up a tree can be easily accessed in a number of ways, including during tree visualization. Here a number of options are provided to the <code>.draw()</code> function to style the drawing. The \"node_labels\" option is set to \"idx\", which matches one of the features in the tree data, and so the data (numeric labels) are mapped to the appropriate nodes in the tree. Similarly, the \"edge_colors\" option is set to \"dist\" which automatically applies a colormapping to values of the \"dist\" data in the tree. This approach of assigning data to Nodes of the tree and then mapping these values to a drawing is more secure than trying to correctly order and enter values as a list. See Data/Features for more details.</p> In\u00a0[4]: Copied! <pre># tree drawing showing Node idx labels and edges colored by dist\ntree.draw(\n    layout='d', \n    node_labels=\"idx\", node_sizes=15, node_mask=False, node_colors=\"lightgrey\",\n    edge_colors=\"dist\", edge_widths=3,\n    tip_labels_style={\"font-size\": 20, \"anchor-shift\": 20},\n    scale_bar=True,\n);\n</pre> # tree drawing showing Node idx labels and edges colored by dist tree.draw(     layout='d',      node_labels=\"idx\", node_sizes=15, node_mask=False, node_colors=\"lightgrey\",     edge_colors=\"dist\", edge_widths=3,     tip_labels_style={\"font-size\": 20, \"anchor-shift\": 20},     scale_bar=True, ); 012345678abcde01234 <p>Node: See the Node class documentation. Users primarily interact with Node objects by selecting them from a tree through indexing, slicing, or traversal methods. Nodes are used to store the basic data that makes up a tree, such as the connections between nodes and their distances. In addition, nodes can be used to store any additional arbitrary data. Each <code>Node</code> in a <code>ToyTree</code> has a unique ID assigned to it referred to as its <code>idx</code> label, and which represents its order in a tip-to-root traversal of the tree (see Traversal and Node selection).</p> In\u00a0[5]: Copied! <pre># you can create a Node object on its own\ntoytree.Node(name=\"X\")\n</pre> # you can create a Node object on its own toytree.Node(name=\"X\") Out[5]: <pre>&lt;Node(name='X')&gt;</pre> In\u00a0[6]: Copied! <pre># but more often you will select Nodes from a tree by slicing or indexing\ntree[0]\n</pre> # but more often you will select Nodes from a tree by slicing or indexing tree[0] Out[6]: <pre>&lt;Node(idx=0, name='a')&gt;</pre> In\u00a0[7]: Copied! <pre># a Node's parent is at .up\ntree[0].up\n</pre> # a Node's parent is at .up tree[0].up Out[7]: <pre>&lt;Node(idx=5)&gt;</pre> In\u00a0[8]: Copied! <pre># a Node's children are at .children\ntree[5].children\n</pre> # a Node's children are at .children tree[5].children Out[8]: <pre>(&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=1, name='b')&gt;)</pre> In\u00a0[9]: Copied! <pre># select one or more Nodes from a ToyTree by name\ntree.get_nodes(\"a\", \"c\")\n</pre> # select one or more Nodes from a ToyTree by name tree.get_nodes(\"a\", \"c\") Out[9]: <pre>[&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=2, name='c')&gt;]</pre> In\u00a0[10]: Copied! <pre># access data from attributes of a Node in a ToyTree\ntree[0].idx, tree[0].name, tree[0].dist\n</pre> # access data from attributes of a Node in a ToyTree tree[0].idx, tree[0].name, tree[0].dist Out[10]: <pre>(0, 'a', 1.0)</pre> <p>ToyTree: See the ToyTree class documentation. A <code>ToyTree</code> stores a cached representation of the connections among a set of <code>Node</code> objects in memory and contains numerous methods for operating on these data. As we saw above, <code>ToyTree</code> class objects are usually created by parsing tree data from newick strings. However, a <code>ToyTree</code> can also be created by passing a <code>Node</code> object as the root of a new tree, as shown below. This makes clear that a <code>ToyTree</code> is a container for <code>Node</code> objects. They also contain functions for modifying the connections and data of nodes such as rooting trees, pruning, grafting, modifying edge lengths or support values, and storing new data, to name a few. If an operation changes the tree structure the <code>ToyTree</code> will automatically store a new cached representation of the tree traversal, assigning new <code>idx</code> labels to nodes. This allows for very fast retrieval of information from nodes, and to store cached tree attributes that are emergent properties of the collection of tree, such as node heights, and the number of tips and nodes.</p> In\u00a0[11]: Copied! <pre># create a tree from a Node object to serve as its root Node\ntoytree.ToyTree(toytree.Node(\"root\"))\n</pre> # create a tree from a Node object to serve as its root Node toytree.ToyTree(toytree.Node(\"root\")) Out[11]: <pre>&lt;toytree.ToyTree at 0x7fd8ef38a5c0&gt;</pre> In\u00a0[12]: Copied! <pre># parse a tree from newick data\ntoytree.tree(\"((a,b),c);\")\n</pre> # parse a tree from newick data toytree.tree(\"((a,b),c);\") Out[12]: <pre>&lt;toytree.ToyTree at 0x7fd8ef389a50&gt;</pre> In\u00a0[13]: Copied! <pre>tree.ntips\n</pre> tree.ntips Out[13]: <pre>5</pre> In\u00a0[14]: Copied! <pre>tree.nnodes\n</pre> tree.nnodes Out[14]: <pre>9</pre> In\u00a0[15]: Copied! <pre>tree[5].height\n</pre> tree[5].height Out[15]: <pre>1.0</pre> In\u00a0[16]: Copied! <pre># all nodes in the cached idx order (tips first then postorder traversal)\ntree[:]\n</pre> # all nodes in the cached idx order (tips first then postorder traversal) tree[:] Out[16]: <pre>[&lt;Node(idx=0, name='a')&gt;,\n &lt;Node(idx=1, name='b')&gt;,\n &lt;Node(idx=2, name='c')&gt;,\n &lt;Node(idx=3, name='d')&gt;,\n &lt;Node(idx=4, name='e')&gt;,\n &lt;Node(idx=5)&gt;,\n &lt;Node(idx=6)&gt;,\n &lt;Node(idx=7)&gt;,\n &lt;Node(idx=8)&gt;]</pre> In\u00a0[17]: Copied! <pre># or, use .traverse() to visit Nodes in other traversal orders\nlist(tree.traverse(\"postorder\"))\n</pre> # or, use .traverse() to visit Nodes in other traversal orders list(tree.traverse(\"postorder\")) Out[17]: <pre>[&lt;Node(idx=0, name='a')&gt;,\n &lt;Node(idx=1, name='b')&gt;,\n &lt;Node(idx=5)&gt;,\n &lt;Node(idx=2, name='c')&gt;,\n &lt;Node(idx=3, name='d')&gt;,\n &lt;Node(idx=4, name='e')&gt;,\n &lt;Node(idx=6)&gt;,\n &lt;Node(idx=7)&gt;,\n &lt;Node(idx=8)&gt;]</pre> <p>MultiTree: See the MultiTree documentation. A <code>MultiTree</code> object is a container type for multiple <code>ToyTree</code> objects. It has a number of attributes and methods specific to operating on and visualizing sets of trees. The <code>toytree.mtree()</code> function can be used to parse multiple input types similar to the <code>toytree.tree()</code> method for parsing trees from data for individual trees. Also, <code>toytree.MultiTree()</code> can accept a collection of <code>ToyTree</code> objects as input, demonstrating that multitrees are collections of trees.</p> In\u00a0[18]: Copied! <pre># create a MultiTree containing three copies of 'tree' rooted differently\nmtree = toytree.mtree([tree, tree.root('c'), tree.root('d', 'e')])\nmtree\n</pre> # create a MultiTree containing three copies of 'tree' rooted differently mtree = toytree.mtree([tree, tree.root('c'), tree.root('d', 'e')]) mtree Out[18]: <pre>&lt;toytree.MultiTree ntrees=3&gt;</pre> In\u00a0[19]: Copied! <pre># select individual ToyTrees by indexing or slicing\nmtree[0]\n</pre> # select individual ToyTrees by indexing or slicing mtree[0] Out[19]: <pre>&lt;toytree.ToyTree at 0x7fd8ef3e4c10&gt;</pre> In\u00a0[20]: Copied! <pre># visualization methods for multiple trees. Takes similar arguments as ToyTree.draw()\nmtree.draw(tip_labels_style={\"font-size\": 16});\n</pre> # visualization methods for multiple trees. Takes similar arguments as ToyTree.draw() mtree.draw(tip_labels_style={\"font-size\": 16}); abcdecdeabdecab In\u00a0[21]: Copied! <pre>tree.copy()\n</pre> tree.copy() Out[21]: <pre>&lt;toytree.ToyTree at 0x7fd8ef3f2da0&gt;</pre> In\u00a0[22]: Copied! <pre>tree.is_rooted()\n</pre> tree.is_rooted() Out[22]: <pre>True</pre> In\u00a0[23]: Copied! <pre>tree.is_monophyletic(\"a\", \"b\")\n</pre> tree.is_monophyletic(\"a\", \"b\") Out[23]: <pre>True</pre> In\u00a0[24]: Copied! <pre>tree.get_ancestors(\"a\")\n</pre> tree.get_ancestors(\"a\") Out[24]: <pre>{&lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=5)&gt;, &lt;Node(idx=8)&gt;}</pre> In\u00a0[25]: Copied! <pre>tree.get_mrca_node(\"d\", \"e\")\n</pre> tree.get_mrca_node(\"d\", \"e\") Out[25]: <pre>&lt;Node(idx=6)&gt;</pre> In\u00a0[26]: Copied! <pre>tree.get_tip_labels()\n</pre> tree.get_tip_labels() Out[26]: <pre>['a', 'b', 'c', 'd', 'e']</pre> In\u00a0[27]: Copied! <pre># select nodes by name\ntree.get_nodes(\"a\", \"b\")\n</pre> # select nodes by name tree.get_nodes(\"a\", \"b\") Out[27]: <pre>[&lt;Node(idx=1, name='b')&gt;, &lt;Node(idx=0, name='a')&gt;]</pre> In\u00a0[28]: Copied! <pre># select nodes by regular expression\ntree.get_nodes(\"~[a-c]\")\n</pre> # select nodes by regular expression tree.get_nodes(\"~[a-c]\") Out[28]: <pre>[&lt;Node(idx=1, name='b')&gt;, &lt;Node(idx=0, name='a')&gt;, &lt;Node(idx=2, name='c')&gt;]</pre> In\u00a0[29]: Copied! <pre># select internal node by mrca of tip names\ntree.get_mrca_node(\"a\", \"b\")\n</pre> # select internal node by mrca of tip names tree.get_mrca_node(\"a\", \"b\") Out[29]: <pre>&lt;Node(idx=5)&gt;</pre> In\u00a0[30]: Copied! <pre># or, select a node directly by its idx label\ntree[5]\n</pre> # or, select a node directly by its idx label tree[5] Out[30]: <pre>&lt;Node(idx=5)&gt;</pre> <p>rtree: Random tree generation functions. The <code>rtree</code> subpackage provides a variety of algorithms for generating random trees that can be used for learning, testing, or analyses. For example, random, balanced, imbalanced, birth-death, coalescent, and other forms of trees can be generated with a variety of options for setting data on the trees.</p> In\u00a0[31]: Copied! <pre># generate a birth-death tree\nbtree = toytree.rtree.bdtree(ntips=8, b=1, d=0.1, seed=123, random_names=True)\nbtree.draw(scale_bar=True);\n</pre> # generate a birth-death tree btree = toytree.rtree.bdtree(ntips=8, b=1, d=0.1, seed=123, random_names=True) btree.draw(scale_bar=True); r6r1r3r0r2r5r4r721.510.50 <p>enum: enumeration of tree data. Many algorithms for working with trees involve analyzing and comparing subsets of trees, such as bipartitions or quartets created by edges, or require knowing the number of possible trees of a given size. The <code>enum</code> subpackage provides a number of exact calculations, or generator functions, for accessing these data efficiently with a variety of formatting options. These methods are particularly useful for implementing or testing tree analysis methods.</p> In\u00a0[32]: Copied! <pre># expand a generator over all quartets in a tree\nlist(toytree.enum.iter_quartets(tree))\n</pre> # expand a generator over all quartets in a tree list(toytree.enum.iter_quartets(tree)) Out[32]: <pre>[({'a', 'b'}, {'d', 'e'}),\n ({'a', 'b'}, {'c', 'e'}),\n ({'a', 'b'}, {'c', 'd'}),\n ({'d', 'e'}, {'b', 'c'}),\n ({'d', 'e'}, {'a', 'c'})]</pre> <p>distance: node and tree distance metrics. Distances are a common type of measurement associated with trees, either in the form of measuring distances between nodes in a single tree, or comparing two or more trees using metrics of their (dis)similarity. A variety of methods for measuring node and tree distances are available in the <code>distance</code> subpackage.</p> In\u00a0[33]: Copied! <pre># return a matrix of distances between tips in a tree\ntoytree.distance.get_tip_distance_matrix(tree, df=True)\n</pre> # return a matrix of distances between tips in a tree toytree.distance.get_tip_distance_matrix(tree, df=True) Out[33]: a b c d e a 0.0 2.0 8.0 8.0 8.0 b 2.0 0.0 8.0 8.0 8.0 c 8.0 8.0 0.0 6.0 6.0 d 8.0 8.0 6.0 0.0 2.0 e 8.0 8.0 6.0 2.0 0.0 In\u00a0[34]: Copied! <pre># return the Robinson-Foulds tree distance between two random 10-tip trees\nrtree1 = toytree.rtree.rtree(10, seed=123)\nrtree2 = toytree.rtree.rtree(10, seed=321)\ntoytree.distance.get_treedist_rf(rtree1, rtree2, normalize=True)\n</pre> # return the Robinson-Foulds tree distance between two random 10-tip trees rtree1 = toytree.rtree.rtree(10, seed=123) rtree2 = toytree.rtree.rtree(10, seed=321) toytree.distance.get_treedist_rf(rtree1, rtree2, normalize=True) Out[34]: <pre>0.8571428571428571</pre> <p>mod: Tree modifications. Methods for manipulating and modifying tree data can be used to generate new trees, change the structure or data contained in a tree, and to store new data in trees. This is currently the largest subpackage with many common tree manipulation algorithms implemented.</p> In\u00a0[35]: Copied! <pre># return a tree with edges scaled so root is at height=100\nmodified = toytree.mod.edges_scale_to_root_height(tree, 100)\n\n# show the original and modified trees side by side\ntoytree.mtree([tree, modified]).draw(scale_bar=True);\n</pre> # return a tree with edges scaled so root is at height=100 modified = toytree.mod.edges_scale_to_root_height(tree, 100)  # show the original and modified trees side by side toytree.mtree([tree, modified]).draw(scale_bar=True); abcde43210abcde100500 In\u00a0[36]: Copied! <pre># return a tree with a new split (internal node and child) added\nmodified = toytree.mod.add_internal_node_and_child(tree, \"d\", name=\"x\")\n\n# show the original and modified trees side by side\ntoytree.mtree([tree, modified]).draw();\n</pre> # return a tree with a new split (internal node and child) added modified = toytree.mod.add_internal_node_and_child(tree, \"d\", name=\"x\")  # show the original and modified trees side by side toytree.mtree([tree, modified]).draw(); abcdeabcedx <p>annotate: add annotations to tree drawings. The <code>ToyTree.draw()</code> function accepts a large number of arguments that allow it to style tree drawings in variety of ways. However, it is difficult to make all options available within one function without causing confusion. Therefore, we have developed the <code>annotate</code> subpackage to house many additional methods for adding annotations to tree drawings after they are initially created. Some may prefer the use of this module to create tree drawing code that is more readable and atomized.</p> In\u00a0[37]: Copied! <pre># draw a tree and store returned objects\ncanvas, axes, mark = tree.draw()\n\n# annotate method to add node markers\ntoytree.annotate.add_tip_markers(tree, axes, color=\"salmon\", size=12);\n\n# annotate method to add to edge labels\ntoytree.annotate.add_edge_labels(tree, axes, labels=\"idx\", font_size=15, yshift=-12, mask=False);\n</pre> # draw a tree and store returned objects canvas, axes, mark = tree.draw()  # annotate method to add node markers toytree.annotate.add_tip_markers(tree, axes, color=\"salmon\", size=12);  # annotate method to add to edge labels toytree.annotate.add_edge_labels(tree, axes, labels=\"idx\", font_size=15, yshift=-12, mask=False); abcde0123456 <p>pcm: phylogenetic comparative methods. This module has a long way to go towards offering many of the numerous comparative methods that have been developed over decades for studying evolution on trees. Currently, a number of simulation and model fitting approaches are available for discrete and continuous traits. (This is a great place to contribute to toytree!)</p> In\u00a0[38]: Copied! <pre># get variance-covariance matrix from tree\ntoytree.pcm.get_vcv_matrix_from_tree(tree, df=True)\n</pre> # get variance-covariance matrix from tree toytree.pcm.get_vcv_matrix_from_tree(tree, df=True) Out[38]: a b c d e a 1.0 3.0 0.0 0.0 0.0 b 3.0 1.0 0.0 0.0 0.0 c 0.0 0.0 3.0 1.0 1.0 d 0.0 0.0 1.0 1.0 3.0 e 0.0 0.0 1.0 3.0 1.0 In\u00a0[39]: Copied! <pre># simulate a discrete trait under a Markov transition model\ntoytree.pcm.simulate_discrete_data(tree, nstates=3, model=\"ER\", nreplicates=5)\n</pre> # simulate a discrete trait under a Markov transition model toytree.pcm.simulate_discrete_data(tree, nstates=3, model=\"ER\", nreplicates=5) Out[39]: t0 t1 t2 t3 t4 0 1 0 2 1 1 1 2 2 1 0 1 2 2 1 1 0 0 3 2 2 2 1 2 4 1 0 0 0 2 5 0 0 1 1 1 6 2 0 0 2 2 7 0 2 2 2 2 8 2 2 1 1 0 In\u00a0[40]: Copied! <pre># make a copy of tree on which we will add a bunch of data\ndtree = tree.copy()\n\n# add a feature and set all Nodes to a default value\ndtree = dtree.set_node_data(\"trait1\", default=10)\n\n# or set some to specific values and others to a default\ndtree = dtree.set_node_data(\"trait2\", {i: 5 for i in range(dtree.ntips)}, default=1)\n\n# or add some to specific values and leave others as NaN\ndtree = dtree.set_node_data(\"trait3\", {0: \"X\", 1: \"Y\"})\n\n# or, add a feature by assigning as an attribute to one or more Nodes\ndtree[6].trait4 = \"special\"\n\n# show the data\ndtree.get_node_data()\n</pre> # make a copy of tree on which we will add a bunch of data dtree = tree.copy()  # add a feature and set all Nodes to a default value dtree = dtree.set_node_data(\"trait1\", default=10)  # or set some to specific values and others to a default dtree = dtree.set_node_data(\"trait2\", {i: 5 for i in range(dtree.ntips)}, default=1)  # or add some to specific values and leave others as NaN dtree = dtree.set_node_data(\"trait3\", {0: \"X\", 1: \"Y\"})  # or, add a feature by assigning as an attribute to one or more Nodes dtree[6].trait4 = \"special\"  # show the data dtree.get_node_data() Out[40]: idx name height dist support trait1 trait2 trait3 trait4 0 0 a 0.0 1.0 NaN 10 5 X NaN 1 1 b 0.0 1.0 NaN 10 5 Y NaN 2 2 c 0.0 3.0 NaN 10 5 NaN NaN 3 3 d 0.0 1.0 NaN 10 5 NaN NaN 4 4 e 0.0 1.0 NaN 10 5 NaN NaN 5 5 1.0 3.0 90.0 10 1 NaN NaN 6 6 1.0 2.0 100.0 10 1 NaN special 7 7 3.0 1.0 100.0 10 1 NaN NaN 8 8 4.0 0.0 NaN 10 1 NaN NaN In\u00a0[41]: Copied! <pre># the draw function returns three objects\ntree.draw()\n</pre> # the draw function returns three objects tree.draw() Out[41]: <pre>(&lt;toyplot.canvas.Canvas at 0x7fd8ef420940&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7fd8ef421600&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7fd8ef4209a0&gt;)</pre> abcde <p>As you may have noticed, I end many drawing commands with a semicolon which simply hides the return values when we don't intend to save them to variables. In a notebook the Canvas will automatically render in the cell below the plot even if you do not save it as a variable. If you save the notebook the rendered figure is saved to the output.</p> In\u00a0[42]: Copied! <pre># the semicolon hides the returned text of the Canvas and Cartesian objects\ntree.draw();\n</pre> # the semicolon hides the returned text of the Canvas and Cartesian objects tree.draw(); abcde <p>Finally, you can store the three returned objects, in which case you can add additional styling and/or save to a file. In this example I add additional styling to the Cartesian axes.</p> In\u00a0[43]: Copied! <pre># or, we can store them as variables\ncanvas, axes, mark = tree.draw(scale_bar=True)\n\n# and then optionally add additional styling\naxes.x.label.text = \"Time (Mya)\"\naxes.x.label.style[\"font-size\"] = 14\naxes.x.label.offset = 20\n</pre> # or, we can store them as variables canvas, axes, mark = tree.draw(scale_bar=True)  # and then optionally add additional styling axes.x.label.text = \"Time (Mya)\" axes.x.label.style[\"font-size\"] = 14 axes.x.label.offset = 20 abcde43210Time (Mya) In\u00a0[44]: Copied! <pre># drawing with pre-built tree_styles\ntree.draw(tree_style='c');  # coalescent-style\ntree.draw(tree_style='d');  # dark-style\n\n# 'ts' is also a shortcut for tree_style\ntree.draw(ts='o');          # umlaut-style\n</pre> # drawing with pre-built tree_styles tree.draw(tree_style='c');  # coalescent-style tree.draw(tree_style='d');  # dark-style  # 'ts' is also a shortcut for tree_style tree.draw(ts='o');          # umlaut-style abcde01234 abcde abcde In\u00a0[45]: Copied! <pre># define a style dictionary\nmystyle = {\n    \"layout\": 'd',\n    \"edge_type\": 'p',\n    \"edge_style\": {\n        \"stroke\": \"darkcyan\",\n        \"stroke-width\": 2.5,\n    },\n    \"tip_labels_colors\": \"black\",\n    \"tip_labels_style\": {\n        \"font-size\": \"16px\"\n    },\n    \"node_sizes\": 8,\n    \"node_colors\": \"dist\",\n    \"node_labels\": \"support\",\n    \"node_labels_style\": {\"baseline-shift\": 12, \"anchor-shift\": 15, \"font-size\": 12},\n    \"node_mask\": (0, 1, 0),\n}\n\n# use your custom style dictionary in one or more tree drawings\ntree.draw(height=300, **mystyle);\n</pre> # define a style dictionary mystyle = {     \"layout\": 'd',     \"edge_type\": 'p',     \"edge_style\": {         \"stroke\": \"darkcyan\",         \"stroke-width\": 2.5,     },     \"tip_labels_colors\": \"black\",     \"tip_labels_style\": {         \"font-size\": \"16px\"     },     \"node_sizes\": 8,     \"node_colors\": \"dist\",     \"node_labels\": \"support\",     \"node_labels_style\": {\"baseline-shift\": 12, \"anchor-shift\": 15, \"font-size\": 12},     \"node_mask\": (0, 1, 0), }  # use your custom style dictionary in one or more tree drawings tree.draw(height=300, **mystyle); 90100100abcde In\u00a0[46]: Copied! <pre># draw a plot and store the Canvas object to a variable\ncanvas, axes, mark = tree.draw(ts='p');\n</pre> # draw a plot and store the Canvas object to a variable canvas, axes, mark = tree.draw(ts='p'); 012345678abcde01234 <p>HTML rendering is the default format. This will save the figure as a vector graphic (SVG) wrapped in HTML with optional javascript wrapping that enables interactive features. You can share the file with others and anyone can open it in a browser. You can embed it on your website, or even display it in emails.</p> In\u00a0[47]: Copied! <pre># HTML allows for interactivity and embedding in web sites\ntoytree.save(canvas, \"/tmp/tree-plot.html\")\n</pre> # HTML allows for interactivity and embedding in web sites toytree.save(canvas, \"/tmp/tree-plot.html\") In\u00a0[48]: Copied! <pre># SVG for figures you will further edit in Illustrator/Inkscape\ntoytree.save(canvas, \"/tmp/tree-plot.svg\")\n</pre> # SVG for figures you will further edit in Illustrator/Inkscape toytree.save(canvas, \"/tmp/tree-plot.svg\") In\u00a0[49]: Copied! <pre># PDF for final shareable figures\ntoytree.save(canvas, \"/tmp/tree-plot.pdf\")\n</pre> # PDF for final shareable figures toytree.save(canvas, \"/tmp/tree-plot.pdf\") In\u00a0[50]: Copied! <pre># PNG for small and easy to share figures \ntoytree.save(canvas, \"/tmp/tree-plot.png\")\n</pre> # PNG for small and easy to share figures  toytree.save(canvas, \"/tmp/tree-plot.png\") <p>The toyplot library also has options for saving canvases. See the toyplot documentation. The <code>toytree.save()</code> function above is simply a convenient wrapper around these functions.</p> In\u00a0[51]: Copied! <pre>import toyplot\ntoyplot.html.render(canvas, \"/tmp/tree-plot.html\")\n</pre> import toyplot toyplot.html.render(canvas, \"/tmp/tree-plot.html\") In\u00a0[52]: Copied! <pre>import toyplot.svg\ntoyplot.svg.render(canvas, \"/tmp/tree-plot.svg\")\n</pre> import toyplot.svg toyplot.svg.render(canvas, \"/tmp/tree-plot.svg\") In\u00a0[53]: Copied! <pre>import toyplot.pdf\ntoyplot.pdf.render(canvas, \"/tmp/tree-plot.pdf\")\n</pre> import toyplot.pdf toyplot.pdf.render(canvas, \"/tmp/tree-plot.pdf\") In\u00a0[54]: Copied! <pre>import toyplot.png\ntoyplot.png.render(canvas, \"/tmp/tree-plot.png\")\n</pre> import toyplot.png toyplot.png.render(canvas, \"/tmp/tree-plot.png\")"},{"location":"quick_guide/#quick-guide","title":"Quick Guide\u00b6","text":"<p>This tutorial introduces several key concepts and applications of the <code>toytree</code> package to provide a general overview. Please follow links throughout this guide, and explore the broader documentation, to find more detailed instructions of each topic.</p>"},{"location":"quick_guide/#the-toytree-package","title":"The <code>toytree</code> package\u00b6","text":"<p><code>toytree</code> is a Python library for working with tree data. It provides a custom class for storing and representing tree data alongside an extensive library of methods for performing numerical and evolutionary analyses on trees. In addition, <code>toytree</code> provides interactive features that make it particularly well suited for use inside jupyter notebooks, such as interactive tree plotting methods and a well organized, modular, and documented code base.</p> <p>This tutorial was created as a jupyter notebook, and you can follow along in a notebook of your own by executing code from the top to the bottom of the document. To begin, let's import the <code>toytree</code> package.</p>"},{"location":"quick_guide/#a-simple-example","title":"A simple example\u00b6","text":"<p>The code block below contains three lines of code to parse a tree object from data, modify it, and generate a tree drawing, respectively. This simple operation demonstrates several key features of <code>toytree</code> functionality and design. The first line uses the method <code>toytree.tree</code> (see Tree Parsing (i/o)) to parse tree data (in this case from a public URL) into a <code>ToyTree</code> class object, and store it to the variable name tree.</p> <p>The next line of code calls a method of the <code>ToyTree</code> object to root the tree on a specified edge. The <code>ToyTree</code> class object is the main class for representing trees in <code>toytree</code> and has many methods associated with it. In this case, we enter \"~prz\" as an argument to <code>.root()</code>, which is interpreted as a regular expression to match any names on the tree containing \"prz\" (See Node/Name Query), as a convenient method to select an internal edge on which to root the tree.</p> <p>Finally, the last code line calls the <code>.draw()</code> method of the <code>ToyTree</code> to generate a tree drawing (See Tree Drawing). The drawing is automatically displayed in the notebook output cell, and can be optionally stored as a variable and further modified, or saved to disk in a variety of formats. We provide arguments to align the tip names and show markers at the nodes with interactive tooltip information (try it by hovering your cursor over the nodes).</p>"},{"location":"quick_guide/#parsing-tree-data","title":"Parsing tree data\u00b6","text":"<p><code>ToyTree</code> objects can be flexibly loaded from a range of input types using the <code>toytree.tree()</code> function. Tree data can be loaded from a string, file path, or public URL. The data can be formatted as Newick, NHX, or NEXUS format. Complex metadata can be parsed from extended Newick strings, and/or added to trees and saved to extended Newick formatted strings. Here we parse a newick string into a <code>ToyTree</code> object and call the <code>get_node_data()</code> function of the tree, which returns a summary table of the data in the tree. Viewing this table we can see how it has assigned the \"name\", \"dist\", and \"support\" values from the Newick data to the Nodes of the tree.</p>"},{"location":"quick_guide/#class-objects","title":"Class objects\u00b6","text":"<p>The main Class objects in <code>toytree</code> are structured as a nested hierarchy. At the lowest level are <code>toytree.Node</code> class objects. A collection of connected <code>Nodes</code> form the data for a <code>toytree.ToyTree</code> class object. This is the primary class in <code>toytree</code>. In addition, a collection of trees can form the data of a higher-level class object, called a <code>toytree.MultiTree</code>. Each object type contains attributes and methods that are designed for its specific place in the hierarchy. For example, nodes contain attributes and methods for extracting information about a specific <code>Node</code> and its connections (edges) to other nodes. A <code>ToyTree</code> contains attributes and methods for extracting information about an entire tree of connected nodes, including emergent properties of these collections, and methods for operating on them. Finally, a <code>MultiTree</code> contains attributes and methods for operating on collections of trees, such as consensus tree inference and methods for drawing multiple trees together.</p>"},{"location":"quick_guide/#learning-to-use-toytree","title":"Learning to use <code>toytree</code>\u00b6","text":"<p>When first learning <code>toytree</code> it is hugely beneficial to play around in an interactive environment such as a jupyter notebook or IDE that provides tab-completion/auto-complete features that make it possible to see all available methods and attributes of an object. In this way, you can easily explore the many possibilities associated with a <code>ToyTree</code> object without having to study the entire documentation. To try this feature in a notebook type the name of a <code>ToyTree</code> variable (e.g., tree below) followed by a dot and then press tab. A few of the many methods that will pop-up are shown below.</p>"},{"location":"quick_guide/#selecting-nodes","title":"Selecting nodes\u00b6","text":"<p>Many methods in <code>toytree</code> require selecting one or more nodes from a tree to operate on. This can often be challenging since most nodes in a tree usually do not have unique names assigned to them, and selecting nodes by a numeric indexing method can be error-prone if the indices change. We have tried to design the node query and selection methods in toytree to be maximally flexible to allow for ease-of-use when selecting nodes while also trying to prevent users from making simple and common mistakes.</p> <p>The <code>get_nodes</code> and <code>get_mrca_node</code> methods of <code>ToyTree</code> objects provide a flexible approach to selecting one or more nodes either by name or by their unique integer indices. See the Node Query/Selection documentation section for details.</p>"},{"location":"quick_guide/#subpackages","title":"Subpackages\u00b6","text":"<p>There are many possible operations, algorithms, statistics, and metrics that can be implemented or computed on tree data, and if we simply added every method as an additional function of a <code>ToyTree</code> object it would become crowded and difficult to find its more common attributes and functions. Therefore, we have instead organized many of these additional methods into subpackages where functions with similar themes are organized together. For example, the <code>rtree</code> subpackage is used to generate random trees under a variety of algorithms, and the <code>mod</code> subpackage is used to group together many functions for modifying tree data. The methods in each of these subpackages is explained in much greater detail in their specific section of the documentation. Here we provide just a brief introduction to each.</p>"},{"location":"quick_guide/#storing-data-to-trees","title":"Storing data to trees\u00b6","text":"<p>Any arbitrary data can be stored to trees by assigning it to the <code>Node</code> objects in the tree. This can be done in the most simple way by iterating over nodes in a tree and assigning values to nodes, or, it can be done by using a tree's <code>.set_node_data()</code> function, which has options for making it easy to assign values to some nodes but not others. The <code>get_node_data()</code> function is especially useful here in that it collects data from all Nodes and can provide NaN, or a custom value, for nodes that either have no value for a feature, or lack the feature all together, depending on how it was assigned. Several examples for setting data to nodes are shown:</p>"},{"location":"quick_guide/#tree-drawings","title":"Tree drawings\u00b6","text":"<p>When you call <code>.draw()</code> on a tree it returns three objects, a Canvas, Cartesian, and Mark. This follows the design principle of the toyplot plotting library that <code>toytree</code> uses as its default plotting backend. The Canvas describes the dimensions of the plot space, the Cartesian coordinates define how to project points onto that space, and a Mark represents plotted data. One Canvas can have multiple Cartesian coordinates, and each Cartesian object can have multiple Marks. After a plot is generated, each of these objects can be interacted with to set additional styling to axes, ticks, font sizes, etc. The three returned objects can be seen in the output field of the cell below.</p>"},{"location":"quick_guide/#styling-tree-drawings","title":"Styling tree drawings\u00b6","text":"<p>There are innumerous ways in which to style tree drawings. In addition to individual options that change a style component one-by-one, we also provide a number of built-in \"tree-style\" arguments, which change the default style on top of which additional changes can be made. Users can also create their own tree-style dictionaries easily. You can view the <code>draw</code> function docstring for more details on available arguments, or you can see which styles are available by accessing the <code>.style</code> dict-like object of a <code>ToyTree</code>. See the <code>Styling</code> documentation for more details.</p>"},{"location":"quick_guide/#saving-tree-drawings","title":"Saving tree drawings\u00b6","text":"<p>Tree drawings can be saved to disk in a variety of formats, including HTML, SVG, PDF, or PNG. The simplest way to save a canvas drawing is using the <code>toytree.save()</code> function, where the file format will be inferred from the filename suffix. As demonstrated below, you can also save a canvas using options from the <code>toyplot</code> library.</p>"},{"location":"range-mapping/","title":"feature range-mapping","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np <p>Take Home</p> <p>       Range mapping allows you to easily project data values into an appropriate range of pixel sizes to enter as arguments to drawing functions. This is done by entering the data feature to be range-mapped as a tuple in the format: (feature, min_value, max_value, nan_value).   </p> In\u00a0[2]: Copied! <pre># example: map node sizes to node idx values in range (12-25) px\ntree = toytree.rtree.bdtree(10, seed=123)\ntree.draw(ts='s', node_sizes=(\"idx\", 12, 25));\n</pre> # example: map node sizes to node idx values in range (12-25) px tree = toytree.rtree.bdtree(10, seed=123) tree.draw(ts='s', node_sizes=(\"idx\", 12, 25)); 0123456789101112131415161718r0r1r2r3r4r5r6r7r8r9 In\u00a0[3]: Copied! <pre>tree = toytree.rtree.bdtree(10, seed=123)\nrng = np.random.default_rng(seed=123)\ntree.set_node_data(\"X\", rng.uniform(0, 1, tree.nnodes), inplace=True);\ntree.set_node_data(\"Y\", rng.uniform(1e2, 1e3, tree.nnodes), inplace=True);\ntree.set_node_data(\"Z\", {i: i.X for i in tree[12:]}, inplace=True);\n</pre> tree = toytree.rtree.bdtree(10, seed=123) rng = np.random.default_rng(seed=123) tree.set_node_data(\"X\", rng.uniform(0, 1, tree.nnodes), inplace=True); tree.set_node_data(\"Y\", rng.uniform(1e2, 1e3, tree.nnodes), inplace=True); tree.set_node_data(\"Z\", {i: i.X for i in tree[12:]}, inplace=True); In\u00a0[4]: Copied! <pre>tree.get_node_data([\"X\", \"Y\", \"Z\"])\n</pre> tree.get_node_data([\"X\", \"Y\", \"Z\"]) Out[4]: X Y Z 0 0.682352 566.348533 NaN 1 0.053821 308.400062 NaN 2 0.220360 249.313594 NaN 3 0.184372 548.010072 NaN 4 0.175906 624.452177 NaN 5 0.812095 265.904189 NaN 6 0.923345 113.405425 NaN 7 0.276574 524.019906 NaN 8 0.819755 755.418995 NaN 9 0.889893 926.740443 NaN 10 0.512970 662.980605 NaN 11 0.244965 925.410315 NaN 12 0.824242 878.221226 0.824242 13 0.213763 296.328586 0.213763 14 0.741467 879.514688 0.741467 15 0.629940 757.676743 0.629940 16 0.927407 350.078761 0.927407 17 0.231908 817.339198 0.231908 18 0.799125 878.699542 0.799125 In\u00a0[5]: Copied! <pre># raw \"X\" data values are too small to use for node_sizes\ntree.draw(node_sizes=\"X\");\n</pre> # raw \"X\" data values are too small to use for node_sizes tree.draw(node_sizes=\"X\"); r0r1r2r3r4r5r6r7r8r9 In\u00a0[6]: Copied! <pre># raw \"Y\" data values are too large to use for node_sizes\ntree.draw(node_sizes=\"Y\", height=350, width=350);\n</pre> # raw \"Y\" data values are too large to use for node_sizes tree.draw(node_sizes=\"Y\", height=350, width=350); r0r1r2r3r4r5r6r7r8r9 In\u00a0[7]: Copied! <pre># project \"X\" values to pixel range using auto args for min,max,nan\ntree.draw(node_sizes=(\"X\",));\n</pre> # project \"X\" values to pixel range using auto args for min,max,nan tree.draw(node_sizes=(\"X\",)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[8]: Copied! <pre># project very small \"X\" values to pixel range 5-15\ntree.draw(node_sizes=(\"X\", 5, 15));\n</pre> # project very small \"X\" values to pixel range 5-15 tree.draw(node_sizes=(\"X\", 5, 15)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[9]: Copied! <pre># project very large \"Y\" values to pixel range 5-15\ntree.draw(node_sizes=(\"Y\", 5, 15));\n</pre> # project very large \"Y\" values to pixel range 5-15 tree.draw(node_sizes=(\"Y\", 5, 15)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[10]: Copied! <pre># project very small \"Z\" values to pixel range 5-15, with NaN values set to 0\ntree.draw(node_sizes=(\"Z\", 5, 15, 0));\n</pre> # project very small \"Z\" values to pixel range 5-15, with NaN values set to 0 tree.draw(node_sizes=(\"Z\", 5, 15, 0)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[11]: Copied! <pre>tree.draw(node_sizes=(\"Z\", 5, 15, 10));\n</pre> tree.draw(node_sizes=(\"Z\", 5, 15, 10)); r0r1r2r3r4r5r6r7r8r9 In\u00a0[12]: Copied! <pre>toytree.style.get_range_mapped_feature(tree, \"X\", min_value=2, max_value=15, nan_value=0)\n</pre> toytree.style.get_range_mapped_feature(tree, \"X\", min_value=2, max_value=15, nan_value=0) Out[12]: <pre>array([11.35328489,  2.        ,  4.47829579,  3.94275072,  3.81676794,\n       13.2840094 , 14.93954874,  5.31483464, 13.39800011, 14.44173875,\n        8.83268852,  4.84444335, 13.46477251,  4.38012595, 12.23298906,\n       10.57333721, 15.        ,  4.65014844, 13.09100966])</pre>"},{"location":"range-mapping/#range-mapping","title":"Range-mapping\u00b6","text":"<p>Range mapping is a convenient method and syntax that allows for transforming/projecting raw data values, which may be composed of very small or very large values, into a range of values that is more appropriate for visualization, such as pixel size units. This is especially useful when wanting to visualize a range of data values on a tree as a distribution of node sizes or edge widths. (See Color-Mapping for a similar implementation to project discrete or continuous data values to a color map.)</p>"},{"location":"range-mapping/#example-data","title":"Example Data\u00b6","text":"<p>To demonstrate range-mapping we will use a 10 tip birth-death tree with three data features assigned to Nodes of the tree. The first feature \"X\" contains small float values randomly drawn from the interval (0-1). The second feature contains large float values randly drawn from the interval (100-1000). And the third feature contains the same data as feature \"X\", but with missing values for many nodes.</p>"},{"location":"range-mapping/#visualizing-raw-data","title":"Visualizing Raw Data\u00b6","text":"<p>As we can see in the examples below, the features \"X\", \"Y\" and \"Z\" do not serve well as arguments to the draw function to designate size of node markers. Either the markers are too small to see or too large such that they obscure the entire plot. One solution to this problem would be to call <code>get_node_data</code> on the feature to extract the data and then either multiply or divide the values by a constant to transform them into a more reasonable pixel size range. While this can be done, range-mapping provides a more convenient solution, explained below.</p>"},{"location":"range-mapping/#using-range-mapping","title":"Using Range Mapping\u00b6","text":"<p>Range mapping allows you to project a set of values into a new range while still preserving the relative differences among values. For example, the data in feature \"X\" ranges from about 0.05 to 0.95, all of which is too small for visualization. Using range mapping we can project these values so that the smallest values is 5, the largest value is 15, and all intermediate values are projected to the appropriate relative position between these min and max values.</p>"},{"location":"range-mapping/#tuple-syntax","title":"Tuple syntax\u00b6","text":"<p>Range mapping is designated by using the tuple syntax <code>(feature name, min_value, max_value, nan_value)</code>. The feature name is the only required argument, if the others are left empty then default values are assigned for the min, max, and nan values of (5, 20, 0).</p>"},{"location":"range-mapping/#missing-data-values","title":"Missing Data Values\u00b6","text":"<p>When one or more Nodes do not contain a feature they are assigned a value of <code>np.nan</code> by default. When range-mapping is performed it can be instructed how to treat these values. The default treatment is to convert these values to 0, but, you can alternatively set any value you want.</p>"},{"location":"range-mapping/#discrete-data-values","title":"Discrete Data Values\u00b6","text":"<p>Note that range-mapping can only be applied to continuous data, not discrete/categorical data. A more appropriate way to treat discrete data may be to use Color-Mapping instead.</p>"},{"location":"range-mapping/#get-range-mapped-data","title":"Get Range Mapped Data\u00b6","text":"<p>When you use the tuple format to instruct <code>toytree</code> to perform range mapping on a data feature it performs a simple operation under the hood to project the data into its new value range. This function is available to users in <code>toytree.style.get_range_mapped_feature</code> in case users wish to use it externally.</p>"},{"location":"rooting/","title":"rooting trees","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># an example tree with outgroup (r3,r4)\ntree = toytree.rtree.unittree(ntips=5, seed=123)\n\n# create an unrooted tree \nutree = tree.unroot()\n\n# root the tree on its original outgroup\nrtree = utree.root(\"r3\", \"r4\")\n\n# re-root the tree on an alternative outgroup\natree = rtree.root(\"r2\")\n</pre> # an example tree with outgroup (r3,r4) tree = toytree.rtree.unittree(ntips=5, seed=123)  # create an unrooted tree  utree = tree.unroot()  # root the tree on its original outgroup rtree = utree.root(\"r3\", \"r4\")  # re-root the tree on an alternative outgroup atree = rtree.root(\"r2\") <p>Take Home</p> <p>       A tree can be manually rooted on an outgroup using tree.root(...), or using one of several       algorithms to estimate the root placement. A tree can be unrooted using tree.unroot().   </p> In\u00a0[3]: Copied! <pre># the .treenode is the top-level node\ntree.treenode\n</pre> # the .treenode is the top-level node tree.treenode Out[3]: <pre>&lt;Node(idx=8)&gt;</pre> In\u00a0[4]: Copied! <pre># it is also accessible as the last indexed node\ntree[-1]\n</pre> # it is also accessible as the last indexed node tree[-1] Out[4]: <pre>&lt;Node(idx=8)&gt;</pre> In\u00a0[5]: Copied! <pre># draw the trees rooted\nc, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='d');\na[0].label.text = \"rooted tree\"\na[1].label.text = \"unrooted tree\"\na[2].label.text = \"alt rooted tree\"\n</pre> # draw the trees rooted c, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='d'); a[0].label.text = \"rooted tree\" a[1].label.text = \"unrooted tree\" a[2].label.text = \"alt rooted tree\" 012345678r0r1r2r3r4rooted tree01234567r0r1r2r3r4unrooted tree012345678r2r0r1r3r4alt rooted tree <p>The drawings below show the same trees but using the unrooted/undirected ('un') layout. This places the treenode near the center and projects edges away from it in a way that minimizes overlaps. You can more clearly see by comparing the three trees in this layout that the structure (topology) of the tree does not change during rooting. The only difference between the middle and two outer drawings is the addition of an extra node (node 8) that is inserted either between nodes 6 and 7 on the left tree, or between nodes 0 and 7 on the right tree (note: node idx labels change between trees with different rootings). An undirected  layout would typically be used to visualize an unrooted tree (middle) but is not the most informative for rooted trees, since it is harder to interpret the distances of nodes from the root.</p> In\u00a0[6]: Copied! <pre># draw the trees unrooted\nc, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='un');\na[0].label.text = \"rooted tree\"\na[1].label.text = \"unrooted tree\"\na[2].label.text = \"alt rooted tree\"\n</pre> # draw the trees unrooted c, a, m = toytree.mtree([tree, utree, atree]).draw(ts='p', layout='un'); a[0].label.text = \"rooted tree\" a[1].label.text = \"unrooted tree\" a[2].label.text = \"alt rooted tree\" 012345678r0r1r2r3r4rooted tree01234567r0r1r2r3r4unrooted tree012345678r2r0r1r3r4alt rooted tree <p>Tip</p> <p>       A key point is to recognize the difference between whether a tree is rooted or not, and whether a tree is drawn using an unrooted/undirected layout or not. These are two distinct things.   </p> In\u00a0[7]: Copied! <pre># root the tree using clade (r3,r4) as outgroup\nnew_tree = utree.root(\"r3\", \"r4\")\n\n# show the unrooted and newly rooted trees\ntoytree.mtree([utree, new_tree]).draw(ts='p');\n</pre> # root the tree using clade (r3,r4) as outgroup new_tree = utree.root(\"r3\", \"r4\")  # show the unrooted and newly rooted trees toytree.mtree([utree, new_tree]).draw(ts='p'); 01234567r0r1r2r3r4012345678r3r4r0r1r2 In\u00a0[8]: Copied! <pre># root the tree on the global midpoint and draw it\nutree.mod.root_on_midpoint().draw(ts='p');\n</pre> # root the tree on the global midpoint and draw it utree.mod.root_on_midpoint().draw(ts='p'); 012345678r3r4r0r1r200.51 In\u00a0[9]: Copied! <pre># get a rooted tree with MAD scores stored as features\ntree.mod.root_on_minimal_ancestor_deviation().draw(ts='p');\n</pre> # get a rooted tree with MAD scores stored as features tree.mod.root_on_minimal_ancestor_deviation().draw(ts='p'); 012345678r3r4r0r1r200.51 In\u00a0[10]: Copied! <pre># manual set rooting position 0.1 height units above clade (r3,r4)\nutree.root(\"r3\", \"r4\", root_dist=0.1).draw(ts='p');\n</pre> # manual set rooting position 0.1 height units above clade (r3,r4) utree.root(\"r3\", \"r4\", root_dist=0.1).draw(ts='p'); 012345678r3r4r0r1r200.40.81.2 In\u00a0[11]: Copied! <pre># manual set rooting position 0.6 height units above clade (r3,r4)\nutree.root(\"r3\", \"r4\", root_dist=0.6).draw(ts='p');\n</pre> # manual set rooting position 0.6 height units above clade (r3,r4) utree.root(\"r3\", \"r4\", root_dist=0.6).draw(ts='p'); 012345678r3r4r0r1r200.40.81.2 In\u00a0[12]: Copied! <pre>tree, stats = tree.mod.root_on_minimal_ancestor_deviation(return_stats=True)\nstats\n</pre> tree, stats = tree.mod.root_on_minimal_ancestor_deviation(return_stats=True) stats Out[12]: <pre>{'minimal_ancestor_deviation': 0.0,\n 'root_ambiguity_index': 0.0,\n 'root_clock_coefficient_of_variation': 1.922962686383564e-14}</pre> <p>Whereas in this example non-ultrametric tree the MAD, ambiguity, and clock variation are all very high.</p> In\u00a0[13]: Copied! <pre># create a non-ultrametric tree and draw it\nnon_ultrametric_tree = toytree.rtree.rtree(10)\nnon_ultrametric_tree.draw(layout='d');\n\n# calculate and return the global MAD stats\n_, stats = non_ultrametric_tree.mod.root_on_minimal_ancestor_deviation(return_stats=True)\nstats\n</pre> # create a non-ultrametric tree and draw it non_ultrametric_tree = toytree.rtree.rtree(10) non_ultrametric_tree.draw(layout='d');  # calculate and return the global MAD stats _, stats = non_ultrametric_tree.mod.root_on_minimal_ancestor_deviation(return_stats=True) stats Out[13]: <pre>{'minimal_ancestor_deviation': 0.19333523444378065,\n 'root_ambiguity_index': 0.9783776829860145,\n 'root_clock_coefficient_of_variation': 21.521660778220504}</pre> r0r1r2r3r4r5r6r7r8r9 In\u00a0[14]: Copied! <pre># get a rooted tree with MAD scores stored as features\nmad_tree = tree.mod.root_on_minimal_ancestor_deviation()\nmad_tree.get_node_data()\n</pre> # get a rooted tree with MAD scores stored as features mad_tree = tree.mod.root_on_minimal_ancestor_deviation() mad_tree.get_node_data() Out[14]: idx name height dist support MAD MAD_root_prob 0 0 r0 0.000000e+00 0.333333 NaN 0.500000 0.10066 1 1 r1 0.000000e+00 0.333333 NaN 0.500000 0.10066 2 2 r2 0.000000e+00 0.666667 NaN 0.258199 0.14934 3 3 r3 2.220446e-16 0.666667 NaN 0.258199 0.14934 4 4 r4 2.220446e-16 0.666667 NaN 0.258199 0.14934 5 5 3.333333e-01 0.333333 NaN 0.258199 0.14934 6 6 6.666667e-01 0.333333 NaN 0.000000 0.20132 7 7 6.666667e-01 0.333333 NaN 0.000000 0.20132 8 8 root 1.000000e+00 0.000000 NaN NaN NaN <p>Finally, we could plot the MAD or MAD_root_prob scores on the edges of a tree easily, since they are stored as features to the returned rooted tree.</p> In\u00a0[15]: Copied! <pre># plot and show the MAD rooting probability for other edges\nc, a, m = mad_tree.draw('p', width=450);\nmad_tree.annotate.add_edge_markers(a, \"r3x1\", size=14, color=\"lightgrey\", mask=False, xshift=0)\nmad_tree.annotate.add_edge_labels(a, \"MAD_root_prob\", mask=False, font_size=11);\n</pre> # plot and show the MAD rooting probability for other edges c, a, m = mad_tree.draw('p', width=450); mad_tree.annotate.add_edge_markers(a, \"r3x1\", size=14, color=\"lightgrey\", mask=False, xshift=0) mad_tree.annotate.add_edge_labels(a, \"MAD_root_prob\", mask=False, font_size=11); 012345678r0r1r2r3r40.10070.10070.14930.14930.14930.14930.201300.51 In\u00a0[16]: Copied! <pre># returns True if root node has &gt;2 children\ntree.is_rooted()\n</pre> # returns True if root node has &gt;2 children tree.is_rooted() Out[16]: <pre>True</pre> In\u00a0[17]: Copied! <pre># get an unrooted copy of the tree\ntree.unroot()\n</pre> # get an unrooted copy of the tree tree.unroot() Out[17]: <pre>&lt;toytree.ToyTree at 0x7f21c8bab580&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>ctre = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\")\nctre.draw(ts='r', node_labels=\"support\");\nctre.draw(\n    layout='unr', \n    node_labels=\"support\", node_as_edge_data=True, node_sizes=16, \n    node_markers=\"r2x1\", node_colors=\"lightgrey\",\n);\n</pre> ctre = toytree.tree(\"https://eaton-lab.org/data/Cyathophora.tre\") ctre.draw(ts='r', node_labels=\"support\"); ctre.draw(     layout='unr',      node_labels=\"support\", node_as_edge_data=True, node_sizes=16,      node_markers=\"r2x1\", node_colors=\"lightgrey\", ); In\u00a0[56]: Copied! <pre>toytree.tree(\"((a[2],b[1])[3],c[100])[4];\", feature_prefix=None,).draw('r', node_mask=False, node_labels=\"label\");\n</pre> toytree.tree(\"((a[2],b[1])[3],c[100])[4];\", feature_prefix=None,).draw('r', node_mask=False, node_labels=\"label\"); 2110034abc In\u00a0[64]: Copied! <pre>toytree.tree(\"/home/deren/R/x86_64-pc-linux-gnu-library/4.2/phangorn/extdata/trees/RAxML_bipartitionsBranchLabels.AIs\", feature_prefix=None, \n            ).draw('r', node_labels=\"label\", node_hover=True);\n</pre> toytree.tree(\"/home/deren/R/x86_64-pc-linux-gnu-library/4.2/phangorn/extdata/trees/RAxML_bipartitionsBranchLabels.AIs\", feature_prefix=None,              ).draw('r', node_labels=\"label\", node_hover=True); idx: 8 dist: 0.000870360696582 support: nan height: 0.0208901930586 label: 39 name: 39idx: 9 dist: 0.00122506270256 support: nan height: 0.0217605537551 label: 42 name: 42idx: 10 dist: 0.00167792487939 support: nan height: 0.0202351982994 label: 83 name: 83idx: 11 dist: 0.00107249327886 support: nan height: 0.0219131231788 label: 41 name: 41idx: 12 dist: 0.00382497683825 support: nan height: 0.0229856164577 label: 100 name: 100idx: 13 dist: 0 support: nan height: 0.026810593296 label: nan name: nanAmeHmaUthMurUarUmaUamTor In\u00a0[67]: Copied! <pre>toytree.tree(\"/home/deren/R/x86_64-pc-linux-gnu-library/4.2/phangorn/extdata/trees/RAxML_bipartitions.3moles\").draw('s', node_labels=\"support\");\n</pre> toytree.tree(\"/home/deren/R/x86_64-pc-linux-gnu-library/4.2/phangorn/extdata/trees/RAxML_bipartitions.3moles\").draw('s', node_labels=\"support\"); nannannannannannannannan363010060100nanAmeHmaMurUthUamUarUmaTor In\u00a0[\u00a0]: Copied! <pre>support_tree = tree.set_node_data(\"support\", default=100)\nsupport_tree.get_node_data()\n</pre> support_tree = tree.set_node_data(\"support\", default=100) support_tree.get_node_data() In\u00a0[\u00a0]: Copied! <pre># the proper \ntree.set_node_data(\"support\", default=100).draw(node_labels=\"support\", node_sizes=20, node_as_edge_data=True);\n</pre> # the proper  tree.set_node_data(\"support\", default=100).draw(node_labels=\"support\", node_sizes=20, node_as_edge_data=True); In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre># \"\"\": Example dataset with inner labels as edge data.\"\"\"\n# self.supp = toytree.tree(\"(a,b,((c,d)CD[&amp;support=100],(e,f)EF[&amp;support=80])X[&amp;support=90])AB;\")\n# \"\"\": Tree w/ internal names and supports\"\"\"\n# self.itree = toytree.rtree.imbtree(10, seed=123, treeheight=10)\n# self.btree = toytree.rtree.baltree(10, seed=123, treeheight=10)\n# self.utree = toytree.rtree.unittree(10, seed=123, treeheight=10)\n# self.trees = [self.itree, self.btree, self.utree]\n</pre> # \"\"\": Example dataset with inner labels as edge data.\"\"\" # self.supp = toytree.tree(\"(a,b,((c,d)CD[&amp;support=100],(e,f)EF[&amp;support=80])X[&amp;support=90])AB;\") # \"\"\": Tree w/ internal names and supports\"\"\" # self.itree = toytree.rtree.imbtree(10, seed=123, treeheight=10) # self.btree = toytree.rtree.baltree(10, seed=123, treeheight=10) # self.utree = toytree.rtree.unittree(10, seed=123, treeheight=10) # self.trees = [self.itree, self.btree, self.utree] In\u00a0[\u00a0]: Copied! <pre>tree.unroot().root('r2').unroot().root('r3', 'r4').draw('p');\n</pre> tree.unroot().root('r2').unroot().root('r3', 'r4').draw('p'); In\u00a0[\u00a0]: Copied! <pre># unrooted tree from Czech et al... \nczech = \"((C,D)1,(A,(B,X)3)2,E)R;\"\nctree = toytree.tree(czech, internal_labels=\"name\")\n\n# set data to label nodes and edges of the unrooted tree\ncolors = {'1': 'red', '2': 'green', '3': 'orange'}\nctree.set_node_data(\"ecolor\", colors, default=\"black\", inplace=True)\nctree.set_node_data(\"ncolor\", colors, inplace=True);\n\n# create a style dict\nkwargs = {\n    'layout': 'd',\n    'use_edge_lengths': False,\n    'node_sizes': 10,\n    'node_labels': 'name',\n    'node_labels_style': {\n        'font-size': 20,\n        'baseline-shift': 10,\n        '-toyplot-anchor-shift': 10,\n    }}\n</pre> # unrooted tree from Czech et al...  czech = \"((C,D)1,(A,(B,X)3)2,E)R;\" ctree = toytree.tree(czech, internal_labels=\"name\")  # set data to label nodes and edges of the unrooted tree colors = {'1': 'red', '2': 'green', '3': 'orange'} ctree.set_node_data(\"ecolor\", colors, default=\"black\", inplace=True) ctree.set_node_data(\"ncolor\", colors, inplace=True);  # create a style dict kwargs = {     'layout': 'd',     'use_edge_lengths': False,     'node_sizes': 10,     'node_labels': 'name',     'node_labels_style': {         'font-size': 20,         'baseline-shift': 10,         '-toyplot-anchor-shift': 10,     }} In\u00a0[\u00a0]: Copied! <pre># draw original unrooted tree\nctree.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs);\n</pre> # draw original unrooted tree ctree.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs); <p>When we root the tree on the edge above \"X\" this changes the orientation of several nodes on the tree, such that some which were parents of another before now appear as children of that node. This has the important consequence for how the edge between these nodes is interpreted...</p> <p>For example, the yellow edge which previously represented information about the split separating (B,X) from every other node now instead represents the split between X and every other node. Similarly, the green edge which previously represented the split between (A,B,X) versus (C,D,E) now represents (B,X) versus (A,C,D,E). This is incorrect.</p> <p>...</p> In\u00a0[\u00a0]: Copied! <pre># root w/o indicating edge_features, error!\nrtree = ctree.root(\"X\")\nrtree.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs);\n</pre> # root w/o indicating edge_features, error! rtree = ctree.root(\"X\") rtree.draw(node_colors=\"ncolor\", edge_colors=\"ecolor\", **kwargs); In\u00a0[\u00a0]: Copied! <pre># re-root, treating 'ecolor' but not 'ncolor' as an edge feature.\nrtree = ctree.root(\"X\", edge_features=[])\nrtree.draw(\n    node_colors=rtree.get_node_data('ncolor', missing='black'),\n    edge_colors=rtree.get_node_data('ecolor', missing='black'),\n    **kwargs,\n);\n</pre> # re-root, treating 'ecolor' but not 'ncolor' as an edge feature. rtree = ctree.root(\"X\", edge_features=[]) rtree.draw(     node_colors=rtree.get_node_data('ncolor', missing='black'),     edge_colors=rtree.get_node_data('ecolor', missing='black'),     **kwargs, ); In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"rooting/#rooting-trees","title":"Rooting trees\u00b6","text":"<p>Rooting or re-rooting trees orients the direction of ancestor-descendant relationships and thus provides \"polarization\" for the direction of evolution. Most tree inference algorithms return an unrooted tree as a result, and it is up to the researcher to select the placement of the root based on external information (e.g., outgroup designation) or analytical methods (e.g., based on edge lengths).</p> <p>This tutorial section provides background on how rooting or re-rooting affects a tree data structure and how to choose the edge and position on which to root a tree. It also clarifies several common misconceptions and sources of error during tree rooting.</p>"},{"location":"rooting/#the-treenode","title":"The treenode\u00b6","text":"<p>All ToyTree objects contain a node that is designated the treenode, and which represents the top level <code>Node</code> object in the collection of nodes that make up the tree hierarchy. This node exists in a tree whether it is rooted or unrooted. We use the term treenode rather than root node to refer to this top level node, since it is not always a true root node, as in the case of an unrooted tree. This can be a confusing point, but understanding it will help to make clear what the process of tree rooting actually represents. It is a little more complex than simply moving or relabeling a node, as described for the three operations below.</p>"},{"location":"rooting/#rooting","title":"Rooting\u00b6","text":"<p>When rooting an unrooted tree, a new node is inserted on an edge, splitting it into two (it helps me to think of it visually as pinching the edge and pulling it back to insert the node). The new node serves as the treenode. The number of nodes in the tree increases by 1.</p>"},{"location":"rooting/#unrooting","title":"Unrooting\u00b6","text":"<p>When unrooting a rooted tree, the current treenode is removed, and an existing node in the tree (the previous treenode's left child) is designated as the treenode. The number of nodes in the tree decreases by 1.</p>"},{"location":"rooting/#re-rooting","title":"Re-rooting\u00b6","text":"<p>When re-rooting a rooted tree, the current treenode is removed and a new node is inserted on a different edge of the tree. The new node serves as the treenode. The number of nodes in the tree does not change.</p>"},{"location":"rooting/#rooting-visualized","title":"Rooting visualized\u00b6","text":"<p>You cannot verify that a tree is unrooted based simply on a visualization, since an unrooted tree can look the same as a rooted tree that contains a polytomy at its root. Thus, it is best practice to mention in a figure legend whether and how a tree is rooted. Another way of hinting that a tree is rooted versus unrooted is by using different tree layouts for visualization. This is demonstrated below.</p> <p>This first set of drawing uses the default linear down ('d') layout. This places the treenode at the top of the drawing, which makes it easy to interpret how far each other node is from the treenode. This style makes sense for interpreting rooted trees (left and right), but is misleading for the unrooted tree (middle), since it gives the impression visually that the tree is rooted at node 7.</p>"},{"location":"rooting/#rooting-methods","title":"Rooting methods\u00b6","text":"<p><code>toytree</code> currently supports three methods for rooting a tree: (1) manually; (2) by the midpoint (Farris 1972); and (3) by the minimal ancestor deviation (Tria et al. 2017). The first requires the user to designate the outgroup and optionally specify the length along the edge at which to insert the new root node. The second method automatically places the root node on an edge that is average distance from all terminal nodes. The last method calculates a set of statistics that can be used to either automatically place the root node, or to provide a score for an alternative manual placement.</p> <p>The most common methods, <code>.root()</code> and <code>.unroot</code>, are available from a <code>ToyTree</code> object. These are also available in the <code>toytree.mod</code> subpackage, where the other optional rooting functions are also located. Each is demonstrated with further explanation below.</p>"},{"location":"rooting/#manually-set-the-outgroup","title":"Manually set the outgroup\u00b6","text":"<p>The <code>.root()</code> function requires manually designating an outgroup. Specifically, you are designating the node for which the edge above it will be bisected by the new treenode. The clade composed of the selected node and its descendants is designated the outgroup, and the clade of everything else on the other side of the root is the ingroup.</p>"},{"location":"rooting/#midpoint-deviation","title":"Midpoint deviation\u00b6","text":"<p>Rooting on the \"midpoint\" assumes a clock-like evolutionary rate (i.e., branch lengths are equal to time) and may yield odd results when this assumption is violated. This algorithm calculates the pairwise path length between all tips in an unrooted tree, and places the treenode on an edge representing the midpoint of the longest path.</p>"},{"location":"rooting/#minimal-ancestor-deviation","title":"Minimal-ancestor-deviation\u00b6","text":"<p>The minimal ancestor deviation (MAD) rooting method is intended to accommodate rate heterogeneity among edges of a tree when inferring the root state of an unrooted tree. It assumes that branch lengths are additive and that the true tree is ultrametric (i.e., tip height variation results from rate heterogeneity). This method finds the point on every edge that minimizes the deviations from all pairwise midpoint rooting positions. The optimal rooting position is on the edge with the lowest MAD score, but the user can also manually select a suboptimal edge and assess its relative score compared to alternative root placements (See Inferring the root below.)</p>"},{"location":"rooting/#root-dist","title":"Root dist\u00b6","text":"<p>When rooting a tree it is important not only to select the correct edge on which to place the treenode, but also the correct position on that edge. For example, the edge could be split at its midpoint, or closer to one child node than the other. The true rooting position is not known, and so this is a place where a model-based inference can be useful. One common assumption is that the tree should be as close to ultrametric as possible, and thus a position should be selected on the edge that best aligns the tip nodes. This is approach taken by the midpoint and minimal-ancestor-deviation methods. In addition, the user can set a position manually using the manual rooting method. If the <code>root_dist</code> arg is left at its default=None setting in the root function then the edge midpoint is used.</p>"},{"location":"rooting/#inferring-the-root","title":"Inferring the root\u00b6","text":"<p>It is always best practice to include an outgroup in phylogenetic analyses, but in some cases the outgroup may be unknown or unavailable. In such cases it can be useful to apply methods for inferring the most likely root state based on edge length information. The best method for this currently implemented in <code>toytree</code> is using the minimal ancestor deviation score.</p> <p>The <code>root_on_minimal_ancestor_deviation</code> function in <code>toytree</code> calculates the MAD score and the root probabilities for each edge in the tree. By default these scores are stored as edge features on the returned tree. In addition, global score info can be returned by using <code>return_stats=True</code> argument. This includes the <code>minimal_ancestor_deviation</code> score for the rooting edge (lower is better); the <code>root_ambiguity_index</code> (whether another edge is as good as the selected one. Lower is better); and the <code>root_clock_coefficient_of_variation</code> (how variable rates are, i.e., how non-ultrametric the tree is.) This is demonstrated below for an example where the rooted tree is ultrametric, and a case where it is very much not.</p>"},{"location":"rooting/#mad-statistics","title":"MAD statistics\u00b6","text":"<p>In this tree (shown in examples above) the values of each statistic are very low.</p>"},{"location":"rooting/#compare-mad-rootings","title":"Compare MAD rootings\u00b6","text":"<p>One of the real strengths of the MAD approach is that it not only finds the best edge on which to root a tree, but it also reports scores for all alternative rootings, and how much better one is than another. This is returned for each edge on the tree as a \"MAD\" and \"MAD_root_prob\" score. For example, in the tree below, the MAD score for the correct root position is 0.0, indicating that the tree is perfectly ultrametric when rooted at this position. The MAD rooting function correctly infers that this is the best root position, and assigns it as the root. The MAD_root_prob for this edge is 0.20 (the same probability is assigned to nodes 5 and 7, since they share edge on which the root node is placed. As we saw above, the global `root_ambiguity_index' for this rooting was 0.0, meaning that the 0.201 probability for this placement is significantly better than the 0.15 root probability for the next highest scoring edge.</p>"},{"location":"rooting/#check-root-status","title":"Check root status\u00b6","text":"<p>A method to check whether a tree is rooted based on resolution of the treenode. Note: this does not distinguish between a tree actually being rooted versus whether the treenode is a polytomy. This method simply returns a boolean for whether the root node has &gt;2 children. It is nevertheless still quite useful.</p>"},{"location":"rooting/#unrooting","title":"Unrooting\u00b6","text":"<p>The <code>unroot</code> function can be called to unroot a rooted tree. In an unrooted tree the treenode is always a polytomy. A rooted bifurcating tree has <code>nnodes = (ntips * 2) - 1</code>, whereas an unrooted bifurcating tree has nnodes = <code>(ntips * 2) - 2</code>. In other words, converting from a rooted to unrooted state removes one node (the former treenode) from the tree, and assigns an existing node as the new treenode.</p>"},{"location":"rooting/#featuresdata-and-rooting","title":"Features/Data and Rooting\u00b6","text":"<p>The processes of rooting, unrooting, or re-rooting trees should be reversible, meaning that the operations can be performed in any order without the loss of information about the topology, branch lengths, or any associated meta-data/features. This is the goal in <code>toytree</code> and it is always achieved for the case of the topology and branch lengths, but requires some user knowledge when dealing with arbitrary additional data features assigned to the tree.</p> <p>This is because data can be stored to a tree as either a feature of nodes, or of edges (see Node-vs-edge-features).</p> <p>Some data stored to a tree are intended to represent information about the edges (splits) in a tree, rather than information about the nodes. This is important as these types of data must be treated differently when doing things like re-rooting a tree, and in some cases, for visualization.</p> <p>(See the section on Information Loss for how other metadata in the tree can be affected, though.)</p>"},{"location":"rooting/#support-values","title":"Support values\u00b6","text":"<p>The way in which support values are displayed on trees is often a source of confusion. This is because support values are often plotted on the nodes of a tree, despite the fact that they are actually features of the edges of a tree. Thus, there are actually only</p> <p>A support score typically represents confidence in a bipartition that separates one  structure of the topology. However, support scores are often plotted on the nodes of a tree, which can lead to misinterpretation of their meaning, especially with regards to nodes near the root of a tree.</p> <p>For this reason, it is actually incorrect to list a support score for both edges that descend from the treenode of a rooted tree.</p>"},{"location":"rooting/#information-loss","title":"Information loss\u00b6","text":"<p>Is information lost when a tree is unrooted and then re-rooted? The answer is usually no, but there are instances in which data can be lost.</p>"},{"location":"rooting/#example-from-paper","title":"Example from paper\u00b6","text":"<p>This problem was well described in the \"A critical review on the use of support values in tree viewers and   bioinformatics toolkits\" by Czech et al. (2017).</p>"},{"location":"scratch/","title":"Scratch","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[2]: Copied! <pre># an example tree\ntree = toytree.rtree.unittree(ntips=5, seed=123)\n</pre> # an example tree tree = toytree.rtree.unittree(ntips=5, seed=123) In\u00a0[46]: Copied! <pre>import toyplot\n\npalette = toyplot.color.Palette(['red', 'green', 'blue'])\ncmap = toyplot.color.LinearMap(palette, domain_min=0, domain_max=1)\ncmap\n</pre> import toyplot  palette = toyplot.color.Palette(['red', 'green', 'blue']) cmap = toyplot.color.LinearMap(palette, domain_min=0, domain_max=1) cmap Out[46]: In\u00a0[50]: Copied! <pre>cmap.colors([0, 0.25, 0.5, 0.75, 1.0])\n</pre> cmap.colors([0, 0.25, 0.5, 0.75, 1.0]) Out[50]: In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[3]: Copied! <pre># set a color name as 'red' or 'blue' to all nodes for feature \"C\"\ntree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True);\ntree.get_node_data(\"C\")\n</pre> # set a color name as 'red' or 'blue' to all nodes for feature \"C\" tree.set_node_data(\"C\", {6: \"red\"}, inherit=True, default=\"blue\", inplace=True); tree.get_node_data(\"C\") Out[3]: <pre>0     red\n1     red\n2     red\n3    blue\n4    blue\n5     red\n6     red\n7    blue\n8    blue\ndtype: object</pre> In\u00a0[4]: Copied! <pre># set a color name as 'red' or 'blue' to all nodes for feature \"C\"\ntree.set_node_data(\"A\", {6: \"A\"}, inherit=True, default=\"B\", inplace=True);\ntree.get_node_data(\"A\")\n</pre> # set a color name as 'red' or 'blue' to all nodes for feature \"C\" tree.set_node_data(\"A\", {6: \"A\"}, inherit=True, default=\"B\", inplace=True); tree.get_node_data(\"A\") Out[4]: <pre>0    A\n1    A\n2    A\n3    B\n4    B\n5    A\n6    A\n7    B\n8    B\ndtype: object</pre> In\u00a0[5]: Copied! <pre># set random float values in (0-1) to all nodes for feature \"D\"\ntree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True);\ntree.get_node_data(\"D\")\n</pre> # set random float values in (0-1) to all nodes for feature \"D\" tree.set_node_data(\"D\", np.random.random(tree.nnodes), inplace=True); tree.get_node_data(\"D\") Out[5]: <pre>0    0.252134\n1    0.473288\n2    0.125519\n3    0.207844\n4    0.180335\n5    0.496407\n6    0.729994\n7    0.126836\n8    0.012640\ndtype: float64</pre> In\u00a0[6]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors='red');\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors='red'); r0r1r2r3r4 In\u00a0[7]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=(0, 1, 1, 0.5));\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=(0, 1, 1, 0.5)); r0r1r2r3r4 In\u00a0[8]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\"));\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=tree.get_node_data(\"C\")); r0r1r2r3r4 In\u00a0[9]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=\"C\");\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=\"C\"); r0r1r2r3r4 In\u00a0[10]: Copied! <pre>cvalues = tree.get_node_data(\"A\").values\ncvalues = [str(i) for i in cvalues]\ncvalues = [\"~~\" + i if i == \"nan\" else i for i in cvalues]\n\nnp.unique(cvalues, return_inverse=True)\n</pre> cvalues = tree.get_node_data(\"A\").values cvalues = [str(i) for i in cvalues] cvalues = [\"~~\" + i if i == \"nan\" else i for i in cvalues]  np.unique(cvalues, return_inverse=True) Out[10]: <pre>(array(['A', 'B'], dtype='&lt;U1'), array([0, 0, 0, 1, 1, 0, 0, 1, 1]))</pre> In\u00a0[11]: Copied! <pre>import toyplot\ncmap = toyplot.color.brewer.map(\"Spectral\")\n</pre> import toyplot cmap = toyplot.color.brewer.map(\"Spectral\") In\u00a0[12]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=\"D\");\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=\"D\"); r0r1r2r3r4 In\u00a0[14]: Copied! <pre># draw the tree entering node colors using the \"C\" discrete data feature\ntree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"Spectral\"));\n</pre> # draw the tree entering node colors using the \"C\" discrete data feature tree.draw(node_sizes=15, node_mask=False, node_colors=(\"D\", \"Spectral\")); r0r1r2r3r4 In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"test/","title":"Tree I/O","text":"<p>Tree data in its simplest form is very simple. Metadata can be very rich. Formats for storing trees has evolved over time. tldr; the <code>toytree.tree</code> function can flexibly parse most formats. newick, nexus, and NHX format.</p> <pre><code>import toytree\n</code></pre>"},{"location":"test/#parsing-tldr","title":"Parsing tldr;","text":"<pre><code># a simple newick string\nNEWICK = \"(((a,b),c),d);\"\n\n# load newick as a ToyTree object\ntree = toytree.tree(NEWICK)\nprint(tree)\n</code></pre> <pre><code>...\n</code></pre>"},{"location":"test/#from-a-string","title":"From a string","text":""},{"location":"test/#from-a-file","title":"From a file","text":""},{"location":"test/#from-a-url","title":"From a URL","text":""},{"location":"toytree/","title":"ToyTree","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># generate a random uniform tree\ntree = toytree.rtree.unittree(8, seed=123)\n</pre> # generate a random uniform tree tree = toytree.rtree.unittree(8, seed=123) In\u00a0[3]: Copied! <pre>tree[0]\n</pre> tree[0] Out[3]: <pre>&lt;Node(idx=0, name='r0')&gt;</pre> In\u00a0[4]: Copied! <pre>tree[1:3]\n</pre> tree[1:3] Out[4]: <pre>[&lt;Node(idx=1, name='r1')&gt;, &lt;Node(idx=2, name='r2')&gt;]</pre> In\u00a0[5]: Copied! <pre>for node in tree:\n    print(node)\n</pre> for node in tree:     print(node) <pre>&lt;Node(idx=0, name='r0')&gt;\n&lt;Node(idx=1, name='r1')&gt;\n&lt;Node(idx=2, name='r2')&gt;\n&lt;Node(idx=3, name='r3')&gt;\n&lt;Node(idx=4, name='r4')&gt;\n&lt;Node(idx=5, name='r5')&gt;\n&lt;Node(idx=6, name='r6')&gt;\n&lt;Node(idx=7, name='r7')&gt;\n&lt;Node(idx=8)&gt;\n&lt;Node(idx=9)&gt;\n&lt;Node(idx=10)&gt;\n&lt;Node(idx=11)&gt;\n&lt;Node(idx=12)&gt;\n&lt;Node(idx=13)&gt;\n&lt;Node(idx=14)&gt;\n</pre> In\u00a0[6]: Copied! <pre># show node idx labels of cached idxorder traversal\ntree.draw('p');\n</pre> # show node idx labels of cached idxorder traversal tree.draw('p'); 01234567891011121314r0r1r2r3r4r5r6r700.51 In\u00a0[7]: Copied! <pre># the root node\ntree.treenode\n</pre> # the root node tree.treenode Out[7]: <pre>&lt;Node(idx=14)&gt;</pre> In\u00a0[8]: Copied! <pre># also the root node\ntree[-1]\n</pre> # also the root node tree[-1] Out[8]: <pre>&lt;Node(idx=14)&gt;</pre> In\u00a0[9]: Copied! <pre># the root has no parent Node (.up returns None)\ntree.treenode.up\n</pre> # the root has no parent Node (.up returns None) tree.treenode.up <p>A rooted bifurcating tree has <code>nnodes = (ntips * 2) - 1</code>, whereas an unrooted bifurcating tree has <code>nnodes = (ntips * 2) - 2</code>. In other words converting from rooted to unrooted, or vice-versa, involves adding or removing a node from the tree. In an unrooted tree the root node is always a polytomy. (See the Tree rooting tutorial for further details.) This can be seen more clearly by plotting trees in an unrooted layout. The splits in the tree are the same regardless of the root node's placement. In the rooted tree (left) it is on a branch, and has two connected edges (a degree of 2). On the unrooted tree (right) it is on a node of the tree and connected to three edges (of degree 3).</p> In\u00a0[10]: Copied! <pre>toytree.mtree([tree, tree.unroot()]).draw(\n    layout='unr',\n    node_sizes=16, \n    node_labels=\"idx\",\n    node_mask=(0,0,1),\n);\n</pre> toytree.mtree([tree, tree.unroot()]).draw(     layout='unr',     node_sizes=16,      node_labels=\"idx\",     node_mask=(0,0,1), ); 14r0r1r2r3r4r5r6r713r0r1r2r3r4r5r6r7 In\u00a0[11]: Copied! <pre>tree.ntips\n</pre> tree.ntips Out[11]: <pre>8</pre> In\u00a0[12]: Copied! <pre>tree.nnodes\n</pre> tree.nnodes Out[12]: <pre>15</pre> In\u00a0[13]: Copied! <pre>tree.treenode\n</pre> tree.treenode Out[13]: <pre>&lt;Node(idx=14)&gt;</pre> In\u00a0[14]: Copied! <pre>tree.features\n</pre> tree.features Out[14]: <pre>('idx', 'name', 'height', 'dist', 'support')</pre> In\u00a0[15]: Copied! <pre>tree.edge_features\n</pre> tree.edge_features Out[15]: <pre>{'dist', 'support'}</pre> In\u00a0[16]: Copied! <pre># does the tree not contain any polytomies\ntree.is_bifurcating()\n</pre> # does the tree not contain any polytomies tree.is_bifurcating() Out[16]: <pre>True</pre> In\u00a0[17]: Copied! <pre># is the tree rooted\ntree.is_rooted()\n</pre> # is the tree rooted tree.is_rooted() Out[17]: <pre>True</pre> In\u00a0[18]: Copied! <pre># query if set of tip nodes is monophyletic\ntree.is_monophyletic(\"r3\", \"r2\", \"r1\"), tree.is_monophyletic(\"r3\", \"r2\", \"r1\", \"r0\")\n</pre> # query if set of tip nodes is monophyletic tree.is_monophyletic(\"r3\", \"r2\", \"r1\"), tree.is_monophyletic(\"r3\", \"r2\", \"r1\", \"r0\") Out[18]: <pre>(False, True)</pre> In\u00a0[19]: Copied! <pre># return a copy of the tree\ntree.copy()\n</pre> # return a copy of the tree tree.copy() Out[19]: <pre>&lt;toytree.ToyTree at 0x7ff02f48f520&gt;</pre> In\u00a0[20]: Copied! <pre># return a tree drawing as a (Canvas, Cartesian, Mark)\ntree.draw(ts='c')\n</pre> # return a tree drawing as a (Canvas, Cartesian, Mark) tree.draw(ts='c') Out[20]: <pre>(&lt;toyplot.canvas.Canvas at 0x7ff02f4cb550&gt;,\n &lt;toyplot.coordinates.Cartesian at 0x7ff02f37feb0&gt;,\n &lt;toytree.drawing.src.mark_toytree.ToyTreeMark at 0x7ff02f37df30&gt;)</pre> r0r1r2r3r4r5r6r700.51 In\u00a0[21]: Copied! <pre># return all ancestors of query nodes\ntree.get_ancestors(\"r4\", \"r5\")\n</pre> # return all ancestors of query nodes tree.get_ancestors(\"r4\", \"r5\") Out[21]: <pre>{&lt;Node(idx=4, name='r4')&gt;,\n &lt;Node(idx=5, name='r5')&gt;,\n &lt;Node(idx=11)&gt;,\n &lt;Node(idx=12)&gt;,\n &lt;Node(idx=14)&gt;}</pre> In\u00a0[22]: Copied! <pre># get dict mapping one feature to another\ntree.get_feature_dict('idx', 'name')\n</pre> # get dict mapping one feature to another tree.get_feature_dict('idx', 'name') Out[22]: <pre>{0: 'r0',\n 1: 'r1',\n 2: 'r2',\n 3: 'r3',\n 4: 'r4',\n 5: 'r5',\n 6: 'r6',\n 7: 'r7',\n 8: '',\n 9: '',\n 10: '',\n 11: '',\n 12: '',\n 13: '',\n 14: ''}</pre> In\u00a0[23]: Copied! <pre># get edges as a table\ntree.get_edges(feature=\"idx\", df=True)\n</pre> # get edges as a table tree.get_edges(feature=\"idx\", df=True) Out[23]: child parent 0 0 8 1 1 8 2 2 9 3 3 9 4 4 11 5 5 11 6 6 13 7 7 13 8 8 10 9 9 10 10 10 12 11 11 12 12 12 14 13 13 14 In\u00a0[24]: Copied! <pre># get mrca of a queried set of nodes\ntree.get_mrca_node(\"r4\", \"r5\")\n</pre> # get mrca of a queried set of nodes tree.get_mrca_node(\"r4\", \"r5\") Out[24]: <pre>&lt;Node(idx=11)&gt;</pre> In\u00a0[25]: Copied! <pre># get a DataFrame or Series of data from all nodes w/ formatting options\ntree.get_node_data()\n</pre> # get a DataFrame or Series of data from all nodes w/ formatting options tree.get_node_data() Out[25]: idx name height dist support 0 0 r0 0.00 0.25 NaN 1 1 r1 0.00 0.25 NaN 2 2 r2 0.00 0.25 NaN 3 3 r3 0.00 0.25 NaN 4 4 r4 0.00 0.50 NaN 5 5 r5 0.00 0.50 NaN 6 6 r6 0.00 0.75 NaN 7 7 r7 0.00 0.75 NaN 8 8 0.25 0.25 NaN 9 9 0.25 0.25 NaN 10 10 0.50 0.25 NaN 11 11 0.50 0.25 NaN 12 12 0.75 0.25 NaN 13 13 0.75 0.25 NaN 14 14 1.00 0.00 NaN In\u00a0[26]: Copied! <pre># get mask that is True for selected nodes and False for others\ntree.get_node_mask(0, 1, 2)\n</pre> # get mask that is True for selected nodes and False for others tree.get_node_mask(0, 1, 2) Out[26]: <pre>array([ True,  True,  True, False, False, False, False, False, False,\n       False, False, False, False, False, False])</pre> In\u00a0[27]: Copied! <pre># get nodes matching a query\ntree.get_nodes(\"~r[0-3]$\")\n</pre> # get nodes matching a query tree.get_nodes(\"~r[0-3]$\") Out[27]: <pre>[&lt;Node(idx=2, name='r2')&gt;,\n &lt;Node(idx=3, name='r3')&gt;,\n &lt;Node(idx=0, name='r0')&gt;,\n &lt;Node(idx=1, name='r1')&gt;]</pre> In\u00a0[28]: Copied! <pre># like get_node_data but only for tip (leaf) nodes\ntree.get_tip_data()\n</pre> # like get_node_data but only for tip (leaf) nodes tree.get_tip_data() Out[28]: idx name height dist support 0 0 r0 0.0 0.25 NaN 1 1 r1 0.0 0.25 NaN 2 2 r2 0.0 0.25 NaN 3 3 r3 0.0 0.25 NaN 4 4 r4 0.0 0.50 NaN 5 5 r5 0.0 0.50 NaN 6 6 r6 0.0 0.75 NaN 7 7 r7 0.0 0.75 NaN In\u00a0[29]: Copied! <pre># return the names for nodes idx 0-ntips in order\ntree.get_tip_labels()\n</pre> # return the names for nodes idx 0-ntips in order tree.get_tip_labels() Out[29]: <pre>['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7']</pre> In\u00a0[30]: Copied! <pre># return a hash str unique to this topology\ntree.get_topology_id()\n</pre> # return a hash str unique to this topology tree.get_topology_id() Out[30]: <pre>'535ff2bd575ed1f753d5b5f6340e8389'</pre> In\u00a0[31]: Copied! <pre># extract a subtree connecting tips r0, r1, r2, r3 and draw it\ntoytree.mod.extract_subtree(tree, \"~r[0-3]\").draw();\n</pre> # extract a subtree connecting tips r0, r1, r2, r3 and draw it toytree.mod.extract_subtree(tree, \"~r[0-3]\").draw(); r0r1r2r3 In\u00a0[32]: Copied! <pre># example of complex chained function calls\ncanvas, axes, mark = (tree\n    .root(\"r6\")\n    .mod.edges_scale_to_root_height(10)\n    .ladderize(True)\n    .set_node_data(\"name\", {-1: 'root'})\n    .draw(\n        node_labels=\"name\", node_mask=(0, 0, 1), node_sizes=18,\n        node_markers=\"r2x1\", node_colors=\"lightgrey\",\n        scale_bar=True, tip_labels_align=True,\n    )\n);\n</pre> # example of complex chained function calls canvas, axes, mark = (tree     .root(\"r6\")     .mod.edges_scale_to_root_height(10)     .ladderize(True)     .set_node_data(\"name\", {-1: 'root'})     .draw(         node_labels=\"name\", node_mask=(0, 0, 1), node_sizes=18,         node_markers=\"r2x1\", node_colors=\"lightgrey\",         scale_bar=True, tip_labels_align=True,     ) ); rootr0r1r2r3r4r5r7r61050 In\u00a0[33]: Copied! <pre># call drop_tips from the module-level\ntoytree.mod.drop_tips(tree, \"~r[4-6]\").draw();\n</pre> # call drop_tips from the module-level toytree.mod.drop_tips(tree, \"~r[4-6]\").draw(); r0r1r2r3r7 In\u00a0[34]: Copied! <pre># call drop_tips from the object-level\ntree.mod.drop_tips(\"~r[4-6]\").draw();\n</pre> # call drop_tips from the object-level tree.mod.drop_tips(\"~r[4-6]\").draw(); r0r1r2r3r7 In\u00a0[35]: Copied! <pre>tree.write()\n</pre> tree.write() Out[35]: <pre>'((((r0:0.25,r1:0.25):0.25,(r2:0.25,r3:0.25):0.25):0.25,(r4:0.5,r5:0.5):0.25):0.25,(r6:0.75,r7:0.75):0.25);'</pre> In\u00a0[36]: Copied! <pre># create a copy that we will modify the .style of\ntre = tree.copy()\n\n# set several style options on the tree\ntre.style.node_style.fill = \"black\"\ntre.style.node_style.stroke = \"white\"\ntre.style.node_style.stroke_width = 3\ntre.style.node_sizes = 12\ntre.style.node_mask = False\ntre.style.node_markers = \"v\"\ntre.style.edge_style.stroke = \"darkcyan\"\ntre.style.edge_style.stroke_width = 3\ntre.style.layout = 'd'\n\n# call draw and the .style will form the default tree style\ntre.draw(tree_style=None);\n</pre> # create a copy that we will modify the .style of tre = tree.copy()  # set several style options on the tree tre.style.node_style.fill = \"black\" tre.style.node_style.stroke = \"white\" tre.style.node_style.stroke_width = 3 tre.style.node_sizes = 12 tre.style.node_mask = False tre.style.node_markers = \"v\" tre.style.edge_style.stroke = \"darkcyan\" tre.style.edge_style.stroke_width = 3 tre.style.layout = 'd'  # call draw and the .style will form the default tree style tre.draw(tree_style=None); r0r1r2r3r4r5r6r7"},{"location":"toytree/#toytree","title":"ToyTree\u00b6","text":"<p>The <code>toytree.ToyTree</code> object is the main class in the <code>toytree</code> package. It contains a number of useful functions for interacting with the underlying <code>Node</code> structure (e.g., rooting, dropping tips), for storing and retrieving data (e.g., trait or support values), performing comparative or statistical analyses (e.g., tree distance metrics), and creating visualizations.</p> <p>Note: this section of the documentation is relatively short since many of the other sections of the documentation are about properties or methods of <code>ToyTree</code> objects.</p>"},{"location":"toytree/#generating-toytrees","title":"Generating ToyTrees\u00b6","text":"<p>A <code>ToyTree</code> is loaded in one of three ways: (1) by parsing tree data using <code>toytree.tree()</code> (see tree/io); (2) by generating a fixed or random tree with <code>toytree.rtree</code> (see rtree); or (3) by wrapping one or more <code>toytree.Node</code> objects in a <code>ToyTree</code> (see Building-trees-from-nodes). Follow the links for more details on each. We will use the random birth 8-tip unit tree generated below for this tutorial.</p>"},{"location":"toytree/#trees-are-indexable-and-iterable","title":"Trees are indexable and iterable\u00b6","text":"<p><code>Node</code> objects can be selected from <code>ToyTrees</code> in a variety of ways. See Node Query/selection for details.</p>"},{"location":"toytree/#cached-traversal","title":"Cached Traversal\u00b6","text":"<p>A <code>ToyTree</code> stores a cached traversal of all Nodes in the tree in idxorder (see Traversal order/methods). Briefly, a traversal involves visiting each node in a tree exactly once. This is used to assign a unique integer label to every node. The idx labels <code>0-ntips</code> are the tips, and from <code>ntips-nnodes-1</code> are the internal nodes. The <code>nnodes-1</code> idx label corresponds to the root.</p>"},{"location":"toytree/#the-tree-root-treenode","title":"The tree root (treenode)\u00b6","text":"<p>A <code>ToyTree</code> acts as a wrapper around a collection of connected <code>Node</code> objects. Of these nodes, one has a special designation as the root of the tree, whether or not the tree structure is rooted or unrooted. This node merely represents the top of the hierarchical structure of stored nodes. This node can be accessed like any other node by indexing or by name, and can also be accessed as the <code>.treenode</code> attribute of a <code>ToyTree</code>.</p>"},{"location":"toytree/#attributes","title":"Attributes\u00b6","text":"<p><code>ToyTree</code> attributes store information about the size of the tree, and are automatically updated by the <code>mod</code> functions when a tree structure is modified. The <code>features</code> and <code>edge_features</code> describe data stored to nodes of a tree and are further described in Data/Features.</p>"},{"location":"toytree/#methods","title":"Methods\u00b6","text":"<p>The <code>ToyTree</code> object has a number of methods available directly from object, as well as many additional methods organized into subpackages that are also accessible from a tree.</p>"},{"location":"toytree/#modifying-trees","title":"Modifying trees\u00b6","text":"<p>See the <code>mod</code> documentation section for details on tree modification methods. Many methods are available for modifying the topology, branch lengths, or other data on trees. These include common options like <code>.ladderize</code>, <code>.prune</code>, <code>.root</code>, <code>.collapse_nodes</code>, <code>edges_set_node_heights</code>, and many more. These functions are written to be very efficient, requiring the minimum number of tree traversals or modifications, and ensure the returned tree has proper node idx, height, and other node features updated.</p>"},{"location":"toytree/#chaining-methods","title":"Chaining methods\u00b6","text":"<p>Many methods of a <code>ToyTree</code> return a copy of the tree which are intended to make it easy to chain together multiple function calls to accomplish complex operations. For example, below the tree is re-rooted, scaled to a new crown height, ladderized, adds an internal node name, and then calls draw with many styling options including showing the new node name.</p>"},{"location":"toytree/#subpackage-api","title":"Subpackage API\u00b6","text":"<p>Many functions for working with trees are organized in subpackages. See their documentation sections for more details. Any of these methods which accept a toytree as their first argument are also accessible from a <code>ToyTree</code> object as a convenience. For example, <code>toytree.mod.func(tree)</code> is equivalent to <code>tree.mod.func()</code>. We refer to this as using the module-level API versus the object-level API.</p>"},{"location":"toytree/#writing-trees","title":"Writing trees\u00b6","text":"<p>See the Writing tree data documentation section. The function <code>write()</code> is used to write a tree to a newick or other format of serialized tree data, and to return it as a string or write to a file from a <code>ToyTree</code>, with options to also include metadata.</p>"},{"location":"toytree/#drawing-toytrees","title":"Drawing ToyTrees\u00b6","text":"<p>See the Tree Drawing documentation section for a detailed description of drawing options using the <code>.draw()</code> function.</p>"},{"location":"toytree/#style-dict","title":"Style dict\u00b6","text":"<p><code>ToyTree</code> objects have a <code>.style</code> dict-like object that can be used to view all options for styling tree drawings, and to modify their default drawing style. This is an optional convenience, it is often simpler to provide arguments directly to the <code>.draw()</code> function.</p>"},{"location":"traversal/","title":"traversal order/methods","text":"In\u00a0[1]: Copied! <pre>import toytree\n</pre> import toytree In\u00a0[2]: Copied! <pre># an example tree\ntree = toytree.rtree.unittree(8, seed=123)\n</pre> # an example tree tree = toytree.rtree.unittree(8, seed=123) In\u00a0[3]: Copied! <pre># traverse() is a generator function\ntree.traverse(strategy=\"levelorder\")\n</pre> # traverse() is a generator function tree.traverse(strategy=\"levelorder\") Out[3]: <pre>&lt;generator object ToyTree.traverse at 0x7f13e4c1e1f0&gt;</pre> In\u00a0[4]: Copied! <pre># unpacking the generator returns every Node visited once\nlist(tree.traverse(\"levelorder\"))\n</pre> # unpacking the generator returns every Node visited once list(tree.traverse(\"levelorder\")) Out[4]: <pre>[&lt;Node(idx=14)&gt;,\n &lt;Node(idx=12)&gt;,\n &lt;Node(idx=13)&gt;,\n &lt;Node(idx=10)&gt;,\n &lt;Node(idx=11)&gt;,\n &lt;Node(idx=6, name='r6')&gt;,\n &lt;Node(idx=7, name='r7')&gt;,\n &lt;Node(idx=8)&gt;,\n &lt;Node(idx=9)&gt;,\n &lt;Node(idx=4, name='r4')&gt;,\n &lt;Node(idx=5, name='r5')&gt;,\n &lt;Node(idx=0, name='r0')&gt;,\n &lt;Node(idx=1, name='r1')&gt;,\n &lt;Node(idx=2, name='r2')&gt;,\n &lt;Node(idx=3, name='r3')&gt;]</pre> In\u00a0[5]: Copied! <pre>def get_traversal_drawing(tree: toytree.ToyTree, strategy: str) -&gt; toytree.core.Canvas:\n    \"\"\"Return a tree drawing canvas showing a traversal strategy\"\"\"\n    \n    # create map of {node: int} in levelorder traversal\n    order = {j: i for (i, j) in enumerate(tree.traverse(strategy))}\n    \n    # set as data to the tree\n    tree.set_node_data(feature=strategy, data=order, inplace=True)\n    \n    # draw the tree showing the 'levelorder' feature on nodes\n    c, a, m = tree.draw(layout='d', node_sizes=18, node_labels=strategy, node_mask=False);\n    \n    # add label\n    a.label.text = f'\"{strategy}\" traversal'\n    return c\n</pre> def get_traversal_drawing(tree: toytree.ToyTree, strategy: str) -&gt; toytree.core.Canvas:     \"\"\"Return a tree drawing canvas showing a traversal strategy\"\"\"          # create map of {node: int} in levelorder traversal     order = {j: i for (i, j) in enumerate(tree.traverse(strategy))}          # set as data to the tree     tree.set_node_data(feature=strategy, data=order, inplace=True)          # draw the tree showing the 'levelorder' feature on nodes     c, a, m = tree.draw(layout='d', node_sizes=18, node_labels=strategy, node_mask=False);          # add label     a.label.text = f'\"{strategy}\" traversal'     return c In\u00a0[6]: Copied! <pre>get_traversal_drawing(tree, \"levelorder\")\n</pre> get_traversal_drawing(tree, \"levelorder\") Out[6]: 11121314910567834120r0r1r2r3r4r5r6r7\"levelorder\" traversal In\u00a0[7]: Copied! <pre>get_traversal_drawing(tree, \"preorder\")\n</pre> get_traversal_drawing(tree, \"preorder\") Out[7]: 45781011131436291120r0r1r2r3r4r5r6r7\"preorder\" traversal In\u00a0[8]: Copied! <pre>get_traversal_drawing(tree, \"postorder\")\n</pre> get_traversal_drawing(tree, \"postorder\") Out[8]: 01347811122569101314r0r1r2r3r4r5r6r7\"postorder\" traversal In\u00a0[9]: Copied! <pre>get_traversal_drawing(tree, \"idxorder\")\n</pre> get_traversal_drawing(tree, \"idxorder\") Out[9]: 01234567891011121314r0r1r2r3r4r5r6r7\"idxorder\" traversal In\u00a0[10]: Copied! <pre># node idx 0 represents the first node in an idxorder traversal\ntree[3]\n</pre> # node idx 0 represents the first node in an idxorder traversal tree[3] Out[10]: <pre>&lt;Node(idx=3, name='r3')&gt;</pre> In\u00a0[11]: Copied! <pre># node idx 10 represents the 11th node in an idxorder traversal\ntree[10]\n</pre> # node idx 10 represents the 11th node in an idxorder traversal tree[10] Out[11]: <pre>&lt;Node(idx=10)&gt;</pre> In\u00a0[12]: Copied! <pre>bigtree = toytree.rtree.rtree(ntips=300)\n</pre> bigtree = toytree.rtree.rtree(ntips=300) In\u00a0[13]: Copied! <pre>%%timeit\n# select tip nodes from the idxorder cache\n[i.name for i in bigtree[:bigtree.ntips]]\n</pre> %%timeit # select tip nodes from the idxorder cache [i.name for i in bigtree[:bigtree.ntips]] <pre>40.5 \u00b5s \u00b1 465 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</pre> In\u00a0[14]: Copied! <pre>%%timeit\n# perform a new traversal to visit each node\nnames = []\nfor node in bigtree.traverse(strategy=\"idxorder\"):\n    if node.is_leaf():\n        names.append(node.name)\n</pre> %%timeit # perform a new traversal to visit each node names = [] for node in bigtree.traverse(strategy=\"idxorder\"):     if node.is_leaf():         names.append(node.name) <pre>352 \u00b5s \u00b1 5.18 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</pre> In\u00a0[15]: Copied! <pre># trees are iterable and return nodes in idxorder\nfor node in tree:\n    pass\n\n# same as above\nfor node in tree[:]:\n    pass\n\n# nodes can be indexed using their idxorder idx labels\nfor idx in range(tree.nnodes):\n    node = tree[idx]\n\n# to iterate idxorder in reverse (root to tips)\nfor node in tree[::-1]:\n    pass\n</pre> # trees are iterable and return nodes in idxorder for node in tree:     pass  # same as above for node in tree[:]:     pass  # nodes can be indexed using their idxorder idx labels for idx in range(tree.nnodes):     node = tree[idx]  # to iterate idxorder in reverse (root to tips) for node in tree[::-1]:     pass In\u00a0[16]: Copied! <pre># for tip nodes\nfor idx in range(tree.ntips):\n    pass\n\n# for tip nodes\nfor node in tree[:tree.ntips]:\n    pass\n\n# for tip nodes\nfor node in tree:\n    if not node.is_leaf():\n        pass\n\n# tips in reverse order of how they will be plotted\nfor node in tree[:tree.ntips][::-1]:\n    pass\n\n# tips in reverse order of how they will be plotted\nfor node in tree[:tree.ntips:-1]:\n    pass\n</pre> # for tip nodes for idx in range(tree.ntips):     pass  # for tip nodes for node in tree[:tree.ntips]:     pass  # for tip nodes for node in tree:     if not node.is_leaf():         pass  # tips in reverse order of how they will be plotted for node in tree[:tree.ntips][::-1]:     pass  # tips in reverse order of how they will be plotted for node in tree[:tree.ntips:-1]:     pass In\u00a0[17]: Copied! <pre># for internal nodes\nfor idx in range(tree.ntips, tree.nnodes):\n    pass\n\n# for internal nodes\nfor node in tree[tree.ntips: tree.nnodes]:\n    pass\n\n# for internal nodes\nfor node in tree[:]:\n    if not node.is_leaf():\n        pass\n\n# for reverse order: root to last internal\nfor idx in range(tree.nnodes - 1, tree.ntips - 1, -1):\n    node = tree[idx]\n\n# for reverse order: root to last internal\nfor node in tree[tree.nnodes: tree.ntips:-1]:\n    pass\n</pre> # for internal nodes for idx in range(tree.ntips, tree.nnodes):     pass  # for internal nodes for node in tree[tree.ntips: tree.nnodes]:     pass  # for internal nodes for node in tree[:]:     if not node.is_leaf():         pass  # for reverse order: root to last internal for idx in range(tree.nnodes - 1, tree.ntips - 1, -1):     node = tree[idx]  # for reverse order: root to last internal for node in tree[tree.nnodes: tree.ntips:-1]:     pass"},{"location":"traversal/#traversal-ordermethods","title":"Traversal order/methods\u00b6","text":"<p>A key property of a tree data structure is the process of traversal, by which each Node is visited exactly once in a determined order. Traversal algorithms make it possible to calculate information on trees fast and efficiently, typically by performing calculations on parts of the tree which can be re-used in later calculations. Examples of this include summing branch lengths during traversal to measure distances between nodes, or the way in which Felsenstein's pruning algorithm calculates parsimony or likelihood scores while moving up a tree from tips towards the root.</p> <p>This section introduces different traversal algorithms, shows how they are implemented in <code>toytree</code>, and provides some demonstrations of how traversal can be used to write efficient functions. We also discuss the cached 'idxorder' traversal of <code>ToyTree</code> objects and show how this allows for fast and intuitive access to nodes in most situtations, as further demonstrated in the Node Query/Selection section.</p>"},{"location":"traversal/#why-traverse","title":"Why traverse?\u00b6","text":"<p>A <code>ToyTree</code> represents a container around a collection of connected <code>Node</code> objects. You can imagine that this collection of nodes could be stored in a variety of ways, such as a list or dictionary mapping names to nodes. But, either of these approaches would involve linearizing the node collection, rather than treating it hierarchically. And in each case, it would be necessary to choose the order in which to store the nodes, which raises the question of which order is the most useful, intuitive, or memorable.</p> <p>A traversal algorithm represents a set of rules for consistently iterating over Nodes in a tree to visit each Node exactly once. There are several common traversal algorithms designed to traverse trees, which we will cover shortly.</p> <p>Different strategies have advantages in different scenarios, such as when calculating data for a child that depends on the state of its parent, or vice versa. Similarly, when performing a search process over a tree that can be terminated when a particular target is found, it is more efficient to use a traversal strategy that is more likely to encounter the target earlier. Most algorithms for computing statistics on trees, fitting evolutionary models to trees, or searching trees involves a traversal. Learning the most common traversal strategies is thus valuable towards understanding how these methods work, and for developing new tree-based methods.</p> <p>The <code>traverse()</code> function of a <code>ToyTree</code> can be used to implement a tree traversal. This is a generator function, meaning it returns a generator that can be unpacked by iteration, and only generates each subsequent node in the traversal when requested.</p>"},{"location":"traversal/#traversal-strategies","title":"Traversal strategies\u00b6","text":"<p>Below I show the main traversal strategies in <code>toytree</code>: \"levelorder\", \"preorder\", \"postorder\", and \"idxorder\". Below is a custom function written to return a plot to visualize each traversal order shown as node labels on a tree.</p>"},{"location":"traversal/#levelorder-root-to-tips","title":"levelorder (root to tips)\u00b6","text":"<p>A levelorder traversal (also called a breadth-first search; BFS) is an algorithm that starts at the root and visits all Nodes at a given depth descended from the root before moving to the next level. (Note: depth here refers to distance in number of nodes, not branch lengths). The Nodes in each level are visited in left to right order in toytree, but the opposite could just as easily be implemented. The primary utility of this traversal strategy is that it is topologically sorted, such that a parent is always visited before any of its children.</p>"},{"location":"traversal/#preorder-root-to-tips","title":"preorder (root to tips)\u00b6","text":"<p>A preorder traversal is an example of a Depth-first search algorithm. It starts at the root Node and explores as far as possible along each descendant subtree before backtracking. The default in toytree is to visit the left subtree before the right subtree, such that the algorithm could be summarized as NLR (Node, left subtree, right subtree). The primary utility of this traversal strategy is that it is topologically sorted, such that a parent is always visited before any of its children. This property is also shared with levelorder traversal. The primary concern in distinguishing between these two strategies is if you plan to stop the traversal when a certain Node is found (e.g., to prevent having to traverse a very large set of Nodes), in which case the two will differ in the order in which they may find the stopping Node.</p>"},{"location":"traversal/#postorder-tips-to-root","title":"postorder (tips to root)\u00b6","text":"<p>A postorder traversal is also a Depth-first search algorithm, similar to preorder traversal, however it yields nodes from this traversal very differently. It starts by traversing down the left subtree from the root until it reaches a tip Node (i.e., no more left subtrees descend from the current Node), it then checks for a right subtree (sister), and then visits the current Node. As with other algorithms, it could similarly be designed to visit right before left. Given the implementation in toytree, this algorithm could be summarized as LRN (left subtree, right subtree, Node). The primary utility of this traversal strategy is that it is topologically sorted, such that all children are always visited before their parent. This is especially useful for algorithms where parent values are calculated dependent on their child values. In a phylogenetic context, this involves algorithms for calculating likelihoods of data observed at the tips, for inferring ancestral state reconstructions, node depth/height calculations, and many more.</p>"},{"location":"traversal/#idxorder-tips-to-root","title":"idxorder (tips to root)\u00b6","text":"<p>This is a custom traversal order used by toytree. It could similarly be called \"tips-first-then-postorder\" traversal, because it works by first visiting the tip Nodes from left to right, and then proceeds by visiting internal nodes in a postorder manner (left then right subtrees, then their parent). This traversal strategy turns out be particularly convenient for working with phylogenetic trees, since the tip Nodes represent the actual extant samples in our dataset, and are therefore usually of greatest interest. This strategy is also topologically sorted, such that children are always visited before their parents.</p> <p>This traversal thus makes it easier to select and find the tip Nodes by knowing that the first ntips Nodes in a tree will be the tips. This is not the case in any of the other tree traversal algorithms above.</p>"},{"location":"traversal/#using-a-cached-traversal","title":"Using a cached traversal\u00b6","text":"<p>Although we just learned that tree traversal algorithms are widely useful for working with tree data structures, I am now going to going to argue a slightly contrary point, which is that, for the purpose of writing super-efficient code, you should try to limit the number of tree traversals that must be performed.</p> <p>This is to say, if a tree isn't changed in some way (e.g., by modifying the topology or edge lengths), then a single tree traversal can be performed to cache the information about the tree structure (e.g., a specific traversal order), and any subsequent operations can make use of this cached information rather than traversing the entire tree again. This can make code run much faster since fetching information from a cache (e.g., a dictionary) is pretty much the fastest thing you can do in Python; much faster than traversing an entire tree. Of course, if the tree does change in some way (e.g., it is re-rooted) then a tree traversal will need to be performed to store the new structure and update the cached information again.</p> <p>This is one of the key properties of the <code>ToyTree</code> class. It stores a cached representation of the 'idxorder' traversal of the nodes, and this cache is automatically updated when the tree structure is modified. This makes it easy to write functions that can access all or a subset of nodes, such as just the tips, or just the internal nodes, for quickly traverse all nodes in a postorder-type traversal. This cache is the source of node \"idx\" labels.</p>"},{"location":"traversal/#speed-comparison","title":"Speed Comparison\u00b6","text":"<p>To make this point more clearly, let's walk through an example. Let's say that we want to access the names of every leaf Node in a tree. The two examples below compare selecting tip nodes from the cached idxorder versus performing a traversal of the entire tree. Both approaches are very fast, even on a large tree, but the cached traversal method is about 6X faster. This difference is not a big deal in this example, but it is good to be aware of, since some methods may require thousands of traversals over a tree.</p>"},{"location":"traversal/#common-traversals","title":"Common traversals\u00b6","text":"<p>Below are some common code snippets used to traverse all or parts of a tree:</p>"},{"location":"traversal/#iterate-over-all-nodes","title":"iterate over all nodes\u00b6","text":""},{"location":"traversal/#iterate-over-leaf-nodes","title":"iterate over leaf nodes\u00b6","text":"<p>The strategies below can be used to traverse over internal nodes in a tree (not leaf nodes) efficiently.</p>"},{"location":"traversal/#iterate-over-internal-nodes","title":"iterate over internal nodes\u00b6","text":"<p>The strategies below can be used to traverse over internal nodes in a tree (not leaf nodes) efficiently.</p>"},{"location":"try-it-now/","title":"Try it now","text":"<p>A simple way to get started with using and learning <code>toytree</code> is to jump inside an interactive Jupyter notebook and to follow along with the tutorials in the documentation.</p> <p>In fact, you can even try out <code>toytree</code> before installing it by launching an interactive notebook server running in the cloud that has <code>toytree</code> and many example notebooks pre-installed and loaded. Simply click the link below.</p> <p>Launch binder: toytree binder</p> <p></p>"},{"location":"write_trees/","title":"writing tree data","text":"In\u00a0[1]: Copied! <pre>import toytree\nimport numpy as np\n</pre> import toytree import numpy as np In\u00a0[3]: Copied! <pre># get a balanced 4-tip tree\ntree = toytree.rtree.baltree(ntips=4)\n\n# write the tree to serialized newick format\ntree.write()\n</pre> # get a balanced 4-tip tree tree = toytree.rtree.baltree(ntips=4)  # write the tree to serialized newick format tree.write() Out[3]: <pre>'((r0:0.5,r1:0.5):0.5,(r2:0.5,r3:0.5):0.5);'</pre> <p>Take Home</p> <p>       Write tree data to a serialized text format (Newick, NHX, Nexus) using tree.write(...).   </p> In\u00a0[4]: Copied! <pre># add internal node names as \"A\"\ntree.set_node_data(\"name\", {4: \"A\", 5: \"B\", 6: \"C\"}, inplace=True)\n\n# add internal node support values as 100\ntree.set_node_data(\"support\", {4: 100, 5: 90}, inplace=True)\n\n# add X as node feature with random float values\ntree.set_node_data(\"X\", np.random.normal(0, 2, tree.nnodes), inplace=True)\n\n# show the tree data\ntree.get_node_data()\n</pre> # add internal node names as \"A\" tree.set_node_data(\"name\", {4: \"A\", 5: \"B\", 6: \"C\"}, inplace=True)  # add internal node support values as 100 tree.set_node_data(\"support\", {4: 100, 5: 90}, inplace=True)  # add X as node feature with random float values tree.set_node_data(\"X\", np.random.normal(0, 2, tree.nnodes), inplace=True)  # show the tree data tree.get_node_data() Out[4]: idx name height dist support X 0 0 r0 0.0 0.5 NaN 3.241786 1 1 r1 0.0 0.5 NaN 0.669912 2 2 r2 0.0 0.5 NaN -3.078850 3 3 r3 0.0 0.5 NaN 1.993329 4 4 A 0.5 0.5 100.0 -2.234693 5 5 B 0.5 0.5 90.0 2.277798 6 6 C 1.0 0.0 NaN 0.931252 In\u00a0[3]: Copied! <pre># Newick str from using default arguments to write()\ntree.write()\n</pre> # Newick str from using default arguments to write() tree.write() Out[3]: <pre>'((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);'</pre> In\u00a0[4]: Copied! <pre># writes to file path, returns None\ntree.write(path=\"/tmp/test.nwk\")\n</pre> # writes to file path, returns None tree.write(path=\"/tmp/test.nwk\") In\u00a0[5]: Copied! <pre># write topology only set these args to None\ntree.write(path=None, dist_formatter=None, internal_labels=None)\n</pre> # write topology only set these args to None tree.write(path=None, dist_formatter=None, internal_labels=None) Out[5]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[6]: Copied! <pre># short-hand for simplest tree serialization\ntree.write(None, None, None)\n</pre> # short-hand for simplest tree serialization tree.write(None, None, None) Out[6]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[7]: Copied! <pre># hide edge lengths\ntree.write(dist_formatter=None, internal_labels=None)\n</pre> # hide edge lengths tree.write(dist_formatter=None, internal_labels=None) Out[7]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[8]: Copied! <pre># format edge lengths to show two fixed floating points\ntree.write(dist_formatter=\"%.2f\", internal_labels=None)\n</pre> # format edge lengths to show two fixed floating points tree.write(dist_formatter=\"%.2f\", internal_labels=None) Out[8]: <pre>'((r0:0.50,r1:0.50):0.50,(r2:0.50,r3:0.50):0.50);'</pre> In\u00a0[9]: Copied! <pre># format edge lengths to show max 4 floating points\ntree.write(dist_formatter=\"%.4g\", internal_labels=None)\n</pre> # format edge lengths to show max 4 floating points tree.write(dist_formatter=\"%.4g\", internal_labels=None) Out[9]: <pre>'((r0:0.5,r1:0.5):0.5,(r2:0.5,r3:0.5):0.5);'</pre> In\u00a0[10]: Copied! <pre># format edge lengths as integers\ntree.write(dist_formatter=\"%d\", internal_labels=None)\n</pre> # format edge lengths as integers tree.write(dist_formatter=\"%d\", internal_labels=None) Out[10]: <pre>'((r0:0,r1:0):0,(r2:0,r3:0):0);'</pre> In\u00a0[11]: Copied! <pre># None excludes internal labels\ntree.write(dist_formatter=None, internal_labels=None)\n</pre> # None excludes internal labels tree.write(dist_formatter=None, internal_labels=None) Out[11]: <pre>'((r0,r1),(r2,r3));'</pre> In\u00a0[12]: Copied! <pre># use support floats as internal labels\ntree.write(dist_formatter=None, internal_labels=\"support\")\n</pre> # use support floats as internal labels tree.write(dist_formatter=None, internal_labels=\"support\") Out[12]: <pre>'((r0,r1)100,(r2,r3)90);'</pre> In\u00a0[13]: Copied! <pre># use name str as internal labels\ntree.write(dist_formatter=None, internal_labels=\"name\")\n</pre> # use name str as internal labels tree.write(dist_formatter=None, internal_labels=\"name\") Out[13]: <pre>'((r0,r1)A,(r2,r3)B)C;'</pre> In\u00a0[14]: Copied! <pre># use other existing feature in tree as internal labels\ntree.write(dist_formatter=None, internal_labels=\"X\")\n</pre> # use other existing feature in tree as internal labels tree.write(dist_formatter=None, internal_labels=\"X\") Out[14]: <pre>'((r0,r1)-2.2019018558,(r2,r3)-1.51247041326)0.0903984949236;'</pre> In\u00a0[15]: Copied! <pre># None applies no string formatting\ntree.write(internal_labels_formatter=None)\n</pre> # None applies no string formatting tree.write(internal_labels_formatter=None) Out[15]: <pre>'((r0:0.5,r1:0.5):0.5,(r2:0.5,r3:0.5):0.5);'</pre> In\u00a0[16]: Copied! <pre># float format the 'support' values as max 12 floating points\ntree.write(internal_labels=\"support\", internal_labels_formatter=\"%.12g\")\n</pre> # float format the 'support' values as max 12 floating points tree.write(internal_labels=\"support\", internal_labels_formatter=\"%.12g\") Out[16]: <pre>'((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);'</pre> In\u00a0[17]: Copied! <pre># float format the 'support' values w/ 2 fixed floating points\ntree.write(internal_labels=\"support\", internal_labels_formatter=\"{:.2f}\")\n</pre> # float format the 'support' values w/ 2 fixed floating points tree.write(internal_labels=\"support\", internal_labels_formatter=\"{:.2f}\") Out[17]: <pre>'((r0:0.5,r1:0.5)100.00:0.5,(r2:0.5,r3:0.5)90.00:0.5);'</pre> In\u00a0[18]: Copied! <pre># float format the 'support' values as ints\ntree.write(internal_labels=\"support\", internal_labels_formatter=\"%d\")\n</pre> # float format the 'support' values as ints tree.write(internal_labels=\"support\", internal_labels_formatter=\"%d\") Out[18]: <pre>'((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);'</pre> In\u00a0[19]: Copied! <pre># see the features of a tree\ntree.features\n</pre> # see the features of a tree tree.features Out[19]: <pre>('idx', 'name', 'height', 'dist', 'support', 'X')</pre> In\u00a0[20]: Copied! <pre># see which features are edge (not node) data\ntree.edge_features\n</pre> # see which features are edge (not node) data tree.edge_features Out[20]: <pre>{'dist', 'support'}</pre> In\u00a0[21]: Copied! <pre># write NHX w/ \"X\" as node feature\ntree.write(features=[\"X\"])\n</pre> # write NHX w/ \"X\" as node feature tree.write(features=[\"X\"]) Out[21]: <pre>'((r0[&amp;X=0.608116507902]:0.5,r1[&amp;X=-1.12762954173]:0.5)100[&amp;X=-2.2019018558]:0.5,(r2[&amp;X=-3.42995006373]:0.5,r3[&amp;X=-1.19754491671]:0.5)90[&amp;X=-1.51247041326]:0.5)[&amp;X=0.0903984949236];'</pre> In\u00a0[22]: Copied! <pre># write NHX w/ \"support\" as edge feature\ntree.write(features=[\"support\"])\n</pre> # write NHX w/ \"support\" as edge feature tree.write(features=[\"support\"]) Out[22]: <pre>'((r0:0.5,r1:0.5)100:0.5[&amp;support=100],(r2:0.5,r3:0.5)90:0.5[&amp;support=90]);'</pre> In\u00a0[23]: Copied! <pre># write NHX string with one node metadata feature  \ntree.write(features=[\"X\"], features_formatter=\"%.3f\")\n</pre> # write NHX string with one node metadata feature   tree.write(features=[\"X\"], features_formatter=\"%.3f\") Out[23]: <pre>'((r0[&amp;X=0.608]:0.5,r1[&amp;X=-1.128]:0.5)100[&amp;X=-2.202]:0.5,(r2[&amp;X=-3.430]:0.5,r3[&amp;X=-1.198]:0.5)90[&amp;X=-1.512]:0.5)[&amp;X=0.090];'</pre> In\u00a0[24]: Copied! <pre># write tree in Newick format wrapped in Nexus\nnexus = tree.write(nexus=True)\nprint(nexus)\n</pre> # write tree in Newick format wrapped in Nexus nexus = tree.write(nexus=True) print(nexus) <pre>#NEXUS\nbegin trees;\n    translate\n        0 r0,\n        1 r1,\n        2 r2,\n        3 r3,\n    ;\n    tree 0 = [&amp;R] ((0:0.5,1:0.5)100:0.5,(2:0.5,3:0.5)90:0.5);\nend;\n</pre> In\u00a0[25]: Copied! <pre># write tree in NHX format wrapped in Nexus\nnexus = tree.write(features=[\"support\", \"name\", \"X\"], nexus=True, features_formatter=\"%.2f\")\nprint(nexus)\n</pre> # write tree in NHX format wrapped in Nexus nexus = tree.write(features=[\"support\", \"name\", \"X\"], nexus=True, features_formatter=\"%.2f\") print(nexus) <pre>#NEXUS\nbegin trees;\n    translate\n        0 r0,\n        1 r1,\n        2 r2,\n        3 r3,\n    ;\n    tree 0 = [&amp;R] ((0[&amp;name=r0,X=0.61]:0.5,1[&amp;name=r1,X=-1.13]:0.5)100[&amp;name=A,X=-2.20]:0.5[&amp;support=100.00],(2[&amp;name=r2,X=-3.43]:0.5,3[&amp;name=r3,X=-1.20]:0.5)90[&amp;name=B,X=-1.51]:0.5[&amp;support=90.00])[&amp;name=C,X=0.09];\nend;\n</pre> In\u00a0[26]: Copied! <pre># write tree to file as Nexus\ntree.write(path=\"/tmp/test.nex\", nexus=True)\n</pre> # write tree to file as Nexus tree.write(path=\"/tmp/test.nex\", nexus=True) In\u00a0[27]: Copied! <pre># create a MultiTree\nmtree = toytree.mtree([tree, tree, tree])\n</pre> # create a MultiTree mtree = toytree.mtree([tree, tree, tree]) In\u00a0[28]: Copied! <pre># write multi-Newick\nprint(mtree.write())\n</pre> # write multi-Newick print(mtree.write()) <pre>((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);\n((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);\n((r0:0.5,r1:0.5)100:0.5,(r2:0.5,r3:0.5)90:0.5);\n</pre>"},{"location":"write_trees/#writing-tree-data-io","title":"Writing tree data (I/O)\u00b6","text":"<p>Tree data can be serialized into a <code>str</code> as Newick, NHX, or NEXUS format using the <code>.write()</code> function, available as <code>toytree.io.write(tree, ...)</code> or from a ToyTree object as <code>tree.write(...)</code>. This function accepts several additional arguments to optionally format float data or include additional metadata, and to write the <code>str</code> result to a file path.</p>"},{"location":"write_trees/#example-data","title":"Example data\u00b6","text":"<p>To demonstrate, let's start by generating a <code>ToyTree</code> with several types of node and edge data to use for examples. Here we are assigning names to all internal nodes, support values to internal nodes/edges except the root, and a feature named \"X\" with a random float value to every node.</p>"},{"location":"write_trees/#the-write-function","title":"The write function\u00b6","text":"<p>The default arguments to the <code>.write()</code> function return a newick string with edge lengths (if present) formatted as <code>\"%.12g\"</code>, with internal labels as <code>\"support\"</code> values (if present) formatted as <code>\"%.12g\"</code>, and no additional features (metadata). However, all of these options can be modified, as demonstrated below.</p>"},{"location":"write_trees/#path-save-to-disk","title":"path: save to disk\u00b6","text":"<p>The first argument to <code>write()</code> is <code>path</code>, which accepts a file path as a <code>str</code>, <code>Path</code>, or None. If a <code>path</code> is entered then the data will be written to the designated file path and None is returned. If <code>path=None</code> then nothing is written to file and the serialized tree data <code>str</code> will be returned (like above). This can be useful when you want to store the <code>str</code> data as a variable and do something with it. I use the default arg <code>path=None</code> throughout the rest of this document after this example for demonstration.</p>"},{"location":"write_trees/#newick","title":"Newick\u00b6","text":"<p>As we saw above, the default output format of <code>.write</code> is a Newick str, and when called with the default arguments it writes the dist edge lengths as well as internal node labels. By modifying these arguments you can either suppress these additional data or modify their formatting.</p>"},{"location":"write_trees/#dist_formatter-edge-lengths","title":"dist_formatter: edge lengths\u00b6","text":"<p>The <code>dist_formatter</code> argument can be used to include or exclude edge lengths, and to format the edge lengths if they are included. By setting <code>dist_formatter=None</code> edge lengths are not shown. Formatting of branch lengths takes a Python formatting string in one of two supported formats, using percent sign or curly brackets, e.g., <code>\"%.12g\"</code> or <code>\"{:.12g}\"</code>. See the Python documentation for further explanation of Python string formatting (or this resource). Here I set <code>internal_labels=None</code> just to hide internal labels to make it easier to see the edge lengths.</p>"},{"location":"write_trees/#internal_labels","title":"internal_labels\u00b6","text":"<p>As discussed in the Parsing tree data docs, the internal label in a newick string can be ambiguous in its usage for storing either internal node names, edge support values, or possibly other types of data. The <code>internal_labels</code> arg takes a str feature name as an argument. A <code>ToyTree</code> always has \"name\" and \"support\" features that can be selected, and if empty, they will be ignored. Here I set <code>dist_formatter=None</code> just to hide edge lengths to make it easier to see the internal_labels.</p>"},{"location":"write_trees/#internal_labels_formatter","title":"internal_labels_formatter\u00b6","text":"<p>Similar to the <code>dist_formatter</code> arg above, you can similarly apply string formatting to <code>internal_labels</code> when they are floats. This has no effect on internal names, but is useful for support, or other features.</p>"},{"location":"write_trees/#write-nhx","title":"Write NHX\u00b6","text":"<p>The extended New Hampshire format (NHX) is simply an extension of the Newick format with metadata stored inside square brackets after nodes and/or edges. The data/features in a <code>ToyTree</code> represent any data stored to one or more <code>Node</code> objects of the tree (see Data/Features). These data may have been generated by some analysis tool, or could be stored manually in <code>toytree</code>. You can view the features of a <code>ToyTree</code> using <code>get_node_data()</code>, which shows data for each Node for each feature. You can view the features by calling <code>.features</code> and see which subset of features apply to edges by calling <code>.edge_features</code>. This is important to note because the <code>.write()</code> function will append edge features as metadata to edges, and node features as metadata to nodes in the NHX format.</p>"},{"location":"write_trees/#features","title":"features\u00b6","text":""},{"location":"write_trees/#features_formatting","title":"features_formatting\u00b6","text":""},{"location":"write_trees/#write-nexus","title":"Write NEXUS\u00b6","text":"<p>Converting tree data into NEXUS format is trivial, simply add the <code>nexus=True</code> argument to write. You can still use any of the formatting options above to format the Newick/NHX string, but it will now be written inside a \"trees\" block, with names translated into integers, with a translation section, and with a \"#NEXUS\" header.</p>"},{"location":"write_trees/#write-multitrees","title":"Write MultiTrees\u00b6","text":"<p>MultiTrees have a <code>.write()</code> function that works very similarly to the <code>ToyTree.write</code> but applies to each tree in order. A multi- Newick file contains trees separated by newline characters, whereas a multi Nexus file contains trees labels by increasing number in the trees block.</p>"}]}